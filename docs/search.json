[
  {
    "objectID": "Numpy_Basic.html",
    "href": "Numpy_Basic.html",
    "title": "Introduction to NumPy and Matplotlib",
    "section": "",
    "text": "Numpy는 선형 대수학 및 기타 과학 컴퓨팅 영역에 필요한 계산을 수행하는 데 필수적인 Python 패키지입니다. Matplotlib은 다양한 그래프를 생성하기 위한 Python 패키지입니다. 선형 대수학에서 접하게 되는 많은 계산에는 NumPy가 사용되지만, 개념을 시각적으로 유용하게 표현하기 위해서만 Matplotlib을 활용하는 것을 권장합니다."
  },
  {
    "objectID": "Numpy_Basic.html#numpy",
    "href": "Numpy_Basic.html#numpy",
    "title": "Introduction to NumPy and Matplotlib",
    "section": "NumPy",
    "text": "NumPy\n선형 대수에서 하는 거의 모든 계산은 숫자 배열을 다루는 작업이 포함됩니다. 배열은 행과 열로 배열되어 직사각형을 이루는 숫자의 집합으로 생각할 수 있는데, 아래 예는 행 2개와 열 4개로 이루어진 배열입니다.\n\\[\n\\begin{matrix}\n\\left[ \\begin{array}{rrrr} 5 & -1 & 1 & 0 \\\\ 4 & 3 & 12 & -6 \\end{array}\\right]\n\\end{matrix}\n\\]\n파이썬의 List 객체를 사용하여 배열을 표현할 수도 있지만, NumPy 배열 객체를 사용하겠습니다. NumPy는 배열을 표현하는 강력한 방법을 가지고 있으며, 배열을 효율적으로 처리하기 위한 많은 내장 도구가 있습니다. 수학 모듈과 마찬가지로, NumPy를 사용하기 전에 해당 패키진를 가져와야 합니다. 이번에는 모듈을 가져오되 입력하기 더 편리한 별칭이라고 하는 다른 이름을 지정하는 \\(\\texttt{import numpy as np}\\) 코드를 사용하겠습니다.\n위의 배열을 만드는 가장 쉬운 방법은 \\(\\texttt{array}\\) 함수를 사용하여 특정 형식의 모든 배열 항목 목록을 제공하는 것입니다. 행 항목은 쉼표로 구분하고 대괄호 []로 묶은 다음, 나열된 모든 행을 쉼표로 구분하고 또 다른 대괄호로 묶습니다.\n\nimport numpy as np\n\nA = np.array([[5, -1, 1, 0],[4, 3, 12, -6]])\nprint(A)\n\n[[ 5 -1  1  0]\n [ 4  3 12 -6]]\n\n\n원하는 배열을 만드는 또 다른 방법은 먼저 하나의 긴 행으로 된 배열을 만든 다음 \\(\\texttt{reshape}\\) 함수를 사용하는 것입니다. 대괄호를 추가로 입력하는 것보다 더 편리할 수 있습니다.\n\nB = np.array([5, -1, 1, 0, 4, 3, 12, -6])\nprint(\"This is B before reshaping.\")\nprint(B)\n\nC = B.reshape((2,4))\nprint(\"This is C, which is the entries of B formed into a new shape.\")\nprint(C)\n\nThis is B before reshaping.\n[ 5 -1  1  0  4  3 12 -6]\nThis is C, which is the entries of B formed into a new shape.\n[[ 5 -1  1  0]\n [ 4  3 12 -6]]\n\n\n우리는 종종 원본의 복사본을 유지하면서 배열을 수정하고 싶을 때가 있습니다. 이 경우 \\(\\texttt{copy}\\) 함수를 사용하여 기존 배열을 복제할 수 있습니다.\n\nD = np.copy(A)\nprint(D)\n\n[[ 5 -1  1  0]\n [ 4  3 12 -6]]\n\n\n배열의 개별 항목에 액세스하려면 한 쌍의 인덱스를 사용하여 액세스하려는 항목의 행과 열을 참조해야 합니다. 거의 모든 다른 컴퓨팅 언어와 마찬가지로 Python에서도 인덱스는 0부터 시작합니다! 즉, 첫 번째 행은 인덱스가 0이고 두 번째 행은 인덱스가 1이라는 뜻입니다. 열도 마찬가지입니다. 0에서 카운트를 시작하는 것은 어렵지 않지만, 프로그래밍을 처음 접하는 사람이라면 사고의 전환이 필요합니다.\n\nprint(A[0,2])\n\n1\n\n\n개별 배열 값에 새 번호를 할당하여 수정할 수 있습니다.\n\nA[0,2] = 8\nprint(A)\n\n[[ 5 -1  8  0]\n [ 4  3 12 -6]]\n\n\n때로는 대부분 0이 포함된 배열을 만드는 것이 유용할 때가 있습니다. 이 경우 모든 0이 포함된 배열을 만든 다음 0이 아닌 항목 몇 개를 수정할 수 있습니다.\n\n## Create a 4x4 array that is all zeros.\nD = np.zeros((4,4))\n## Set entries along the main diagonal to 2.\nfor i in range(4):\n    D[i,i] = 2\n    \nprint(D)\n\n[[2. 0. 0. 0.]\n [0. 2. 0. 0.]\n [0. 0. 2. 0.]\n [0. 0. 0. 2.]]\n\n\nNumPy에 포함된 많은 함수는 어떤 식으로든 선형 대수와 관련이 있습니다. 해당 선형대수 주제를 진행하면서 이러한 함수를 더 많이 시연해 보겠습니다.\n\nRandom module\n코드를 테스트하는 한 가지 방법은 많은 무작위 입력을 제공한 다음 각 인스턴스에서 올바른 결과가 생성되는지 확인하는 것입니다. 무작위 입력을 생성하기 위해 NumPy에 포함된 \\(\\texttt{random}\\) 모듈의 함수를 사용할 것입니다. 예를 들어, 인수가 없는 \\(\\texttt{rand}\\) 함수를 사용하여 0과 1 사이의 난수를 생성할 수 있습니다.\n\nr = np.random.rand()\nprint(r)\n\n0.6983335663800959\n\n\ntexttt{rand}$ 함수를 실행할 때마다 새로운 난수를 산출합니다. texttt{rand}$는 \\(\\texttt{random}\\) 모듈에 포함된 함수이며, 이 모듈은 다시 NumPy에 포함되어 있다는 점에 유의하세요. 따라서 접근하려면 점 표기법을 두 번 사용해야 합니다.\n또한 배열의 행과 열 수를 지정하는 두 개의 인수를 \\(\\texttt{rand}\\)에 전달하여 임의의 숫자 배열을 생성할 수도 있습니다.\n\nX = np.random.rand(3,2)\nprint(X)\n\n[[0.19443351 0.05665268]\n [0.37579411 0.92505324]\n [0.66751134 0.75502419]]\n\n\n임의의 정수를 생성하려면 \\(\\texttt{randint}\\) 함수를 사용할 수 있습니다. 이 함수에는 생성되는 숫자의 상한을 지정하는 인수가 하나 이상 필요합니다. 아래 코드는 0에서 19 사이의 정수 중에서 난수를 생성합니다.\n\nprint(np.random.randint(20))\n\n16\n\n\n무작위 배열을 생성하려면 \\(\\texttt{size}\\)라는 키워드 인수를 사용하여 행과 열의 개수를 지정해야 합니다. 키워드 인수*를 사용하려면 다음 예시와 같이 약간 다른 구문이 필요합니다.\n\nY = np.random.randint(10,size=(3,6))\nprint(Y)\n\n[[9 1 7 8 2 5]\n [4 6 0 9 7 0]\n [2 3 3 6 7 7]]\n\n\n파이썬 함수에서 키워드 인자를 사용하는 것은 매우 일반적입니다. 이 기능의 장점은 인수를 미리 지정된 순서대로 제공할 필요가 없다는 것입니다.\n\nprint(np.random.randint(size=(2,3),high=10,low=1))\n\n[[1 5 5]\n [4 3 8]]\n\n\n또한 \\(\\texttt{random}\\) 모듈에는 지정된 컬렉션에서 무작위로 선택된 값을 생성할 수 있는 \\(\\texttt{choice}\\)라는 함수가 있습니다. 이 함수는 숫자 목록을 인수로 받아 해당 목록에서 무작위로 선택된 값을 반환합니다.\n\nx = np.random.choice([0,3,7,42])\nprint(x)\n\n42\n\n\n또한 \\(\\texttt{choice}\\) 함수를 사용하여 지정된 컬렉션의 값으로 구성된 숫자 배열을 생성할 수도 있습니다. 이 경우 다시 \\(\\texttt{size}\\) 키워드 인수를 사용하면 됩니다.\n\nX = np.random.choice([0,3,7,42], size = (2,3))\nprint(X)\n\n[[ 7  7 42]\n [ 7 42  0]]"
  },
  {
    "objectID": "Numpy_Basic.html#matplotlib",
    "href": "Numpy_Basic.html#matplotlib",
    "title": "Introduction to NumPy and Matplotlib",
    "section": "Matplotlib",
    "text": "Matplotlib\nMatplotlib은 다양한 플로팅 기능과 생성된 그림을 정밀하게 사용자 정의할 수 있는 다양한 옵션을 제공합니다. 여기서는 Jupyter 선형 대수학 가이드에 나오는 특정 유형의 그림을 만드는 방법에 대한 설명만 제공하며, 대부분은 동일한 필수 패턴을 따릅니다. 필요한 코드에 대한 몇 가지 세부 사항을 제공하지만 데이터 구조를 엄격하게 설명하거나 라이브러리 내에서 사용할 수 있는 다양한 옵션에 대해 논의하지는 않습니다.\n\nExample 1\n첫 번째 그림에서는 \\((x,y)\\) 좌표가 있는 네 점의 간단한 플롯을 만들겠습니다. 좌표 목록은 NumPy 배열에 저장됩니다.\n\nx = np.array([1, 2.5, 3, 5.8])\ny = np.array([2, 1.2, 1.1, 0.8])\n\n다음 코드 셀에는 플롯을 생성하는 데 필요한 최소한의 지침이 포함되어 있습니다. 셀의 주석은 각 줄의 목적을 나타냅니다.\n\nimport matplotlib.pyplot as plt\n\n%config InlineBackend.figure_format = 'retina'\n\nfig, ax = plt.subplots()\nax.plot(x,y);\n\n\n\n\n\\(texttt{subplots}\\) 메서드는 그림과 축이라는 두 개의 Matplotlib 객체를 생성합니다. 그림은 Matplotlib의 기본 객체입니다. 축 객체는 그림 안에 포함되어 있으며, 우리가 가장 많이 상호작용할 객체입니다. 축 객체의 \\(\\texttt{plot}\\) 메서드는 실제로 좌표 집합을 축에 플롯하는 함수입니다. 결과를 보기 위해 \\(\\texttt{print}\\) 명령이 필요하지 않다는 점에 유의하세요.\n이 기본적인 \\(\\texttt{plot}\\) 메서드 사용으로 생성된 플롯은 데이터 포인트 좌표를 선으로 연결했습니다. 이것이 이 메서드의 기본 기능입니다. Matplotlib 메서드(그리고 실제로 다른 많은 파이썬 라이브러리의 메서드)는 최소한의 인수를 제공하여 생성되는 기본 기능을 가지고 있지만, 이 기본 기능을 변경하는 추가 인수를 제공할 수 있는 것이 일반적입니다. 이 예제에서는 \\(\\texttt{plot}\\) 메서드에 선택적 인수 \\(\\texttt{'b+'}\\)를 제공하여 데이터 좌표를 연결하는 선 대신 파란색 + 기호가 있는 플롯을 생성할 수 있습니다.\n\nfig, ax = plt.subplots()\nax.plot(x,y,'b+');\n\n\n\n\n데이터 요소를 플로팅하는 데 관심이 있는 경우 또 다른 대안은 동일한 구문을 사용할 수 있는 \\(\\texttt{scatter}\\) 메서드입니다.\n\nfig, ax = plt.subplots()\nax.scatter(x,y);\n\n\n\n\n다음은 이러한 플롯에서 사용할 수 있는 여러 옵션 중 일부를 구성하는 방법을 보여드리겠습니다. 플롯은 실제로 축 객체에서 구성되므로 플롯의 요소에 영향을 주는 모든 옵션은 해당 객체의 메서드라는 점을 기억하세요.\n\nfig, ax = plt.subplots()\nax.plot(x,y,'rx');\n\nax.set_xlim(0,8);\nax.set_ylim(0,4);\n\nax.grid(True);\n\nax.set_xlabel('Time');\nax.set_ylabel('Concentration');\n\n\n\n\n\nExample 2\n다음 예제에서는 \\([-2,4]\\) 간격의 \\(x\\)에 대한 곡선 \\(y=0.5x^2\\)를 플롯하는 것이 목표입니다. 동일한 방법을 사용하려면 주어진 간격에서 \\(x\\)에 대해 곡선 위에 놓이는 점 집합을 생성해야 합니다. 지정하는 점들은 직선으로 연결되므로 곡선이 들쭉날쭉한 모양이 되지 않도록 충분한 점을 생성해야 합니다. NumPy 메서드 \\(\\texttt{linspace}\\)는 점을 쉽게 생성할 수 있는 방법을 제공합니다. 이 메서드는 지정된 간격으로 숫자가 균등하게 배치된 NumPy 배열 객체를 생성합니다.\n\nx = np.linspace(-2,4,9)\nprint(x)\n\ny = 0.5*x**2\nprint(y)\n\n[-2.   -1.25 -0.5   0.25  1.    1.75  2.5   3.25  4.  ]\n[2.      0.78125 0.125   0.03125 0.5     1.53125 3.125   5.28125 8.     ]\n\n\n이 플롯에서는 매끄럽게 보이는 곡선을 생성하기 위해 더 많은 수의 점을 사용합니다. 또한 \\(x\\) 및 \\(y\\) 축을 따라 틱을 구성하는 등 몇 가지 다른 옵션을 사용하여 이 플롯의 모양을 조정합니다. 눈금은 축을 따라 격자선과 숫자 레이블을 정의하는 숫자 목록입니다. texttt{plot}$ 메서드는 ticks*의 기본값을 제공하며, 새 값의 배열을 제공하여 변경할 수 있습니다.\n\nx = np.linspace(-2,4,100)\ny = 0.5*x**2\n\nfig, ax = plt.subplots()\nax.plot(x,y);\n\nax.set_xlim(-2,4);\nax.set_ylim(0,8);\n\nax.grid(True,ls='dotted');\n\nax.set_aspect('equal');\n\nax.set_xticks(np.linspace(-2,4,4));\nax.set_yticks(np.linspace(0,8,5));\n\n\n\n\n\nfig, ax = plt.subplots()\nax.plot(x,y,'g',ls='dashed');\n\nax.set_xlim(-3,5);\nax.set_ylim(-1,9);\n\nax.grid(True,ls='dotted');\n\nax.set_aspect('equal');\n\nax.set_xticks(np.linspace(-3,5,9));\nax.set_yticks(np.linspace(-1,9,11));\n\nax.axvline(color='k',linewidth = 1);\nax.axhline(color='k',linewidth = 1);"
  },
  {
    "objectID": "04_Inverse_Matrices.html",
    "href": "04_Inverse_Matrices.html",
    "title": "역행렬",
    "section": "",
    "text": "행렬 형식으로 작성된 연립 선형 방정식에 대해서 다시 한 번 생각해보도록 하겠습니다.\n\\[\nAX = B\n\\]\n다시 말하지만, \\(A\\)는 계수행렬이고, \\(B\\)는 미지수 벡터이며, \\(X\\)는 상수 벡터입니다. 만약 \\(A\\), \\(B\\), \\(X\\)가 숫자로만 이루어진다면, 우리는 \\(X\\)를 해결하는 방법이 방정식의 양변을 \\(A\\)로 나누는 것임을 즉시 알 수 있습니다(\\(A\\neq 0\\)이면). 이 시스템에 대해 자연스럽게 던질 수 있는 질문은 “행렬 나누기를 정의할 수 있는가?”입니다.\n대부분이 아는 것 처럼 당연히 아니다 입니다. 하지만 \\(A\\), \\(B\\), \\(X\\)가 숫자인 경우 \\(1/A\\)를 곱하면 해를 구할 수 있다는 점을 이해하면 진전을 이룰 수 있습니다. 이 미묘한 차이가 중요한 이유는 나눗셈을 정의할 필요가 없다는 것을 의미하기 때문입니다. 우리는 \\(A\\)를 곱하면 1이 되는 숫자만 찾으면 됩니다. 이 숫자를 \\(A\\)의 곱셈 역수라고 하며, \\(A\\neq 0\\)인 경우 \\(1/A\\)로 표기합니다.\n이 아이디어를 \\(A\\), \\(B\\), \\(X\\)가 행렬인 상황으로 확장할 수 있습니다. \\(AX=B\\) 시스템을 풀기 위해 \\(A\\)를 곱하면 행렬 \\(I\\)가 되는 특정 행렬을 곱하고 싶습니다. 이 행렬을 역행렬이라고 하며, 기호는 \\(A^{-1}\\)입니다.\n\\(A\\)가 정방행렬인 경우 \\(A^{-1}\\)(“A의 역행렬, A inverse”으로 읽음)를 다음이 참인 행렬로 정의합니다.\n\\[\nA^{-1}A = I \\hspace{3cm}AA^{-1} = I\n\\]"
  },
  {
    "objectID": "04_Inverse_Matrices.html#역행렬의-구성",
    "href": "04_Inverse_Matrices.html#역행렬의-구성",
    "title": "역행렬",
    "section": "역행렬의 구성",
    "text": "역행렬의 구성\n\\(C\\)를 예제를 통해서 역행렬을 어떻게 만들 수 있는지 생각해 보겠습니다.\n\\[\nC = \\left[ \\begin{array}{rrrr} 1 & 0 & 2 & -1 \\\\ 3 & 1 & -3 & 2 \\\\ 2 & 0 & 4 & 4 \\\\ 2 & 1 & -1 & -1 \\end{array}\\right]\n\\]\n행렬 곱 \\(CC^{-1}= I\\)를 \\(C^{-1}\\)의 열에 대해 생각해 봅시다. 예를 들어 세 번째 열에 초점을 맞추고, 알 수 없는 항목에는 \\(y_i\\)로 레이블을 지정합니다. 알 수 없는 * 항목도 있지만 지금은 무시하겠습니다.\n\\[\nCC^{-1}=\n\\left[ \\begin{array}{rrrr} 1 & 0 & 2 & -1 \\\\ 3 & 1 & -3 & 2 \\\\ 2 & 0 & 4 & 4 \\\\ 2 & 1 & -1 & -1 \\end{array}\\right]\n\\left[ \\begin{array}{rrrr} * & * & y_1& * \\\\ * & * & y_2 & * \\\\ * & * & y_3 & * \\\\ * & * & y_4 & *  \\end{array}\\right]=\n\\left[ \\begin{array}{rrrr} 1 & 0 & 0 & 0 \\\\ 0 & 1 & 0 & 0 \\\\ 0 & 0 & 1 & 0 \\\\ 0 & 0 & 0 & 1 \\end{array}\\right]=\nI\n\\]\n이제 \\(C\\)에 \\(C^{-1}\\)의 세 번째 열을 곱하면 \\(I\\)의 세 번째 열이 나온다는 것을 기억하세요. 이렇게 하면 \\(y_i\\)를 풀 수 있는 선형 시스템이 생깁니다.\n\\[\n\\left[ \\begin{array}{rrrr} 1 & 0 & 2 & -1 \\\\ 3 & 1 & -3 & 2 \\\\ 2 & 0 & 4 & 4 \\\\ 2 & 1 & -1 & -1 \\end{array}\\right]\n\\left[ \\begin{array}{r}  y_1 \\\\  y_2  \\\\ y_3 \\\\ y_4  \\end{array}\\right]=\n\\left[ \\begin{array}{r}  0 \\\\  0  \\\\ 1 \\\\ 0  \\end{array}\\right]\n\\]\n\nimport numpy as np\nimport linear_solver as ls\n\n\n## Solve CY = I3\nC = np.array([[1,0,2,-1],[3,1,-3,2],[2,0,4,4],[2,1,-1,-1]])\nI3 = np.array([[0],[0],[1],[0]])\nY3 = ls.solve_system(C,I3)\nprint(Y3)\n\n[[-0.16666667]\n [ 0.66666667]\n [ 0.16666667]\n [ 0.16666667]]\n\n\n\\(C^{-1}\\)의 다른 열은 동일성 행렬의 해당 열로 유사한 시스템을 풀면 찾을 수 있습니다. 그런 다음 열을 하나의 행렬로 조합하여 \\(C^{-1}\\)를 만들고, \\(C^{-1}C\\)와 \\(CC^{-1}\\)의 곱을 확인하여 결과를 테스트할 수 있습니다.\n\nI1 = np.array([[1],[0],[0],[0]])\nI2 = np.array([[0],[1],[0],[0]])\nI4 = np.array([[0],[0],[0],[1]])\n\nY1 = ls.solve_system(C,I1)\nY2 = ls.solve_system(C,I2)\nY4 = ls.solve_system(C,I4)\n\nC_inverse = np.hstack((Y1,Y2,Y3,Y4))\nprint(\"C inverse:\\n\",C_inverse,'\\n',sep='')\nprint(\"C inverse times C:\\n\",C_inverse@C,'\\n',sep='')\nprint(\"C times C inverse:\\n\",C@C_inverse,sep='')\n\nC inverse:\n[[ 0.83333333  0.5        -0.16666667 -0.5       ]\n [-2.08333333 -1.25        0.66666667  2.25      ]\n [-0.08333333 -0.25        0.16666667  0.25      ]\n [-0.33333333  0.          0.16666667  0.        ]]\n\nC inverse times C:\n[[ 1.00000000e+00  0.00000000e+00 -1.11022302e-16  1.11022302e-16]\n [ 0.00000000e+00  1.00000000e+00  0.00000000e+00  4.44089210e-16]\n [ 5.55111512e-17  0.00000000e+00  1.00000000e+00 -5.55111512e-17]\n [ 0.00000000e+00  0.00000000e+00  0.00000000e+00  1.00000000e+00]]\n\nC times C inverse:\n[[ 1.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00]\n [-1.11022302e-16  1.00000000e+00  5.55111512e-17  0.00000000e+00]\n [ 0.00000000e+00  0.00000000e+00  1.00000000e+00  0.00000000e+00]\n [-3.33066907e-16  0.00000000e+00  1.11022302e-16  1.00000000e+00]]\n\n\n반올림 오류로 인해 0이 되어야 하는 일부 항목이 정확히 0이 아닙니다.\n\nprint(np.round(C@C_inverse,8))\n\n[[ 1.  0.  0.  0.]\n [-0.  1.  0.  0.]\n [ 0.  0.  1.  0.]\n [-0.  0.  0.  1.]]\n\n\n다음으로 행렬의 역을 계산하는 파이썬 함수를 작성해 보겠습니다. 실제로 행렬의 역을 구하는 것은 선형 시스템을 푸는 매우 비효율적인 방법입니다. 행렬의 역을 구하기 위해 \\(n\\)개의 시스템을 풀어야 하므로, 제거를 통해 시스템을 풀 때보다 \\(n\\)배의 작업량이 소요되는 것으로 보입니다. 그러나 다양한 벡터 \\(B\\)에 대한 선형 시스템 \\(AX=B\\)를 풀어야 하지만 계수 행렬 \\(A\\)는 동일하다고 가정해 보겠습니다. 이 경우 \\(A^{-1}\\)를 구성하는 것이 매력적으로 보일 수 있습니다.\n계산의 효율성을 높이기 위해 행 연산의 반복을 최대한 피하고 싶습니다. \\(A^{-1}\\)를 구성하기 위해서는 \\(AX_i=Y_i\\) 시스템을 풀어야 하는데, 여기서 \\(Y_i\\)는 \\(I\\)의 \\(i\\)번째 열입니다. 이렇게 하면 \\(A^{-1}\\)의 \\(i\\)번째 열인 \\(X\\)가 생성됩니다. 증강된 각 행렬 \\([A|Y_i]\\)에서 제거를 수행하는 대신, 전체 행렬 \\(I\\)로 \\(A\\)를 증강하고 모든 \\(Y_i\\)에 필요한 연산을 동시에 수행할 수 있습니다. 예를 들어 \\(A\\)가 \\(4 \\times 4\\) 행렬인 경우 다음과 같은 증강 행렬을 갖게 됩니다.\n\\[\n\\begin{matrix}\n[A|I] = \\left[ \\begin{array}{rrrr|rrrr}\n* & * & * & * & 1 & 0 & 0 & 0 \\\\\n* & * & * & * & 0 & 1 & 0 & 0 \\\\\n* & * & * & * & 0 & 0 & 1 & 0 \\\\\n* & * & * & * & 0 & 0 & 0 & 1 \\\\\n\\end{array}\\right]\n\\end{matrix}\n\\]\n\\(A\\)가 역행렬이 가능한 경우, texttt{row_reduction} 루틴은 다음 형식의 행렬을 반환해야 합니다.\n\\[\n\\begin{matrix}\n[A|I] = \\left[ \\begin{array}{rrrr|rrrr}\n* & * & * & * & * & * & * & * \\\\\n0 & * & * & * & * & * & * & * \\\\\n0 & 0 & * & * & * & * & * & * \\\\\n0 & 0 & 0 & * & * & * & * & * \\\\\n\\end{array}\\right]\n\\end{matrix}\n\\]\n그런 다음 이 행렬의 오른쪽 절반에 있는 각 열에 대해 back_substitution 함수를 한 번씩 호출하면 됩니다.\n\nprint(ls.inverse(C))\n\n[[ 0.83333333  0.5        -0.16666667 -0.5       ]\n [-2.08333333 -1.25        0.66666667  2.25      ]\n [-0.08333333 -0.25        0.16666667  0.25      ]\n [-0.33333333  0.          0.16666667  0.        ]]\n\n\n역행렬이 불가능한 행렬이라면 위의 과정은 실패합니다. 우리는 back_substitution 루틴 내에서 위쪽 삼각형 행렬의 주 대각선을 따른 항목으로 나눈다는 것을 깨달아야 합니다. 이 항목들이 매우 중요한 피벗 위치에 있다는 것을 기억하세요. 하나 이상의 피벗 위치에 0이 있으면 원래 행렬은 반전할 수 없는 행렬입니다.\n예를 들어 inverse 루틴에서 증강 행렬 \\([A|I]\\)에 대해 row_reduction을 수행한 후 결과가 다음과 같다고 가정해 보겠습니다.\n\\[\n\\begin{equation}\n[A|I] = \\left[ \\begin{array}{rrrr|rrrr}\n* & * & * & * & * & * & * & * \\\\\n0 & 0 & * & * & * & * & * & * \\\\\n0 & 0 & * & * & * & * & * & * \\\\\n0 & 0 & 0 & * & * & * & * & * \\\\\n\\end{array}\\right]\n\\end{equation}\n\\]\n이 경우 두 번째 행의 피벗 위치에 0이 있기 때문에 back_substitution은 실패합니다. 따라서 \\(A^{-1}\\) 는 존재하지 않으며 \\(A\\)는 역행렬이 존재하지 않는다는 사실을 알게 됩니다.\n일반적으로 주어진 행렬의 역행렬이 가능한지 여부는 제거 단계를 수행하고 해당 위쪽 삼각형 행렬의 주 대각선에 있는 항목을 검사하여 결정합니다."
  },
  {
    "objectID": "04_Inverse_Matrices.html#scipy를-사용한-역행렬-계산",
    "href": "04_Inverse_Matrices.html#scipy를-사용한-역행렬-계산",
    "title": "역행렬",
    "section": "SciPy를 사용한 역행렬 계산",
    "text": "SciPy를 사용한 역행렬 계산\n\nimport scipy.linalg as sla\n\nC_inverse = sla.inv(C)\nprint(C_inverse)\n\n[[ 0.83333333  0.5        -0.16666667 -0.5       ]\n [-2.08333333 -1.25        0.66666667  2.25      ]\n [-0.08333333 -0.25        0.16666667  0.25      ]\n [-0.33333333  0.          0.16666667  0.        ]]"
  },
  {
    "objectID": "01_Linear_Systems.html",
    "href": "01_Linear_Systems.html",
    "title": "1. 연립 선형 방정식과 해집합",
    "section": "",
    "text": "선형 방정식을 살펴보고 그 해를 구하는 방법 소개합니다."
  },
  {
    "objectID": "01_Linear_Systems.html#선형-연립방정식system-of-linear-equations-혹은-선형계linear-system",
    "href": "01_Linear_Systems.html#선형-연립방정식system-of-linear-equations-혹은-선형계linear-system",
    "title": "1. 연립 선형 방정식과 해집합",
    "section": "선형 연립방정식(system of linear equations, 혹은 선형계(linear system))",
    "text": "선형 연립방정식(system of linear equations, 혹은 선형계(linear system))\n미지수 \\(x_1\\), \\(x_2\\), \\(\\cdots\\), \\(x_n\\)에 대해서 다음과 같은 1차식으로 작성된 방정식을 선형방정식(linear equation)이라고 합니다.\n\\[\n\\begin{split}\n\\begin{matrix}\na_1 x_1 + a_2 x_2 + \\cdots + a_n x_n = b\n\\end{matrix}\n\\end{split}\n\\]\n미지수 \\(x_1\\), \\(x_2\\), \\(x_3\\), … \\(x_n\\)이 있는 \\(m\\)개의 연립 선형방정식은 다음과 같은 형식 표현할 수 있습니다.\n\\[\n\\begin{split}\n\\begin{matrix}\na_{11}x_1 + a_{12}x_2 + \\hspace{0.5cm} ... \\hspace{0.5cm} + a_{1n}x_n & = & b_1 \\\\\na_{21}x_1 + a_{22}x_2 + \\hspace{0.5cm} ... \\hspace{0.5cm} + a_{2n}x_n & = & b_2 \\\\\n\\vdots \\hspace{1.2cm} \\vdots \\hspace{3cm} \\vdots \\hspace{0.5cm}  & = & \\vdots \\\\\na_{m1}x_1 + a_{m2}x_2 + \\hspace{0.5cm} ... \\hspace{0.5cm} +  a_{mn}x_n & = & b_m \\\\\n\\end{matrix}\n\\end{split}\n\\]\n연립 선형방정식의 해는 모든 방정식을 동시에 만족하는 미지수의 집합 입니다. 이런 미지수의 값 혹은 해를 모아둔 집합을 해집합이라고 합니다. 해를 갖지 않는 연립 선형방정식은 해가 없다(inconsistent)라고 하며, 적어도 하나의 해가 존재하면 모순이 없다(consistent)라고 합니다.\n두 개의 방정식과 두 개의 미지수가 있는 연립 선형방정식은 \\(x_1x_2\\) 좌표 평면에서 각 방정식을 만족하는 점의 집합을 쉽게 그래프로 그릴 수 있습니다. 연립 선형방정식의 해집합을 시각적으로 확인하기 위해서 간단한 그래프를 작성해보도록 하겠습니다."
  },
  {
    "objectID": "01_Linear_Systems.html#예제1-unique-solution",
    "href": "01_Linear_Systems.html#예제1-unique-solution",
    "title": "1. 연립 선형 방정식과 해집합",
    "section": "예제1: unique solution",
    "text": "예제1: unique solution\n\\[\n\\begin{matrix}\nx_1 + x_2 - 2 & = & 0 \\\\\nx_1 - x_2 -1 & = & 0 \\\n\\end{matrix}\n\\]\n각 방정식의 해집합은 선으로 나타낼 수 있으며, 선형 시스템의 해집합은 두 선에 놓인 모든 점으로 나타낼 수 있습니다. 이 경우 선은 한 점에서 교차하며 두 방정식을 모두 만족하는 값은 한 쌍만 존재합니다.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n%config InlineBackend.figure_format = 'retina'\n\n\nx=np.linspace(-10,10,100)\n\n\nfig, ax = plt.subplots()\nax.plot(x,(2-x))\nax.plot(x,(1+x))\n\nax.text(1,1.6,'$x_1+x_2 -2 = 0$')\nax.text(-3,0.5,'$x_1-x_2 -1 = 0$')\n\nax.set_xlim(-4,4)\nax.set_ylim(-2,6)\nax.axvline(color='k',linewidth = 1)\nax.axhline(color='k',linewidth = 1)\n\nax.set_xticks(list(range(-4,5)))\nax.set_aspect('equal')\nax.grid(True,ls=':')"
  },
  {
    "objectID": "01_Linear_Systems.html#예제-2-no-solutions",
    "href": "01_Linear_Systems.html#예제-2-no-solutions",
    "title": "1. 연립 선형 방정식과 해집합",
    "section": "예제 2: no solutions",
    "text": "예제 2: no solutions\n\\[\n\\begin{matrix}\nx_1 + 3x_2 & = & 5 \\\\\nx_1 + 3x_2 & = & 0 \\\\\n\\end{matrix}\n\\]\n두 방정식을 동시에 만족하는 해는 없습니다.\n\nfig, ax = plt.subplots()\nax.plot(x,(2*x-3))\nax.plot(x,(4*x-6)/2)\n\nax.text(1,1.6,'$2x_1-x_2 -3 = 0$')\nax.text(1,2.6,'$-4x_1+2x_2 +6 = 0$')\n\nax.set_xlim(-4,4)\nax.set_ylim(-4,4)\nax.axvline(color='k',linewidth = 1)\nax.axhline(color='k',linewidth = 1)\n\nax.set_xticks(list(range(-4,5)))\nax.set_aspect('equal')\nax.grid(True,ls=':')"
  },
  {
    "objectID": "01_Linear_Systems.html#예제-3-infinite-number-of-solutions",
    "href": "01_Linear_Systems.html#예제-3-infinite-number-of-solutions",
    "title": "1. 연립 선형 방정식과 해집합",
    "section": "예제 3: infinite number of solutions",
    "text": "예제 3: infinite number of solutions\n\\[\n\\begin{matrix}\nx_1 + 3x_2 & = & 5 \\\\\n2x_1 + 6x_2 & = & 10 \\\\\n\\end{matrix}\n\\]\n마지막 예제에서 두 번째 방정식은 첫 번째 방정식의 배수입니다. 두 방정식의 해는 모두 같은 선으로 표시되므로 선의 모든 점이 선형 시스템의 해입니다.\n\nfig, ax = plt.subplots()\nax.plot(x,(1-x))\nax.plot(x,(1+x))\nax.plot(x,(-3+3*x))\n\nax.text(0,1,'$x_1+x_2 - 1 = 0$')\nax.text(-1,2,'$x_1-x_2 - 1= 0$')\nax.text(1.5,2,'$-x_1+3x_2 - 3 = 10$')\n\nax.set_xlim(-4,4)\nax.set_ylim(-2,6)\nax.axvline(color='k',linewidth = 1)\nax.axhline(color='k',linewidth = 1)\n\nax.set_xticks(list(range(-4,5)))\nax.set_aspect('equal')\nax.grid(True,ls=':')\n\n앞선 세 가지 예는 두 개의 미지수가 있는 연립 선형 방정식의 모든 유형의 해집합을 보여줍니다. 정확히 하나의 해가 있을 수도 있고, 해가 없을 수도 있으며, 해가 무한 할 수도 있습니다. 선형 시스템에 대한 기본적인 사실은 해집합이 이 세 가지 경우 중 하나라는 것입니다."
  },
  {
    "objectID": "02_Gaussian_Elimination.html",
    "href": "02_Gaussian_Elimination.html",
    "title": "2. 가우스 소거법",
    "section": "",
    "text": "연립 선형방정식을 푸는 데 도움이 되는 몇 가지 파이썬 함수를 사용하여, 가우스 소거법(Gaussian Elimination)에 대해서 알아보겠습니다. 가우스 소거법의 핵심은 해를 보존하면서 점차적으로 해에 더 쉽게 접근할 수 있도록 하는 행 연산이라는 일련의 단계를 적용하는 것 입니다. 기본 행 연산은 세 가지가 있습니다. 1. 두 방정식의 위치 교환하기(interchange) 2. 방정식에 0이 아닌 숫자를 곱하기(scaling) 3. 특정 행을 자기 자신과 다른 행의 배수 배를 합한 것으로 교체(replacement)"
  },
  {
    "objectID": "02_Gaussian_Elimination.html#예제-1-row-operations-and-elimination",
    "href": "02_Gaussian_Elimination.html#예제-1-row-operations-and-elimination",
    "title": "2. 가우스 소거법",
    "section": "예제 1: Row operations and elimination",
    "text": "예제 1: Row operations and elimination\n\n(이건명 2020), p64.\n\n예를 들어 보겠습니다.\n\\[\n\\begin{matrix}\n2x_1 + 2x_2 + 4x_3 & = & 18 \\\\\nx_1 + 3x_2 + 2x_3 & = & 13 \\\\\n3x_1 + x_2 + 3x_3 & = & 14\n\\end{matrix}\n\\]\n첫 번째 방정식과 마지막 방정식을 바꿀 수 있습니다.\n\\[\n\\begin{matrix}\n3x_1 + x_2 + 3x_3 & = & 14 \\\\\nx_1 + 3x_2 + 2x_3 & = & 13 \\\\\n2x_1 + 2x_2 + 4x_3 & = & 18 \\\\\n\\end{matrix}\n\\]\n또는 첫 번째 방정식에 \\(5\\)를 곱할 수 있습니다.\n\\[\n\\begin{matrix}\n(2 \\times 5)x_1 + (2 \\times 5)x_2 + (4 \\times 5)x_3 & = & 18 \\\\\nx_1 + 3x_2 + 2x_3 & = & 13 \\\\\n3x_1 + x_2 + 3x_3 & = & 14\n\\end{matrix}\n\\]\n또는 첫번째 방정식에 두번째 방정식의 \\(2\\)배를 곱하고 뺄 수도 있습니다.\n\\[\n\\begin{matrix}\nx_1 - 4x_2 + x_3 & = & -8 \\\\\nx_1 + 3x_2 + 2x_3 & = & 13 \\\\\n3x_1 + x_2 + 3x_3 & = & 14\n\\end{matrix}\n\\]\n마지막 연산이 가장 중요한 이유는 방정식 중 하나에서 변수를 ’제거’할 수 있기 때문입니다. 세 번째 방정식에는 더 이상 \\(x_2\\) 항이 포함되어 있지 않다는 점에 유의하세요. 이것이 ’가우스 소거법’의 핵심입니다.\n계산을 위해 변수 이름과 “=” 기호를 생략하고 실제 숫자를 모두 배열로 정렬할 수 있습니다.\n\\[\n\\begin{matrix}\n\\left[ \\begin{array}{ccc|c} 2 & 2 & 4 & 18 \\\\ 1 & 3 & 2 & 13 \\\\ 3 & 1 & 3 & 14 \\end{array}\\right]\n\\end{matrix}\n\\]\n이제 이 값으로 NumPy 배열을 만들어 보겠습니다. 나중에 참조할 수 있도록 배열에 \\(\\texttt{A}\\)라는 이름을 지정하겠습니다.\n\nimport numpy as np\nA=np.array([[2,2,4,18],[1,3,2,13],[3,1,3,14]])\n\n기본 행 연산을 수행할 수 있는 간단한 함수를 작성하도록 하겠습니다.\n\ndef row_swap(A,k,l):\n    m = A.shape[0]\n    n = A.shape[1]\n    \n    B = np.copy(A).astype('float64')\n        \n    for j in range(n):\n        temp = B[k][j]\n        B[k][j] = B[l][j]\n        B[l][j] = temp\n        \n    return B\n\ndef row_scale(A,k,scale):\n    m = A.shape[0]\n    n = A.shape[1]\n    \n    B = np.copy(A).astype('float64')\n\n    for j in range(n):\n        B[k][j] *= scale\n        \n    return B\n\ndef row_add(A,k,l,scale):\n    m = A.shape[0]\n    n = A.shape[1]\n    \n    B = np.copy(A).astype('float64')\n        \n    for j in range(n):\n        B[l][j] += B[k][j]*scale\n        \n    return B\n\n이제 row_swap, row_scale, row_add라는 세 가지 새로운 함수가 생겼습니다. 이 함수를 사용해 어떤 결과가 나오는지 살펴봅시다.\n\nB1 = row_scale(A,0,1/2)\nB2 = row_add(A,1,0,-2)\nB3 = row_swap(A,0,2)\n\n\nprint(A,'\\n')\nprint(B1,'\\n')\nprint(B2,'\\n')\nprint(B3,'\\n')\n\n[[ 2  2  4 18]\n [ 1  3  2 13]\n [ 3  1  3 14]] \n\n[[ 1.  1.  2.  9.]\n [ 1.  3.  2. 13.]\n [ 3.  1.  3. 14.]] \n\n[[ 0. -4.  0. -8.]\n [ 1.  3.  2. 13.]\n [ 3.  1.  3. 14.]] \n\n[[ 3.  1.  3. 14.]\n [ 1.  3.  2. 13.]\n [ 2.  2.  4. 18.]] \n\n\n\n가우스 소거법의 목표는 행 연산을 수행하여 다음과 같은 구조의 행렬을 생성하는 것입니다.\n\\[\n\\begin{matrix}\n\\left[ \\begin{array}{ccc|c} 1 & * & * & * \\\\ 0 & 1 & * & * \\\\ 0 & 0 & 1 & * \\end{array}\\right]\n\\end{matrix}\n\\]\n(여기서  기호는 0 또는 1이 될 수도 있고 아닐 수도 있는 다양한 미지의 값을 나타냅니다.)*.\n행 연산을 수행하고 각 단계마다 새로운 이름을 붙인 배열로 진행 상황을 저장합니다. 예를 들어 \\(\\texttt{A1}\\), \\(\\texttt{A2}\\), \\(\\texttt{A3}\\) 등으로 이름을 지정할 수 있습니다. 이렇게 하면 진행 상황을 확인하거나 원하는 경우 돌아가서 코드를 변경할 수 있습니다.\n\nA1 = row_scale(A,0,1.0/2)\nprint(A1,'\\n')\nA2 = row_add(A1,0,1,-1)\nprint(A2,'\\n')\nA3 = row_add(A2,0,2,-3)\nprint(A3,'\\n')\nA4 = row_scale(A3,1,1.0/2)\nprint(A4,'\\n')\nA5 = row_add(A4,1,2,2)\nprint(A5,'\\n')\nA6 = row_add(A5,1,0,-1)\nprint(A6,'\\n')\nA7 = row_scale(A6,2,-(1.0/3))\nprint(A7,'\\n')\nA8 = row_add(A7,2,0,-2)\nprint(A8,'\\n')\n\n[[ 1.  1.  2.  9.]\n [ 1.  3.  2. 13.]\n [ 3.  1.  3. 14.]] \n\n[[ 1.  1.  2.  9.]\n [ 0.  2.  0.  4.]\n [ 3.  1.  3. 14.]] \n\n[[  1.   1.   2.   9.]\n [  0.   2.   0.   4.]\n [  0.  -2.  -3. -13.]] \n\n[[  1.   1.   2.   9.]\n [  0.   1.   0.   2.]\n [  0.  -2.  -3. -13.]] \n\n[[ 1.  1.  2.  9.]\n [ 0.  1.  0.  2.]\n [ 0.  0. -3. -9.]] \n\n[[ 1.  0.  2.  7.]\n [ 0.  1.  0.  2.]\n [ 0.  0. -3. -9.]] \n\n[[ 1.  0.  2.  7.]\n [ 0.  1.  0.  2.]\n [-0. -0.  1.  3.]] \n\n[[ 1.  0.  0.  1.]\n [ 0.  1.  0.  2.]\n [-0. -0.  1.  3.]] \n\n\n\n이제 행렬을 연립 선형 방정식 형태로 다시 표현하도록 하겠습니다.\n\\[\n\\begin{matrix}\nx_1 \\quad\\quad & = & 1 \\\\\n\\quad x_2 \\quad & = & 2 \\\\\n\\quad\\quad x_3 & = & 3 \\\\\n\\end{matrix}\n\\]"
  },
  {
    "objectID": "02_Gaussian_Elimination.html#예제-2-finding-pivots",
    "href": "02_Gaussian_Elimination.html#예제-2-finding-pivots",
    "title": "2. 가우스 소거법",
    "section": "예제 2: Finding pivots",
    "text": "예제 2: Finding pivots\n마지막 예제의 코드는 배율을 계산하기 위해 나눈 배열의 항목 중 하나라도 0이 나타나면 실패합니다. 이러한 중요한 항목을 피벗이라고 하며, 행렬에서 해당 항목의 위치를 피벗 위치라고 합니다. 정의상 피벗은 0이 아니어야 합니다. 제거 단계에서 피벗 위치에 0이 발생하면 행의 순서를 바꿔서 0이 아닌 항목을 피벗 위치로 옮길 수 있습니다. 무작위 배열에서 작동하는 코드를 작성하기 전에 먼저 특정 배열에 대해 이 방법을 시도해 보겠습니다.\n\\[\n\\begin{matrix}\nx_1 - x_2 + x_3 & = & 3\\\\\n2x_1 - 2x_2 + 4x_3 & = & 8\\\\\n3x_1 \\quad\\quad -9x_3 & = & 0\n\\end{matrix}\n\\]\n\nG=np.array([[1,-1,1,3],[2,-2,4,8],[3,0,-9,0]])\nprint(G)\n\n[[ 1 -1  1  3]\n [ 2 -2  4  8]\n [ 3  0 -9  0]]\n\n\n\nG1 = row_add(G,0,1,-2)\nG2 = row_add(G1,0,2,-3)\nprint(G2)\n\n[[  1.  -1.   1.   3.]\n [  0.   0.   2.   2.]\n [  0.   3. -12.  -9.]]\n\n\n이제 중간 피벗 위치에 0이 있습니다. 제거를 계속하기 위해 중간 방정식과 마지막 방정식을 바꿀 수 있습니다.\n\nG3 = row_swap(G2,1,2)\nG4 = row_scale(G3,1,1./3)\nG5 = row_scale(G4,2,1./2)\nprint(G5)\n\n[[ 1. -1.  1.  3.]\n [ 0.  1. -4. -3.]\n [ 0.  0.  1.  1.]]\n\n\n시스템을 익숙한 방정식 집합으로 다시 작성합니다.\n\\[\n\\begin{matrix}\nx_1 - x_2 + x_3 & = & 3\\\\\nx_2 - 4x_3 & = & -3\\\\\nx_3 & = & 1\n\\end{matrix}\n\\]\n역치환을 적용하면 \\(x_2 = 1\\)과 \\(x_1=3\\)이 됩니다.\n행을 바꾸는 것은 수식을 정리하는데 사용한다는 것에 주목할 필요가 있습니다. 동치항을 제거하여 해를 깔끔하게 나타낼 수 있습니다.\n\nG3_alternative = row_scale(G2,1,1./2)\nG4_alternative = row_scale(G3_alternative,2,1./3)\nprint(G4_alternative)\n\n[[ 1. -1.  1.  3.]\n [ 0.  0.  1.  1.]\n [ 0.  1. -4. -3.]]\n\n\n생성된 배열은 방정식의 순서는 물론 다르지만 동일한 단순화된 시스템을 나타냅니다.\n\\[\n\\begin{matrix}\nx_1 - x_2 + x_3 & = & 3\\\\\nx_3 & = & 1 \\\\\nx_2 - 4x_3 & = & -3\n\\end{matrix}\n\\]"
  },
  {
    "objectID": "03_Matrix_Algebra.html",
    "href": "03_Matrix_Algebra.html",
    "title": "3. 행렬과 행렬연산",
    "section": "",
    "text": "행렬 A는 숫자의 2차원 배열입니다. NumPy를 사용하여 행렬로 계산할 때는 이전과 마찬가지로 배열을 사용하게 됩니다. 행렬의 몇 가지 모양은 아래와 같습니다.\n\\[\n\\begin{equation}\nA = \\left[ \\begin{array}{rr} 1 & 3 \\\\ 2 & 1 \\end{array}\\right] \\hspace{1cm}\nB = \\left[ \\begin{array}{rrr} 3 & 0 & 4 \\\\ -1 & -2 & 1 \\end{array}\\right] \\hspace{1cm}\nC = \\left[ \\begin{array}{rr} -2 & 1 \\\\ 4 & 1 \\end{array}\\right] \\hspace{1cm}\nD = \\left[ \\begin{array}{r} 2 \\\\ 6 \\end{array}\\right]\n\\end{equation}\n\\]\n행렬은 행과 열의 개수를 지정하여 행렬의 크기 또는 모양에 대해 이야기하는 것이 일반적입니다. 일반적으로 행의 개수가 먼저 나열됩니다. 이 예제에서 \\(A\\)와 \\(C\\)는 \\(2 \\times 2\\) 행렬이고, \\(B\\)는 \\(2 \\times 3\\) 행렬이며, \\(D\\)는 $ 2 $ 행렬입니다. \\(D\\)와 같이 열이 1개만 있는 행렬은 일반적으로 벡터라고 합니다.\n행렬의 개별 항목에 대해서도 이야기할 필요가 있습니다. 이에 대한 일반적인 표기법은 행렬에서 항목의 위치를 나타내기 위해 아래 첨자가 있는 소문자입니다. 따라서 \\(b_{12}\\)는 행렬 \\(B\\)의 첫 번째 행과 두 번째 열에 있는 0을 나타냅니다. 일반적인 위치에 대해 이야기하는 경우, \\(a_{ij}\\)와 같이 아래 첨자 안에 변수를 사용할 수 있습니다.\n\nimport numpy as np\n\nA = np.array([[1, 3],[2,1]])\nB = np.array([[3, 0, 4],[-1, -2, 1]])\nC = np.array([[-2, 1],[4, 1]])\nD = np.array([[2],[6]])\n\n행과 열의 모양과 크기에 대해서는 배열 객체의 일부로 저장되며 shape라는 메서드로 액세스할 수 있습니다. %B$가 배열인 경우, B.shape 객체는 그 자체로 두 개의 항목이 있는 배열입니다. 첫 번째 항목(인덱스 0)은 행의 개수이고 두 번째 항목(인덱스 1)은 열의 개수입니다.\n\nprint(f\"Array B has {B.shape[0]} rows.\")\nprint(f\"Array B has {B.shape[1]} columns.\")\n\nArray B has 2 rows.\nArray B has 3 columns."
  },
  {
    "objectID": "03_Matrix_Algebra.html#행렬",
    "href": "03_Matrix_Algebra.html#행렬",
    "title": "3. 행렬과 행렬연산",
    "section": "",
    "text": "행렬 A는 숫자의 2차원 배열입니다. NumPy를 사용하여 행렬로 계산할 때는 이전과 마찬가지로 배열을 사용하게 됩니다. 행렬의 몇 가지 모양은 아래와 같습니다.\n\\[\n\\begin{equation}\nA = \\left[ \\begin{array}{rr} 1 & 3 \\\\ 2 & 1 \\end{array}\\right] \\hspace{1cm}\nB = \\left[ \\begin{array}{rrr} 3 & 0 & 4 \\\\ -1 & -2 & 1 \\end{array}\\right] \\hspace{1cm}\nC = \\left[ \\begin{array}{rr} -2 & 1 \\\\ 4 & 1 \\end{array}\\right] \\hspace{1cm}\nD = \\left[ \\begin{array}{r} 2 \\\\ 6 \\end{array}\\right]\n\\end{equation}\n\\]\n행렬은 행과 열의 개수를 지정하여 행렬의 크기 또는 모양에 대해 이야기하는 것이 일반적입니다. 일반적으로 행의 개수가 먼저 나열됩니다. 이 예제에서 \\(A\\)와 \\(C\\)는 \\(2 \\times 2\\) 행렬이고, \\(B\\)는 \\(2 \\times 3\\) 행렬이며, \\(D\\)는 $ 2 $ 행렬입니다. \\(D\\)와 같이 열이 1개만 있는 행렬은 일반적으로 벡터라고 합니다.\n행렬의 개별 항목에 대해서도 이야기할 필요가 있습니다. 이에 대한 일반적인 표기법은 행렬에서 항목의 위치를 나타내기 위해 아래 첨자가 있는 소문자입니다. 따라서 \\(b_{12}\\)는 행렬 \\(B\\)의 첫 번째 행과 두 번째 열에 있는 0을 나타냅니다. 일반적인 위치에 대해 이야기하는 경우, \\(a_{ij}\\)와 같이 아래 첨자 안에 변수를 사용할 수 있습니다.\n\nimport numpy as np\n\nA = np.array([[1, 3],[2,1]])\nB = np.array([[3, 0, 4],[-1, -2, 1]])\nC = np.array([[-2, 1],[4, 1]])\nD = np.array([[2],[6]])\n\n행과 열의 모양과 크기에 대해서는 배열 객체의 일부로 저장되며 shape라는 메서드로 액세스할 수 있습니다. %B$가 배열인 경우, B.shape 객체는 그 자체로 두 개의 항목이 있는 배열입니다. 첫 번째 항목(인덱스 0)은 행의 개수이고 두 번째 항목(인덱스 1)은 열의 개수입니다.\n\nprint(f\"Array B has {B.shape[0]} rows.\")\nprint(f\"Array B has {B.shape[1]} columns.\")\n\nArray B has 2 rows.\nArray B has 3 columns."
  },
  {
    "objectID": "03_Matrix_Algebra.html#행렬-연산",
    "href": "03_Matrix_Algebra.html#행렬-연산",
    "title": "3. 행렬과 행렬연산",
    "section": "행렬 연산",
    "text": "행렬 연산\n행렬에 대해 수행해야 할 세 가지 대수 연산이 있습니다. 정의를 위해 \\(A\\)와 \\(C\\)가 \\(m \\times n\\) 행렬이고, \\(B\\)가 \\(n \\times k\\) 행렬이며, \\(c\\)가 숫자라고 가정해 보겠습니다. 행렬과 숫자를 포함하는 대수를 논의할 때 숫자는 일반적으로 스칼라라고 합니다.\n\n모든 형태의 행렬에 스칼라를 곱할 수 있습니다. 그 결과 모든 항목에 해당 스칼라가 곱해집니다. 아래 첨자 표기법을 사용하면 다음과 같이 작성할 수 있습니다.\n\n\\[\n(cA)_{ij} = ca_{ij}\n\\]\n\n동일한 모양을 가진 두 행렬을 추가할 수 있습니다. 그 결과 해당되는 모든 항목이 추가됩니다.\n\n\\[\n(A+C)_{ij} = a_{ij} + c_{ij}\n\\]\n\n행렬 \\(A\\)의 열 수가 행렬 \\(B\\)의 행 수와 같으면, 행렬을 \\(A\\), \\(B\\) 순서로 곱할 수 있습니다. 그 결과 행의 개수는 \\(A\\)와 같고 열의 개수는 \\(B\\)와 같은 새로운 행렬 \\(AB\\)가 생성됩니다. \\((AB)_{ij}\\) 행렬은 \\(A\\)의 행 \\(i\\)와 \\(B\\)의 열 \\(j\\)의 행렬을 다음과 같이 조합한 행렬이 됩니다.\n\n\\[\n(AB)_{ij} = \\sum_{k=1}^n a_{ik}b_{kj}\n\\]\n행렬 곱셈으로 알려진 마지막 연산은 세 가지 연산 중 가장 복잡하고 직관적이지 않습니다. 이 마지막 공식은 처음 접했을 때 다소 어렵게 느껴질 수 있습니다. 몇 가지 예를 들어 설명해 드리겠습니다.\n\n숫자와 행렬의 곱셈입니다:\n\n\\[\n\\begin{matrix}\n3A = 3\\left[ \\begin{array}{rr} 1 & 3 \\\\ 2 & 1 \\end{array}\\right]\n= \\left[ \\begin{array}{rr} 3 & 9 \\\\ 6 & 3 \\end{array}\\right]\n\\end{matrix}\n\\]\n\n모양이 같은 두 행렬의 합계입니다:\n\n\\[\n\\begin{matrix}\nA + C = \\left[ \\begin{array}{rr} 1 & 3 \\\\ 2 & 1 \\end{array}\\right] +\n\\left[ \\begin{array}{rr} -2 & 1 \\\\ 4 & 1 \\end{array}\\right]\n= \\left[ \\begin{array}{rr} -1 & 4 \\\\ 6 & 2 \\end{array}\\right]\n\\end{matrix}\n\\]\n\n두 행렬의 곱셈입니다:\n\n\\[\n\\begin{matrix}\nAB = \\left[ \\begin{array}{rr} 1 & 3 \\\\ 2 & 1 \\end{array}\\right]\n\\left[ \\begin{array}{rrr} 3 & 0 & 4 \\\\ -1 & -2 & 1 \\end{array}\\right]\n= \\left[ \\begin{array}{rrr} 0 & -6 & 7  \\\\  5 & -2 & 9  \\end{array}\\right]\n\\end{matrix}\n\\]\n행렬 곱셈에서 어떤 일이 일어나는지 명확히 하기 위해 두 개의 항목을 자세히 계산해 보겠습니다.\n\\[\n\\begin{matrix}\n(AB)_{12} & = & 1\\times 0 + 3 \\times (-2) = -6 \\\\\n(AB)_{23} & = & 2 \\times 4 + 1 \\times 1 = 9\n\\end{matrix}\n\\]\n이러한 행렬 연산은 모두 NumPy에 내장되어 있지만 행렬 곱셈의 경우 \\(\\texttt{*}\\) 대신 \\(\\texttt{@}\\) 기호를 사용해야 합니다.\n\nprint(3*A,'\\n')\nprint(A+C,'\\n')\nprint(A@B)\n\n[[3 9]\n [6 3]] \n\n[[-1  4]\n [ 6  2]] \n\n[[ 0 -6  7]\n [ 5 -2  9]]"
  },
  {
    "objectID": "03_Matrix_Algebra.html#행렬-연산의-속성",
    "href": "03_Matrix_Algebra.html#행렬-연산의-속성",
    "title": "3. 행렬과 행렬연산",
    "section": "행렬 연산의 속성",
    "text": "행렬 연산의 속성\n행렬 곱셈에 대해 몇 가지 일반적인 대수적 성질은 아래와 같습니다. \\(A\\), \\(B\\), \\(C\\)를 행렬로, \\(k\\)를 스칼라로 가정합니다. 여기서 설명한 연관성 및 특성은 행렬 곱셈에도 적용됩니다.\n\\[\n\\begin{equation}\nk(A+B) = kA + kB\n\\end{equation}\n\\]\n\\[\n\\begin{equation}\nC(A+B) = CA + CB\n\\end{equation}\n\\]\n\\[\n\\begin{equation}\nA(BC) = (AB)C\n\\end{equation}\n\\]\n\\(A\\)와 \\(B\\)가 \\(3 \\times 3\\) 행렬인 경우에, \\(AB = BA\\)가 성립하지 않는다는 것을 주의해야 합니다.\n\nA = np.random.randint(-5,5,size=(3,3))\nB = np.random.randint(-5,5,size=(3,3))\n\nprint(A@B)\nprint('\\n')\nprint(B@A)\n\n[[-28  -3  -1]\n [ -8   1   5]\n [-25   0   5]]\n\n\n[[-14  -7  10]\n [ -3 -28  -7]\n [-18  11  20]]"
  },
  {
    "objectID": "03_Matrix_Algebra.html#행렬의-전치",
    "href": "03_Matrix_Algebra.html#행렬의-전치",
    "title": "3. 행렬과 행렬연산",
    "section": "행렬의 전치",
    "text": "행렬의 전치\n유용하게 사용할 수 있는 또 다른 일반적인 아이디어는 행렬 전치입니다. 행렬 \\(A\\)의 전치는 열이 \\(A\\)의 행이 되도록 정의된 또 다른 행렬인 \\(A^T\\)입니다. AT\\(는 모든 항목의 행 인덱스를 열 인덱스로 간단히 바꾸면 됩니다(\\)aT_{ij} = a_{ji}$). 두 가지 예제만으로도 이 정의를 명확히 이해할 수 있습니다.\n\\[\n\\begin{equation}\nA = \\left[ \\begin{array}{rrr} 5 & 4 & 0 \\\\ 1 & 8 & 3 \\\\ 6 & 7 & 2\\end{array}\\right] \\hspace{1cm}\nA^T = \\left[ \\begin{array}{rrr} 5 & 1 & 6 \\\\ 4 & 8 & 7 \\\\ 0 & 3 & 2\\end{array}\\right] \\hspace{1cm}\n\\end{equation}\n\\]\n\\[\n\\begin{equation}\nB = \\left[ \\begin{array}{rrr} 1 & 2 & 7 & 0 \\\\ 3 & 1 & 5 & 2 \\\\ 4 & 9 & 8 & 6\\end{array}\\right] \\hspace{1cm}\nB^T = \\left[ \\begin{array}{rrr} 1 & 3 & 4 \\\\ 2 & 1 & 9 \\\\ 7 & 5 & 8 \\\\ 0 & 2 & 6\\end{array}\\right] \\hspace{1cm}\n\\end{equation}\n\\]\nNumPy 배열 객체에는 이를 위해 \\(\\texttt{transpose}\\)라는 메서드가 있습니다.\n\nA = np.array([[5, 4, 0],[1, 8, 3],[6, 7, 2]])\n\n## Note that the tranpose method must be called with (), the same as a function with no arguments.\nA_T = A.transpose()\n\nprint(A)\nprint('\\n')\nprint(A_T)\n\n[[5 4 0]\n [1 8 3]\n [6 7 2]]\n\n\n[[5 1 6]\n [4 8 7]\n [0 3 2]]\n\n\n행렬 \\(A\\)가 자신의 전치와 같을 때, 행렬은 주 대각선을 가로질러 대칭이 되는 성질을 가집니다. 이러한 이유로 행렬 \\(A\\)가 \\(A = A^T\\)이면 대칭 행렬이라고 합니다. 이와 동등하게 행렬의 모든 행렬 \\(a_{ij}\\)에 대해 \\(a_{ij} = a_{ji}\\)이면 \\(A\\)는 대칭이라고 말할 수 있습니다. 아래 행렬 \\(P\\)는 그러한 예시 중 하나입니다.\n\\[\n\\begin{equation}\nP = \\left[ \\begin{array}{rrr} 1 & 0 & 6 \\\\ 0 & 3 & 5 \\\\ 6 & 5 & -2\\end{array}\\right] \\hspace{1cm}\n\\end{equation}\n\\]"
  },
  {
    "objectID": "06_Applications.html",
    "href": "06_Applications.html",
    "title": "Applications of Linear Systems and Matrix Algebra",
    "section": "",
    "text": "선형 시스템을 풀어야 할 필요성은 다양한 분야에서 발생합니다. 선형 시스템의 예를 보여드리겠습니다. 또한 행렬 대수를 암호화와 그래프 이론에 적용하는 방법에 대해서도 설명합니다."
  },
  {
    "objectID": "06_Applications.html#interpolation",
    "href": "06_Applications.html#interpolation",
    "title": "Applications of Linear Systems and Matrix Algebra",
    "section": "Interpolation",
    "text": "Interpolation\n보간은 알려진 값 사이에 있는 미지의 데이터 값을 추정하는 프로세스입니다. 이 프로세스에는 일반적으로 알려진 데이터 포인트 집합을 통해 곡선을 피팅하여 미지의 값을 예측하는 작업이 포함됩니다. 곡선은 일련의 매개변수로 설명되며, ’곡선을 맞추는 것’은 곡선이 데이터를 가장 잘 나타내도록 매개변수를 선택하는 것을 의미합니다. 곡선을 맞추는 간단한 방법은 곡선이 제공된 모든 데이터를 통과하도록 하는 것입니다.\n데이터 포인트 \\((2,8)\\), \\((5,12)\\), \\((6,14)\\) 및 \\((15,15)\\)를 예로 들어 보겠습니다.\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport linear_solver as ls\n\nx = np.array([2,5,6,15])\ny = np.array([8,12,14,15])\n\nfig,ax = plt.subplots()\nax.scatter(x,y,color='red');\n\nax.set_xlim(0,20);\nax.set_ylim(0,20);\nax.set_xlabel('x');\nax.set_ylabel('y');\nax.grid(True)\n\n\n\n\n다항식은 보간에 사용되는 일반적인 곡선입니다. 이 경우 데이터 포인트가 4개이므로 그래프가 각 포인트를 통과하기 위해 충족해야 하는 방정식이 4개가 있습니다. 방정식을 만족하는 매개변수가 4개이므로 3차 다항식인 \\(P_3\\)을 선택합니다.\n\\[\n\\begin{matrix}\nP_3(x) = a_0 + a_1x + a_2x^2 + a_3x^3\n\\end{matrix}\n\\]\n데이터는 \\(P_3(2) = 8\\), \\(P_3(5) = 12\\), \\(P_3(6) = 14\\), \\(P_3(15) = 15\\)의 네 가지 방정식을 제공합니다. 이 방정식 집합은 미지 계수에 대한 선형 시스템입니다.\n\\[\n\\begin{matrix}\na_0 + 2a_1 + 2^2a_2 + 2^3a_3 & = & 8\\\\\na_0 + 5a_1 + 5^2a_2 + 5^3a_3 & = & 12\\\\\na_0 + 6a_1 + 6^2a_2 + 6^3a_3 & = & 14\\\\\na_0 + 15a_1 + 15^2a_2 + 15^3a_3 & = & 15\n\\end{matrix}\n\\]\n행렬 \\(A\\)와 오른쪽 벡터 \\(B\\)를 NumPy 배열로 조합합니다.\n\nA = np.zeros((4,4))\nB = np.zeros((4,1))\n\nfor i in range(4):\n    B[i,0] = y[i]\n    for j in range(4):\n        A[i,j] = x[i]**(j)\n        \nprint(A,'\\n')\nprint(B)\n\n[[1.000e+00 2.000e+00 4.000e+00 8.000e+00]\n [1.000e+00 5.000e+00 2.500e+01 1.250e+02]\n [1.000e+00 6.000e+00 3.600e+01 2.160e+02]\n [1.000e+00 1.500e+01 2.250e+02 3.375e+03]] \n\n[[ 8.]\n [12.]\n [14.]\n [15.]]\n\n\n이제 제거를 통해 \\(AX=B\\) 시스템을 풀 수 있습니다. x$ 변수와 혼동을 피하기 위해, 다항식의 계수를 나타내므로 해의 이름을 coeffs로 지정하겠습니다.\n\ncoeffs = ls.solve_system(A,B)\nprint(coeffs)\n\n[[ 8.64102564]\n [-1.25555556]\n [ 0.52222222]\n [-0.02735043]]\n\n\n마지막으로 데이터 위에 다항식 그래프를 그려서 적합도를 확인합니다.\n\nx_fit = np.linspace(x[0],x[3],50)\ny_fit = coeffs[0] + coeffs[1]*x_fit + coeffs[2]*x_fit**2 + coeffs[3]*x_fit**3\n\nfig,ax = plt.subplots()\n\nax.scatter(x,y,color='red');\nax.plot(x_fit,y_fit,'b');\nax.set_xlim(0,20);\nax.set_ylim(0,30);\nax.set_xlabel('x');\nax.set_ylabel('y');\nax.grid(True);\n\n\n\n\n우리가 생성하는 곡선이 실제로 각 데이터 포인트를 통과하지만, 이 다항식은 기본 프로세스의 최상의 모델이 아닐 수 있습니다. 한 가지 잠재적인 우려는 곡선이 세 번째와 네 번째 데이터 요소를 직접 연결하는 것이 아니라 진동을 나타내는 것처럼 보인다는 것입니다. 데이터 포인트 집합에 맞는 곡선을 만들 때 단순히 곡선이 각 포인트를 통과하도록 하는 것보다 더 중요한 다른 요소가 있을 수 있습니다."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Index",
    "section": "",
    "text": "2023년 겨울 계절학기에 진행된 “공학선형대수학 (CB3500573-059)”에 사용된 Python 코드 및 간단한 예제등을 모아둔 곳 입니다. 선형대수학 공부에 도움이 되시길 바라니다. 교재는 “응용이 보이는 선형대수학 : 파이썬과 함께하는 선형대수학 이론과 응용”(이건명 2020) 입니다.\n문서 버전 : 0.01 - 초안 작성 중"
  },
  {
    "objectID": "index.html#ref.",
    "href": "index.html#ref.",
    "title": "Index",
    "section": "Ref.",
    "text": "Ref.\n\n\n이건명. 2020. 응용이 보이는 선형대수학 : 파이썬과 함께하는 선형대수학 이론과 응용. 한빛미디어."
  },
  {
    "objectID": "05_LU_Factorization.html",
    "href": "05_LU_Factorization.html",
    "title": "LU Factorization",
    "section": "",
    "text": "행렬 \\(A\\)가 주어졌을 때, 다음과 같은 행렬 \\(L\\)과 \\(U\\)를 찾습니다.\n\\[\n\\begin{matrix}\nA = \\left[ \\begin{array}{cccc} * & * & * & * \\\\ * & * & * & * \\\\ * & * & * & * \\\\ * & * & * & *  \\end{array}\\right]\\hspace{1cm}\nL = \\left[ \\begin{array}{cccc} 1 & 0 & 0 & 0 \\\\ * & 1 & 0 & 0 \\\\ * & * & 1 & 0 \\\\ * & * & * & 1 \\end{array}\\right]\\hspace{1cm}\nU = \\left[ \\begin{array}{cccc} * & * & * & * \\\\ 0 & * & * & * \\\\ 0 & 0 & * & * \\\\ 0 & 0 & 0 & *  \\end{array}\\right]\\hspace{1cm}\n\\end{matrix}\n\\]\n알려진 행렬 \\(A\\)에서 \\(L\\)과 \\(U\\)를 계산하는 문제를 다루기 전에 이러한 인수분해가 왜 유용한지 알아보겠습니다. L$과 \\(U\\)를 구하여 \\(A=LU\\)가 되고, \\(AX=B\\) 시스템을 풀고 싶다고 가정해 보겠습니다. 이 문제를 쓰는 또 다른 방법은 \\(LUX=B\\)입니다. 그런 다음 \\(UX=Y\\)라고 하여 미지의 또 다른 \\(Y\\)를 정의하고, 단일 시스템 \\(AX=B\\)를 다음 두 시스템으로 교환할 수 있습니다.\n\\[\n\\begin{matrix}\nUX & = & Y\\\\\nLY & = & B\n\\end{matrix}\n\\]\n실제로 방정식의 수가 두 배로 늘어난 것은 사실이지만, 우리가 가지고 있는 두 시스템은 삼각형이며 뒤로(또는 앞으로) 치환하면 쉽게 풀 수 있습니다."
  },
  {
    "objectID": "05_LU_Factorization.html#예제-1-lu-분해를-활용",
    "href": "05_LU_Factorization.html#예제-1-lu-분해를-활용",
    "title": "LU Factorization",
    "section": "예제 1: LU 분해를 활용",
    "text": "예제 1: LU 분해를 활용\n아래와 같은 방정식을 풀고자 합니다.\n\\[\n\\left[ \\begin{array}{ccc} 3 & -1 & -2 \\\\ 6 & -1 & 0  \\\\ -3 & 5 & 20  \\end{array}\\right]X =\n\\left[ \\begin{array}{c} -4 \\\\ -8 \\\\ 6  \\end{array}\\right]\\hspace{1cm}\n\\]\n여기서 \\(X\\)는 \\(3 \\times 1\\) 벡터입니다. 또한 \\(L\\)과 \\(U\\)도 계산했다고 가정합니다.\n\\[\nL = \\left[ \\begin{array}{ccc} 1 & 0 & 0 \\\\ 2 & 1 & 0  \\\\ -1 & 4 & 1  \\end{array}\\right] \\hspace{2cm}\nU = \\left[ \\begin{array}{ccc} 3 & -1 & -2 \\\\ 0 & 1 & 4  \\\\ 0 & 0 & 2  \\end{array}\\right]\n\\]\n\nimport numpy as np\nimport linear_solver as ls\nimport scipy.linalg as sla\n## Use Python to check for yourself that LU = A.\n\n이제 \\(UX=Y\\) 및 \\(LY = B\\) 시스템을 작성해 보겠습니다. 정확성을 행렬 표기법은 잠시 제쳐두고 \\(X\\)의 항목에는 \\(x_1\\), \\(x_2\\), \\(x_3\\) 변수를, \\(Y\\)의 항목에는 \\(y_1\\), \\(y_2\\), \\(y_3\\) 변수를 사용합니다.\n\\[\n\\begin{matrix}\nx_1 \\hspace{2.1cm}& = & y_1\\\\\n2x_1 + x_2 \\hspace{1.1cm}& = & y_2\\\\\n-x_1 + 4x_2 +x_3 & = & y_3 \\\\\n\\\\\n3y_1 - y_2 - 2y_3 & = & -4\\\\\ny_2 + 4y_3 & = & -8\\\\\n2y_3 & = & 6\n\\end{matrix}\n\\]\n이제 해결책은 치환의 문제입니다. 마지막 방정식은 \\(y_3\\)을 알려줍니다. 거기서부터 거꾸로 작업하여 \\(y_2\\)와 \\(y_1\\)을 찾습니다. 그런 다음 첫 번째 방정식부터 시작하여 아래로 내려가면서 비슷한 방식으로 \\(x\\) 값을 구합니다."
  },
  {
    "objectID": "05_LU_Factorization.html#기본-행렬",
    "href": "05_LU_Factorization.html#기본-행렬",
    "title": "LU Factorization",
    "section": "기본 행렬",
    "text": "기본 행렬\n제거를 통해 LU 인수분해를 구성하는 방법을 이해하려면 기본 행렬이라는 특수 행렬을 곱셈하여 제거 단계를 수행할 수 있다는 것을 알면 도움이 됩니다. 기본 행렬은 호환 가능한 모양의 행렬에 row_scale 또는 row_add 연산을 적용한 결과입니다. (*행 재배열은 피벗 위치에서 0이 발생하는 경우에만 필요하다는 점을 기억하세요. 행 스왑은 곧 다루겠습니다.)\n\nI = np.eye(4)\nE = ls.row_add(I,1,2,-3)\nprint(I,'\\n')\nprint(E)\n\n[[1. 0. 0. 0.]\n [0. 1. 0. 0.]\n [0. 0. 1. 0.]\n [0. 0. 0. 1.]] \n\n[[ 1.  0.  0.  0.]\n [ 0.  1.  0.  0.]\n [ 0. -3.  1.  0.]\n [ 0.  0.  0.  1.]]\n\n\n우리가 얻는 \\(E\\)는 \\(I\\)의 세 번째 행에 \\(I\\)의 첫 번째 행의 -3배를 더한 결과입니다. 기본 행렬 \\(E\\)의 흥미로운 속성은 다른 행렬 \\(A\\)에 \\(E\\)를 곱하면 그 결과가 \\(A\\)에 동일한 행 연산을 적용하여 얻을 수 있는 행렬이 된다는 것입니다.\n\nA=np.array([[1,2,0,-1],[-1,1,-1,4],[2,13,-4,9],[-2,5,-3,13]])\nprint(A,'\\n')\nprint(E@A)\n\n[[ 1  2  0 -1]\n [-1  1 -1  4]\n [ 2 13 -4  9]\n [-2  5 -3 13]] \n\n[[ 1.  2.  0. -1.]\n [-1.  1. -1.  4.]\n [ 5. 10. -1. -3.]\n [-2.  5. -3. 13.]]"
  },
  {
    "objectID": "05_LU_Factorization.html#예제-2-finding-an-lu-factorization",
    "href": "05_LU_Factorization.html#예제-2-finding-an-lu-factorization",
    "title": "LU Factorization",
    "section": "예제 2: Finding an LU factorization",
    "text": "예제 2: Finding an LU factorization\n이제 일련의 기본 행렬 \\(E_1\\), \\(E_2\\), \\(E_3\\),…을 \\(A\\)에 적용하여 제거를 수행할 수 있습니다. 위의 행렬에서 어떻게 작동하는지 살펴봅시다.\n\nA=np.array([[1,2,0,-1],[-1,1,-1,4],[2,13,-4,9],[-2,5,-3,13]])\nI = np.eye(4)\nE1 = ls.row_add(I,0,1,1)\nE2 = ls.row_add(I,0,2,-2)\nE3 = ls.row_add(I,0,3,2)\nprint(E3@E2@E1@A,'\\n')\nE4 = ls.row_add(I,1,2,-3)\nE5 = ls.row_add(I,1,3,-3)\nprint(E5@E4@E3@E2@E1@A)\n\n[[ 1.  2.  0. -1.]\n [ 0.  3. -1.  3.]\n [ 0.  9. -4. 11.]\n [ 0.  9. -3. 11.]] \n\n[[ 1.  2.  0. -1.]\n [ 0.  3. -1.  3.]\n [ 0.  0. -1.  2.]\n [ 0.  0.  0.  2.]]\n\n\nrow_add를 사용하여 적절한 공간에 \\(0\\)을 만들었으므로 이제 \\(U\\) 계수가 생겼습니다. 행렬 곱셈을 기호로 작성하면 다음과 같이 표시됩니다.\n\\[\n\\begin{matrix}\nE_5E_4E_3E_2E_1A = U\n\\end{matrix}\n\\]\n곱셈 순서는 변경할 수 없습니다. \\(E_1\\)이 가장 먼저 \\(A\\)를 곱하고, 그다음에 \\(E_2\\)를 곱하는 식으로 곱해야 합니다. 이제 역행렬의 속성에 따라 기호를 약간 조작해 보겠습니다.\n\\[\n\\begin{matrix}\nA &=& (E_5E_4E_3E_2E_1)^{-1}U  \\\\\nA &=& E_1^{-1}E_2^{-1}E_3^{-1}E_4^{-1}E_5^{-1}U  \n\\end{matrix}\n\\]\n\\(L = E_1^{-1}E_2^{-1}E_3^{-1}E_4^{-1}E_5^{-1}\\)가 되어야 합니다. 이 역행렬의 곱이 \\(L\\)이라는 정확한 형태를 갖는다는 사실은 전혀 명확하지 않습니다. 다음 두 가지를 관찰해 봅시다.\n\n역행렬의 각 행렬은 단순한 하한 삼각형 구조를 가집니다. 사실 \\(E_3^{-1}\\) 행렬도 기본 행렬입니다. \\(E_3\\)로 표현되는 행렬 연산을 취소하는 행렬이 바로 기본 행렬입니다! \\(E_3\\)를 곱하면 첫 번째 행의 2배를 마지막 행에 더하게 됩니다. \\(E_3^{-1}\\)로 곱하면 마지막 행에 첫 번째 행의 -2배를 더합니다.\n\n\nprint(E3,'\\n')\nprint(sla.inv(E3))\n\n[[1. 0. 0. 0.]\n [0. 1. 0. 0.]\n [0. 0. 1. 0.]\n [2. 0. 0. 1.]] \n\n[[ 1. -0. -0.  0.]\n [ 0.  1. -0.  0.]\n [ 0.  0.  1.  0.]\n [-2.  0.  0.  1.]]\n\n\n\n두 개의 하위 삼각형 행렬을 곱하면 하위 삼각형 행렬이 만들어집니다.\n\n\nL1 = np.array([[1,0,0,0],[-1,1,0,0],[2,3,1,0],[-2,3,0,1]])\nL2 = np.array([[1,0,0,0],[2,1,0,0],[-5,4,1,0],[4,4,1,1]])\nprint(L1,'\\n')\nprint(L2,'\\n')\nprint(L1@L2)\n\n[[ 1  0  0  0]\n [-1  1  0  0]\n [ 2  3  1  0]\n [-2  3  0  1]] \n\n[[ 1  0  0  0]\n [ 2  1  0  0]\n [-5  4  1  0]\n [ 4  4  1  1]] \n\n[[1 0 0 0]\n [1 1 0 0]\n [3 7 1 0]\n [8 7 1 1]]\n\n\n이 두 가지 사실을 종합하면 \\(E_1^{-1}E_2^{-1}E_3^{-1}E_4^{-1}E_5^{-1}\\) 행렬이 \\(L\\) 인자가 되기 위한 올바른 구조를 가지고 있음을 알 수 있습니다. 더 편리한 점은 이러한 역행렬을 함께 곱할 때 아래쪽 삼각형 부분의 0이 아닌 항목은 변하지 않는다는 것입니다.\n\nprint(sla.inv(E5),'\\n')\nprint(sla.inv(E4)@sla.inv(E5),'\\n')\nprint(sla.inv(E3)@sla.inv(E4)@sla.inv(E5))\n\n[[ 1. -0.  0.  0.]\n [ 0.  1.  0.  0.]\n [ 0. -0.  1.  0.]\n [ 0.  3.  0.  1.]] \n\n[[1. 0. 0. 0.]\n [0. 1. 0. 0.]\n [0. 3. 1. 0.]\n [0. 3. 0. 1.]] \n\n[[ 1.  0.  0.  0.]\n [ 0.  1.  0.  0.]\n [ 0.  3.  1.  0.]\n [-2.  3.  0.  1.]]\n\n\n\\(E_3^{-1}E_4^{-1}E_5^{-1}\\)의 0이 아닌 하위 삼각형 항목은 \\(E_3^{-1}\\), \\(E_4^{-1}\\) 및 \\(E_5^{-1}\\)의 해당 항목과 동일합니다. 즉, \\(L\\)의 항목은 \\(\\texttt{RowAdd}\\)의 적용에 사용된 배율에 -1을 곱한 값일 뿐입니다. 이제 이러한 기본 행렬이 어떻게 결합하여 \\(L\\)을 생성하는지 이해했으므로 실제로 행렬을 구성할 필요는 없습니다. 행 연산을 할 때 배율을 추적하여 \\(L\\)을 계산하면 됩니다.\n\nL = np.array([[1,0,0,0],[-1,1,0,0],[2,3,1,-0],[-2,3,0,1]])\nU = np.array([[1,2,0,-1],[0,3,-1,3],[0,0,-1,2],[0,0,0,2]])\nprint(\"L:\",'\\n',L,'\\n',sep='')\nprint(\"U:\",'\\n',U,'\\n',sep='')\nprint(\"LU:\",'\\n',L@U,sep='')\n\nL:\n[[ 1  0  0  0]\n [-1  1  0  0]\n [ 2  3  1  0]\n [-2  3  0  1]]\n\nU:\n[[ 1  2  0 -1]\n [ 0  3 -1  3]\n [ 0  0 -1  2]\n [ 0  0  0  2]]\n\nLU:\n[[ 1  2  0 -1]\n [-1  1 -1  4]\n [ 2 13 -4  9]\n [-2  5 -3 13]]"
  },
  {
    "objectID": "Textbook_Solutions.html",
    "href": "Textbook_Solutions.html",
    "title": "프로그래밍 실습",
    "section": "",
    "text": "def calc(n):\n    sum = 0\n    for i in range(0, n+1):\n        sum += i\n    return sum\n\n\ncalc(10)\n\n55\n\n\n\n\n\n\nimport numpy as np\n\nA = np.array([[1,2,3], [4,5,6], [7,8,9]])\nv = np.array([[1], [2], [3]])\n\nprint(f\"A = {A}\")\nprint(f\"v = {v}\")\n\nA = [[1 2 3]\n [4 5 6]\n [7 8 9]]\nv = [[1]\n [2]\n [3]]\n\n\n\n\n\n\\[\nA =\n\\begin{matrix}\n\\left[\\begin{array}{ccc} 1 & 2 & 3 \\\\ 4 & 5 & 6 \\\\ 7 & 8 & 9 \\end{array}\\right]\n\\end{matrix}\n,\nv =\n\\begin{matrix}\n\\left[\\begin{array}{c} 1 \\\\ 2 \\\\ 3 \\end{array}\\right]\n\\end{matrix}\n,\nw = \\begin{matrix}\n\\left[\\begin{array}{c} 1 & 2 & 3 \\end{array}\\right]\n\\end{matrix}\n,\nB =\n\\begin{matrix}\n\\left[\\begin{array}{cc} 1 & 2 & 3\\\\ 4 & 5 & 6 \\end{array}\\right]\n\\end{matrix}\n\\]\n\nA = np.array([[1,2,3], [4,5,6], [7,8,9]])\nprint(f\"A = {A}\")\nprint(f\"A.shape = {A.shape}\")\n\nv = np.array([[1], [2], [3]])\nprint(f\"v = {v}\")\nprint(f\"v.shape = {v.shape}\")\n\nw = np.array([1, 2, 3])\nprint(f\"w = {w}\")\nprint(f\"w.shape = {w.shape}\")\n\nB = np.array([[1,2,3], [4,5,6]])\nprint(f\"B = {B}\")\nprint(f\"B.shape = {B.shape}\")\n\nA = [[1 2 3]\n [4 5 6]\n [7 8 9]]\nA.shape = (3, 3)\nv = [[1]\n [2]\n [3]]\nv.shape = (3, 1)\nw = [1 2 3]\nw.shape = (3,)\nB = [[1 2 3]\n [4 5 6]]\nB.shape = (2, 3)"
  },
  {
    "objectID": "Textbook_Solutions.html#장",
    "href": "Textbook_Solutions.html#장",
    "title": "프로그래밍 실습",
    "section": "",
    "text": "def calc(n):\n    sum = 0\n    for i in range(0, n+1):\n        sum += i\n    return sum\n\n\ncalc(10)\n\n55\n\n\n\n\n\n\nimport numpy as np\n\nA = np.array([[1,2,3], [4,5,6], [7,8,9]])\nv = np.array([[1], [2], [3]])\n\nprint(f\"A = {A}\")\nprint(f\"v = {v}\")\n\nA = [[1 2 3]\n [4 5 6]\n [7 8 9]]\nv = [[1]\n [2]\n [3]]\n\n\n\n\n\n\\[\nA =\n\\begin{matrix}\n\\left[\\begin{array}{ccc} 1 & 2 & 3 \\\\ 4 & 5 & 6 \\\\ 7 & 8 & 9 \\end{array}\\right]\n\\end{matrix}\n,\nv =\n\\begin{matrix}\n\\left[\\begin{array}{c} 1 \\\\ 2 \\\\ 3 \\end{array}\\right]\n\\end{matrix}\n,\nw = \\begin{matrix}\n\\left[\\begin{array}{c} 1 & 2 & 3 \\end{array}\\right]\n\\end{matrix}\n,\nB =\n\\begin{matrix}\n\\left[\\begin{array}{cc} 1 & 2 & 3\\\\ 4 & 5 & 6 \\end{array}\\right]\n\\end{matrix}\n\\]\n\nA = np.array([[1,2,3], [4,5,6], [7,8,9]])\nprint(f\"A = {A}\")\nprint(f\"A.shape = {A.shape}\")\n\nv = np.array([[1], [2], [3]])\nprint(f\"v = {v}\")\nprint(f\"v.shape = {v.shape}\")\n\nw = np.array([1, 2, 3])\nprint(f\"w = {w}\")\nprint(f\"w.shape = {w.shape}\")\n\nB = np.array([[1,2,3], [4,5,6]])\nprint(f\"B = {B}\")\nprint(f\"B.shape = {B.shape}\")\n\nA = [[1 2 3]\n [4 5 6]\n [7 8 9]]\nA.shape = (3, 3)\nv = [[1]\n [2]\n [3]]\nv.shape = (3, 1)\nw = [1 2 3]\nw.shape = (3,)\nB = [[1 2 3]\n [4 5 6]]\nB.shape = (2, 3)"
  },
  {
    "objectID": "Textbook_Solutions.html#장-1",
    "href": "Textbook_Solutions.html#장-1",
    "title": "프로그래밍 실습",
    "section": "2장",
    "text": "2장\n\n2.1 \\(2 \\times 3\\) 영행렬, 모든 성분이 1인 \\(2 \\times 2\\) 행렬, 모든 성분이 3인 \\(3 \\times 2\\) 행렬, \\(2 \\times 2\\) 단위행렬을 만들어 출력하는 프로그램을 작성하라.\n\na = np.zeros((2,3))\nprint(f\"a = {a}\")\n\nb = np.ones((2,2))\nprint(f\"b = {b}\")\n\nc = np.full((3,2),3)\nprint(f\"c = {c}\")\n\nd = np.eye(2)\nprint(f\"d = {d}\")\n\na = [[0. 0. 0.]\n [0. 0. 0.]]\nb = [[1. 1.]\n [1. 1.]]\nc = [[3 3]\n [3 3]\n [3 3]]\nd = [[1. 0.]\n [0. 1.]]\n\n\n\n\n2.2 가우스-조단 소거법을 수행하는 gauss( )라는 함수를 정의하고, 이 함수를 이용하여 다음 연립선형방정식의 해를 구하라. gauss(A)의 입력으로 주어지는 A는 주어진 연립선형방정 식에 대한 첨가행렬이다.\n\\[\n\\begin{matrix}\n2x_1 + 2x_2 + 4x_3 & = & 18 \\\\\nx_1 + 3x_2 + 2x_3 & = & 13 \\\\\n3x_1 + x_2 + 3x_3 & = & 14 \\\\\n\\end{matrix}\n\\]\n\ndef pprint(msg, A):\n    print(\"---\", msg, \"---\")\n    (n,m) = A.shape\n    for i in range(0, n):\n        line = \"\"\n        for j in range(0, m):\n            line += \"{0:.2f}\".format(A[i,j]) + \"\\t\"\n            if j == n-1:\n                line += \"| \"\n        print(line)\n    print(\"\")\n\n\ndef gauss(A):\n    (n,m) = A.shape\n\n    for i in range(0, min(n,m)):\n        # i번째 열에서 절댓값이 최대인 성분의 행 선택\n        maxEl = abs(A[i,i])\n        maxRow = i\n        for k in range(i+1, n):\n            if abs(A[k,i]) &gt; maxEl:\n                maxEl = abs(A[k,i])\n                maxRow = k\n\n        # 현재 i번째 행과 최댓값을 갖는 행 maxRow의 교환\n        for k in range(i, m):\n            tmp = A[maxRow,k]\n            A[maxRow,k] = A[i,k]\n            A[i,k] = tmp\n\n        # 추축성분을 1로 만들기\n        piv = A[i,i]\n        for k in range(i, m):\n            A[i,k] = A[i,k]/piv\n\n        # 현재 i번째 열의 i번째 행을 제외한 모두 성분을 0으로 만들기\n        for k in range(0, n):\n            if k != i:\n                c = A[k,i]/A[i,i]\n                for j in range(i, m):\n                    if i == j:\n                        A[k,j] = 0\n                    else:\n                        A[k,j] = A[k,j] - c * A[i,j]\n\n        pprint(str(i+1)+\"번째 반복\", A) # 중간 과정 출력\n\n    # Ax=b의 해 반환\n    x = np.zeros(m-1)\n    for i in range(0,m-1):\n        x[i] = A[i,m-1]\n    return x\n\n# 주어진 연립선형방정식에 대한 첨가행렬\nA = np.array([[2., 2., 4., 18.], [1., 3., 2., 13.], [3., 1., 3., 14.]])\n\npprint(\"주어진 문제\", A) # 첨가행렬 출력\nx = gauss(A) # 가우스-조단 소거법 적용\n\n# 출력 생성\n(n,m) = A.shape\nline = \"해:\\t\"\nfor i in range(0, m-1):\n    line += \"{0:.2f}\".format(x[i]) + \"\\t\"\nprint(line)\n\n--- 주어진 문제 ---\n2.00    2.00    4.00    | 18.00 \n1.00    3.00    2.00    | 13.00 \n3.00    1.00    3.00    | 14.00 \n\n--- 1번째 반복 ---\n1.00    0.33    1.00    | 4.67  \n0.00    2.67    1.00    | 8.33  \n0.00    1.33    2.00    | 8.67  \n\n--- 2번째 반복 ---\n1.00    0.00    0.88    | 3.63  \n0.00    1.00    0.38    | 3.12  \n0.00    0.00    1.50    | 4.50  \n\n--- 3번째 반복 ---\n1.00    0.00    0.00    | 1.00  \n0.00    1.00    0.00    | 2.00  \n0.00    0.00    1.00    | 3.00  \n\n해:  1.00    2.00    3.00"
  },
  {
    "objectID": "Textbook_Solutions.html#장-2",
    "href": "Textbook_Solutions.html#장-2",
    "title": "프로그래밍 실습",
    "section": "3장",
    "text": "3장\n\n3.1 다음 벡터 \\(v_1\\) , \\(v_2\\), \\(v_3\\)를 행으로 하는 행렬 A와 열로 하는 행렬 B 를 이들 벡터를 사용하여 만들고, 행렬 \\(C\\) 에 \\(v_3\\)를 열로 추가하여 행렬 \\(D\\)를 만들어라. 또한 행렬 \\(E\\)의 1행 4열의 성분, 2 행 3열의 성분, 1~2 행의 3열에 해당하는 부분행렬, 1~2행의 3~4열에 해당하는 부분행렬, 3행에 해당하는 부분행렬을 출력하라. 마지막으로 행렬 \\(E\\)의 1행 1열의 성분을 -1로 변경하고 행렬 \\(E\\)를 출력하라.\n\nprint(\"벡터의 결합에 의한 행렬 생성\")\nv1 = np.array([1, 2, 3])\nv2 = np.array([4, 5, 6])\nv3 = np.array([7, 8, 9])\n\nA = np.vstack([v1, v2, v3]) # v1, v2, v3를 각각 행으로 하는 행렬 A 생성\nprint(\"A =\", A)\n\nB = np.column_stack([v1, v2, v3]) # v1, v2, v3를 각각 열로 하는 행렬 B 생성\nprint(\"B =\", B)\n\nC = np.array([[1, 2], [3, 4], [5, 6]])\nprint(\"C =\", C)\n\nD = np.column_stack([C, v3]) # 행렬 C에 v3를 열로 추가하여 행렬 D 생성\nprint(\"D =\", D)\n\nprint(\"행렬의 성분 접근\")\nE = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])\n\nprint(\"E[0,3] =\", E[0,3]) # 1행 4열의 성분\nprint(\"E[1,2] =\", E[1,2]) # 2행 3열의 성분\n\nprint(\"E[0:2, 2] =\", E[0:2, 2]) # E의 1~2행의 3열에 해당하는 부분행렬\nprint(\"E[0:2, 2:4] =\", E[0:2, 2:4]) # E의 1~2행의 3~4열에 해당하는 부분행렬\nprint(\"E[2, :] =\", E[2, :]) # E의 3행에 해당하는 부분행렬\n\nprint(\"성분의 변경\")\nprint(\"E =\", E)\n\nprint(\"E[0,0] = \", E[0, 0])\nE[0, 0] = -1 # E의 1행 1열 성분을 -1로 변경\nprint(E)\nprint(\"E[0,0] = \", E[0, 0])\n\n벡터의 결합에 의한 행렬 생성\nA = [[1 2 3]\n [4 5 6]\n [7 8 9]]\nB = [[1 4 7]\n [2 5 8]\n [3 6 9]]\nC = [[1 2]\n [3 4]\n [5 6]]\nD = [[1 2 7]\n [3 4 8]\n [5 6 9]]\n행렬의 성분 접근\nE[0,3] = 4\nE[1,2] = 7\nE[0:2, 2] = [3 7]\nE[0:2, 2:4] = [[3 4]\n [7 8]]\nE[2, :] = [ 9 10 11 12]\n성분의 변경\nE = [[ 1  2  3  4]\n [ 5  6  7  8]\n [ 9 10 11 12]]\nE[0,0] =  1\n[[-1  2  3  4]\n [ 5  6  7  8]\n [ 9 10 11 12]]\nE[0,0] =  -1\n\n\n\n\n3.2 다음과 같은 행렬과 벡터를 이용하여 \\(A + B\\), \\(A - B\\), \\(3A\\), \\(2v\\), \\(AB\\), \\(AC\\), \\(Av\\), \\(A^2\\), \\(A^3\\), A 와 B 의 대응 성분별 곱셈 \\(A*B\\), A와 B의 대응 성분별 나눗셈 \\(A/B\\), 성분별 거듭제곱 \\(A**2\\), \\(A^T\\) , \\(v^T\\) , 대각행렬 \\(diag(1, 2, 3)\\)의 생성, \\(D_{11}\\), \\(D_{12}\\), \\(D_{21}\\), \\(D_{22}\\)를 사용한 블록행렬 \\(D\\)의 생성 연산을 수행하고 결과를 출력하는 프로그램을 작성하라.\n\nA = np.array([[1., 2.], [3., 4.]])\nB = np.array([[2., 2.], [1., 3.]])\nC = np.array([[4., 5., 6.], [7., 8., 9.]])\nv = np.array([[10.], [20.]])\n\npprint(\"A+B\", A+B) # 행렬의 합 A+B\npprint(\"A-B\", A-B) # 행렬의 차 A-B\n\npprint(\"3*A \", 3*A) # 행렬의 스칼라배 3A\npprint(\"2*v \", 2*v) # 벡터의 스칼라배 2v\n\npprint(\"matmul(A,B)\", np.matmul(A,B)) # 행렬의 곱 AB\npprint(\"matmul(A,C)\", np.matmul(A,C)) # 행렬의 곱 AC\npprint(\"A*v\", A*v) # 행렬과 벡터의 곱 Av\n\npprint(\"matrix_power(A, 2)\", np.linalg.matrix_power(A, 2)) # 행렬의 거듭제곱 A2\npprint(\"matrix_power(A, 3)\", np.linalg.matrix_power(A, 3)) # 행렬의 거듭제곱 A3\n\npprint(\"A*B\", A*B) # 행렬의 성분별 곱셈 A*B\npprint(\"A/B\", A/B) # 행렬의 성분별 나눗셈 A/B\npprint(\"A**2 == A*A\", A**2) # 행렬의 성분별 거듭제곱 A**2\n\npprint(\"A.T\", A.T) # 행렬의 전치 AT\npprint(\"v.T\", v.T) # 벡터의 전치 vT\n\nM = np.diag([1, 2, 3]) # 대각행렬 diag(1,2,3) 생성\npprint(\"diag(1,2,3) =\", M)\n\nD11 = np.array([[1, 2], [3, 4]])\nD12 = np.array([[5], [6]])\nD21 = np.array([[7, 7]])\nD22 = np.array([[8]])\nD = np.block([[D11, D12], [D21, D22]]) # 블록행렬 D 생성\npprint(\"block matrix\", D)\n\n--- A+B ---\n3.00    4.00    \n4.00    7.00    \n\n--- A-B ---\n-1.00   0.00    \n2.00    1.00    \n\n--- 3*A  ---\n3.00    6.00    \n9.00    12.00   \n\n--- 2*v  ---\n20.00   \n40.00   \n\n--- matmul(A,B) ---\n4.00    8.00    \n10.00   18.00   \n\n--- matmul(A,C) ---\n18.00   21.00   24.00   \n40.00   47.00   54.00   \n\n--- A*v ---\n10.00   20.00   \n60.00   80.00   \n\n--- matrix_power(A, 2) ---\n7.00    10.00   \n15.00   22.00   \n\n--- matrix_power(A, 3) ---\n37.00   54.00   \n81.00   118.00  \n\n--- A*B ---\n2.00    4.00    \n3.00    12.00   \n\n--- A/B ---\n0.50    1.00    \n3.00    1.33    \n\n--- A**2 == A*A ---\n1.00    4.00    \n9.00    16.00   \n\n--- A.T ---\n1.00    3.00    \n2.00    4.00    \n\n--- v.T ---\n10.00   20.00   \n\n--- diag(1,2,3) = ---\n1.00    0.00    0.00    \n0.00    2.00    0.00    \n0.00    0.00    3.00    \n\n--- block matrix ---\n1.00    2.00    5.00    \n3.00    4.00    6.00    \n7.00    7.00    8.00"
  },
  {
    "objectID": "Textbook_Solutions.html#장-3",
    "href": "Textbook_Solutions.html#장-3",
    "title": "프로그래밍 실습",
    "section": "4장",
    "text": "4장\n\n4.1 다음 행렬 A의 역행렬을 구한 다음, 행렬 A와 구한 역행렬의 곱이 단위행렬 I인지 확인하라. 그다음 난수로 3x3 행렬 B를 만들고 그 역행렬을 구한 후，B와 B 의 역행렬을 곱하여 결과를 출력하라. 또한 다음 행렬 C와 D에 대한 행렬방정식 Cx= D의 해를 역행렬을 이용하여 구한 다음, 해가 맞는지 확인하라.\n\nA = np.array([[1., 2.], [3., 4.]])\npprint(\"A\", A)\n\nAinv1 = np.linalg.matrix_power(A, -1) # matrix_power( )를 사용한 역행렬 A-1 계산\npprint(\"linalg.matrix_power(A, -1) =&gt; Ainv1\", Ainv1)\n\nAinv2 = np.linalg.inv(A) # inv( )를 사용한 역행렬 A-1 계산\npprint(\"np.linalg.inv(A) =&gt; Ainv2\", Ainv2)\n\npprint(\"A*Ainv1\", np.matmul(A, Ainv1)) # 행렬 A와 역행렬 A-1의 곱\npprint(\"A*Ainv2\", np.matmul(A, Ainv2)) # 행렬 A와 역행렬 A-1의 곱\n\nB = np.random.rand(3,3) # 난수를 이용한 3x3 행렬 B 생성\npprint(\"B =\", B)\nBinv = np.linalg.inv(B) # 역행렬 B-1 계산\npprint(\"Binv =\", Binv)\npprint(\"B*Binv =\", np.matmul(B, Binv)) # 행렬 B와 역행렬 B-1의 곱\n\n# CX = D의 해 계산\nC = np.array([[5, 3, 2, 1], [6, 2, 4, 5], [7, 4, 1, 3], [4, 3, 5, 2]])\nD = np.array([[4], [2], [5], [1]])\nx = np.matmul(np.linalg.inv(C), D)\npprint(\"x\", x) # 해 x 출력\npprint(\"C*x\", np.matmul(C, x)) # C*x의 결과가 D와 같은지 확인\n\n--- A ---\n1.00    2.00    \n3.00    4.00    \n\n--- linalg.matrix_power(A, -1) =&gt; Ainv1 ---\n-2.00   1.00    \n1.50    -0.50   \n\n--- np.linalg.inv(A) =&gt; Ainv2 ---\n-2.00   1.00    \n1.50    -0.50   \n\n--- A*Ainv1 ---\n1.00    0.00    \n0.00    1.00    \n\n--- A*Ainv2 ---\n1.00    0.00    \n0.00    1.00    \n\n--- B = ---\n0.29    0.40    0.50    \n0.55    0.49    0.21    \n0.89    0.29    0.99    \n\n--- Binv = ---\n-2.66   1.57    1.01    \n2.22    1.00    -1.32   \n1.73    -1.71   0.50    \n\n--- B*Binv = ---\n1.00    -0.00   0.00    \n0.00    1.00    -0.00   \n0.00    -0.00   1.00    \n\n--- x ---\n1.31    \n-0.38   \n-0.31   \n-0.77   \n\n--- C*x ---\n4.00    \n2.00    \n5.00    \n1.00    \n\n\n\n\n\n4.2 임의의 크기의 정방행렬 A 를 LU 분해하는 함수 LU(A)를 사용하여 Ax = b의 해를 구하는 프로그램을 작성하라. [프로그래밍 실습 문제 4-1]의 연립선형방정식을 행렬방정식 Ax = b로 간주하고, 작성한 함수로 계수행렬 A 를 LU 분해하여 이 연립선형방정식의 해를 구하라.\n\n#LU 분해 함수\ndef LU(A):\n    (n,m) = A.shape\n    L = np.zeros((n,n)) # 행렬 L 초기화\n    U = np.zeros((n,n)) # 행렬 U 초기화\n    \n    # 행렬 L과 U 계산\n    for i in range(0, n):\n        for j in range(i, n):\n            U[i, j] = A[i, j]\n            for k in range(0, i):\n                U[i, j] = U[i, j] - L[i, k]*U[k, j]\n        L[i,i] = 1\n        if i &lt; n-1:\n            p = i + 1\n            for j in range(0,p):\n                L[p, j] = A[p, j]\n                for k in range(0, j):\n                    L[p, j] = L[p, j] - L[p, k]*U[k, j]\n                    L[p,j] = L[p,j]/U[j,j]\n    return L, U\n\n# LU 분해를 이용한 Ax=b의 해 구하기\ndef LU_solver(A, b):\n    L, U = LU(A)\n    n = len(L)\n    # Ly=b 계산\n    y = np.zeros((n,1))\n    for i in range(0,n):\n        y[i] = b[i]\n        for k in range(0,i):\n            y[i] -= y[k]*L[i,k]\n    # Ux=y 계산\n    x = np.zeros((n,1))\n    for i in range(n-1, -1, -1):\n        x[i] = y[i]\n        if i &lt; n-1:\n            for k in range(i+1,n):\n                x[i] -= x[k]*U[i,k]\n        x[i] = x[i]/float(U[i,i])\n    return x\n\nA = np.array([[5, 3, 2, 1], [6, 2, 4, 5], [7, 4, 1, 3], [4, 3, 5, 2]])\nb = np.array([[4], [2], [5], [1]])\n\n# 행렬 A의 LU 분해\nL, U = LU(A)\npprint(\"A\", A)\npprint(\"L\", L)\npprint(\"U\", U)\n\n# LU 분해를 이용한 Ax=b의 해 구하기\nx = LU_solver(A,b)\npprint(\"x\", x)\n\n--- A ---\n5.00    3.00    2.00    1.00    \n6.00    2.00    4.00    5.00    \n7.00    4.00    1.00    3.00    \n4.00    3.00    5.00    2.00    \n\n--- L ---\n1.00    0.00    0.00    0.00    \n6.00    1.00    0.00    0.00    \n7.00    1.06    1.00    0.00    \n4.00    0.56    -1.15   1.00    \n\n--- U ---\n5.00    3.00    2.00    1.00    \n0.00    -16.00  -8.00   -1.00   \n0.00    0.00    -4.50   -2.94   \n0.00    0.00    0.00    -4.81   \n\n--- x ---\n-0.06   \n1.54    \n-0.38   \n0.46"
  }
]