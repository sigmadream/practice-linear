[
  {
    "objectID": "Numpy_Introduction.html",
    "href": "Numpy_Introduction.html",
    "title": "Introduction to NumPy and Matplotlib",
    "section": "",
    "text": "Numpy는 선형 대수학 및 기타 과학 컴퓨팅 영역에 필요한 계산을 수행하는 데 필수적인 Python 패키지입니다. Matplotlib은 다양한 그래프를 생성하기 위한 Python 패키지입니다. 선형 대수학에서 접하게 되는 많은 계산에는 NumPy가 사용되지만, 개념을 시각적으로 유용하게 표현하기 위해서만 Matplotlib을 활용하는 것을 권장합니다."
  },
  {
    "objectID": "Numpy_Introduction.html#numpy",
    "href": "Numpy_Introduction.html#numpy",
    "title": "Introduction to NumPy and Matplotlib",
    "section": "NumPy",
    "text": "NumPy\n선형 대수에서 하는 거의 모든 계산은 숫자 배열을 다루는 작업이 포함됩니다. 배열은 행과 열로 배열되어 직사각형을 이루는 숫자의 집합으로 생각할 수 있는데, 아래 예는 행 2개와 열 4개로 이루어진 배열입니다.\n\\[\n\\begin{equation}\n\\left[ \\begin{array}{rrrr} 5 & -1 & 1 & 0 \\\\ 4 & 3 & 12 & -6 \\end{array}\\right]\n\\end{equation}\n\\]\n파이썬의 List 객체를 사용하여 배열을 표현할 수도 있지만, NumPy 배열 객체를 사용하겠습니다. NumPy는 배열을 표현하는 강력한 방법을 가지고 있으며, 배열을 효율적으로 처리하기 위한 많은 내장 도구가 있습니다. 수학 모듈과 마찬가지로, NumPy를 사용하기 전에 해당 패키진를 가져와야 합니다. 이번에는 모듈을 가져오되 입력하기 더 편리한 별칭이라고 하는 다른 이름을 지정하는 \\(\\texttt{import numpy as np}\\) 코드를 사용하겠습니다.\n위의 배열을 만드는 가장 쉬운 방법은 \\(\\texttt{array}\\) 함수를 사용하여 특정 형식의 모든 배열 항목 목록을 제공하는 것입니다. 행 항목은 쉼표로 구분하고 대괄호 []로 묶은 다음, 나열된 모든 행을 쉼표로 구분하고 또 다른 대괄호로 묶습니다.\n\nimport numpy as np\n\nA = np.array([[5, -1, 1, 0],[4, 3, 12, -6]])\nprint(A)\n\n[[ 5 -1  1  0]\n [ 4  3 12 -6]]\n\n\n원하는 배열을 만드는 또 다른 방법은 먼저 하나의 긴 행으로 된 배열을 만든 다음 \\(\\texttt{reshape}\\) 함수를 사용하는 것입니다. 대괄호를 추가로 입력하는 것보다 더 편리할 수 있습니다.\n\nB = np.array([5, -1, 1, 0, 4, 3, 12, -6])\nprint(\"This is B before reshaping.\")\nprint(B)\n\nC = B.reshape((2,4))\nprint(\"This is C, which is the entries of B formed into a new shape.\")\nprint(C)\n\nThis is B before reshaping.\n[ 5 -1  1  0  4  3 12 -6]\nThis is C, which is the entries of B formed into a new shape.\n[[ 5 -1  1  0]\n [ 4  3 12 -6]]\n\n\n우리는 종종 원본의 복사본을 유지하면서 배열을 수정하고 싶을 때가 있습니다. 이 경우 \\(\\texttt{copy}\\) 함수를 사용하여 기존 배열을 복제할 수 있습니다.\n\nD = np.copy(A)\nprint(D)\n\n[[ 5 -1  1  0]\n [ 4  3 12 -6]]\n\n\n배열의 개별 항목에 액세스하려면 한 쌍의 인덱스를 사용하여 액세스하려는 항목의 행과 열을 참조해야 합니다. 거의 모든 다른 컴퓨팅 언어와 마찬가지로 Python에서도 인덱스는 0부터 시작합니다! 즉, 첫 번째 행은 인덱스가 0이고 두 번째 행은 인덱스가 1이라는 뜻입니다. 열도 마찬가지입니다. 0에서 카운트를 시작하는 것은 어렵지 않지만, 프로그래밍을 처음 접하는 사람이라면 사고의 전환이 필요합니다.\n\nprint(A[0,2])\n\n1\n\n\n개별 배열 값에 새 번호를 할당하여 수정할 수 있습니다.\n\nA[0,2] = 8\nprint(A)\n\n[[ 5 -1  8  0]\n [ 4  3 12 -6]]\n\n\n때로는 대부분 0이 포함된 배열을 만드는 것이 유용할 때가 있습니다. 이 경우 모든 0이 포함된 배열을 만든 다음 0이 아닌 항목 몇 개를 수정할 수 있습니다.\n\n## Create a 4x4 array that is all zeros.\nD = np.zeros((4,4))\n## Set entries along the main diagonal to 2.\nfor i in range(4):\n    D[i,i] = 2\n    \nprint(D)\n\n[[2. 0. 0. 0.]\n [0. 2. 0. 0.]\n [0. 0. 2. 0.]\n [0. 0. 0. 2.]]\n\n\nNumPy에 포함된 많은 함수는 어떤 식으로든 선형 대수와 관련이 있습니다. 해당 선형대수 주제를 진행하면서 이러한 함수를 더 많이 시연해 보겠습니다.\n\nRandom module\n코드를 테스트하는 한 가지 방법은 많은 무작위 입력을 제공한 다음 각 인스턴스에서 올바른 결과가 생성되는지 확인하는 것입니다. 무작위 입력을 생성하기 위해 NumPy에 포함된 \\(\\texttt{random}\\) 모듈의 함수를 사용할 것입니다. 예를 들어, 인수가 없는 \\(\\texttt{rand}\\) 함수를 사용하여 0과 1 사이의 난수를 생성할 수 있습니다.\n\nr = np.random.rand()\nprint(r)\n\n0.6983335663800959\n\n\ntexttt{rand}$ 함수를 실행할 때마다 새로운 난수를 산출합니다. texttt{rand}$는 \\(\\texttt{random}\\) 모듈에 포함된 함수이며, 이 모듈은 다시 NumPy에 포함되어 있다는 점에 유의하세요. 따라서 접근하려면 점 표기법을 두 번 사용해야 합니다.\n또한 배열의 행과 열 수를 지정하는 두 개의 인수를 \\(\\texttt{rand}\\)에 전달하여 임의의 숫자 배열을 생성할 수도 있습니다.\n\nX = np.random.rand(3,2)\nprint(X)\n\n[[0.19443351 0.05665268]\n [0.37579411 0.92505324]\n [0.66751134 0.75502419]]\n\n\n임의의 정수를 생성하려면 \\(\\texttt{randint}\\) 함수를 사용할 수 있습니다. 이 함수에는 생성되는 숫자의 상한을 지정하는 인수가 하나 이상 필요합니다. 아래 코드는 0에서 19 사이의 정수 중에서 난수를 생성합니다.\n\nprint(np.random.randint(20))\n\n16\n\n\n무작위 배열을 생성하려면 \\(\\texttt{size}\\)라는 키워드 인수를 사용하여 행과 열의 개수를 지정해야 합니다. 키워드 인수*를 사용하려면 다음 예시와 같이 약간 다른 구문이 필요합니다.\n\nY = np.random.randint(10,size=(3,6))\nprint(Y)\n\n[[9 1 7 8 2 5]\n [4 6 0 9 7 0]\n [2 3 3 6 7 7]]\n\n\n파이썬 함수에서 키워드 인자를 사용하는 것은 매우 일반적입니다. 이 기능의 장점은 인수를 미리 지정된 순서대로 제공할 필요가 없다는 것입니다.\n\nprint(np.random.randint(size=(2,3),high=10,low=1))\n\n[[1 5 5]\n [4 3 8]]\n\n\n또한 \\(\\texttt{random}\\) 모듈에는 지정된 컬렉션에서 무작위로 선택된 값을 생성할 수 있는 \\(\\texttt{choice}\\)라는 함수가 있습니다. 이 함수는 숫자 목록을 인수로 받아 해당 목록에서 무작위로 선택된 값을 반환합니다.\n\nx = np.random.choice([0,3,7,42])\nprint(x)\n\n42\n\n\n또한 \\(\\texttt{choice}\\) 함수를 사용하여 지정된 컬렉션의 값으로 구성된 숫자 배열을 생성할 수도 있습니다. 이 경우 다시 \\(\\texttt{size}\\) 키워드 인수를 사용하면 됩니다.\n\nX = np.random.choice([0,3,7,42], size = (2,3))\nprint(X)\n\n[[ 7  7 42]\n [ 7 42  0]]"
  },
  {
    "objectID": "Numpy_Introduction.html#matplotlib",
    "href": "Numpy_Introduction.html#matplotlib",
    "title": "Introduction to NumPy and Matplotlib",
    "section": "Matplotlib",
    "text": "Matplotlib\nMatplotlib은 다양한 플로팅 기능과 생성된 그림을 정밀하게 사용자 정의할 수 있는 다양한 옵션을 제공합니다. 여기서는 Jupyter 선형 대수학 가이드에 나오는 특정 유형의 그림을 만드는 방법에 대한 설명만 제공하며, 대부분은 동일한 필수 패턴을 따릅니다. 필요한 코드에 대한 몇 가지 세부 사항을 제공하지만 데이터 구조를 엄격하게 설명하거나 라이브러리 내에서 사용할 수 있는 다양한 옵션에 대해 논의하지는 않습니다.\n\nExample 1\n첫 번째 그림에서는 \\((x,y)\\) 좌표가 있는 네 점의 간단한 플롯을 만들겠습니다. 좌표 목록은 NumPy 배열에 저장됩니다.\n\nx = np.array([1, 2.5, 3, 5.8])\ny = np.array([2, 1.2, 1.1, 0.8])\n\n다음 코드 셀에는 플롯을 생성하는 데 필요한 최소한의 지침이 포함되어 있습니다. 셀의 주석은 각 줄의 목적을 나타냅니다.\n\nimport matplotlib.pyplot as plt\n\n%config InlineBackend.figure_format = 'retina'\n\nfig, ax = plt.subplots()\nax.plot(x,y);\n\n\n\n\n\\(texttt{subplots}\\) 메서드는 그림과 축이라는 두 개의 Matplotlib 객체를 생성합니다. 그림은 Matplotlib의 기본 객체입니다. 축 객체는 그림 안에 포함되어 있으며, 우리가 가장 많이 상호작용할 객체입니다. 축 객체의 \\(\\texttt{plot}\\) 메서드는 실제로 좌표 집합을 축에 플롯하는 함수입니다. 결과를 보기 위해 \\(\\texttt{print}\\) 명령이 필요하지 않다는 점에 유의하세요.\n이 기본적인 \\(\\texttt{plot}\\) 메서드 사용으로 생성된 플롯은 데이터 포인트 좌표를 선으로 연결했습니다. 이것이 이 메서드의 기본 기능입니다. Matplotlib 메서드(그리고 실제로 다른 많은 파이썬 라이브러리의 메서드)는 최소한의 인수를 제공하여 생성되는 기본 기능을 가지고 있지만, 이 기본 기능을 변경하는 추가 인수를 제공할 수 있는 것이 일반적입니다. 이 예제에서는 \\(\\texttt{plot}\\) 메서드에 선택적 인수 \\(\\texttt{'b+'}\\)를 제공하여 데이터 좌표를 연결하는 선 대신 파란색 + 기호가 있는 플롯을 생성할 수 있습니다.\n\nfig, ax = plt.subplots()\nax.plot(x,y,'b+');\n\n\n\n\n데이터 요소를 플로팅하는 데 관심이 있는 경우 또 다른 대안은 동일한 구문을 사용할 수 있는 \\(\\texttt{scatter}\\) 메서드입니다.\n\nfig, ax = plt.subplots()\nax.scatter(x,y);\n\n\n\n\n다음은 이러한 플롯에서 사용할 수 있는 여러 옵션 중 일부를 구성하는 방법을 보여드리겠습니다. 플롯은 실제로 축 객체에서 구성되므로 플롯의 요소에 영향을 주는 모든 옵션은 해당 객체의 메서드라는 점을 기억하세요.\n\nfig, ax = plt.subplots()\nax.plot(x,y,'rx');\n\nax.set_xlim(0,8);\nax.set_ylim(0,4);\n\nax.grid(True);\n\nax.set_xlabel('Time');\nax.set_ylabel('Concentration');\n\n\n\n\n\nExample 2\n다음 예제에서는 \\([-2,4]\\) 간격의 \\(x\\)에 대한 곡선 \\(y=0.5x^2\\)를 플롯하는 것이 목표입니다. 동일한 방법을 사용하려면 주어진 간격에서 \\(x\\)에 대해 곡선 위에 놓이는 점 집합을 생성해야 합니다. 지정하는 점들은 직선으로 연결되므로 곡선이 들쭉날쭉한 모양이 되지 않도록 충분한 점을 생성해야 합니다. NumPy 메서드 \\(\\texttt{linspace}\\)는 점을 쉽게 생성할 수 있는 방법을 제공합니다. 이 메서드는 지정된 간격으로 숫자가 균등하게 배치된 NumPy 배열 객체를 생성합니다.\n\nx = np.linspace(-2,4,9)\nprint(x)\n\ny = 0.5*x**2\nprint(y)\n\n[-2.   -1.25 -0.5   0.25  1.    1.75  2.5   3.25  4.  ]\n[2.      0.78125 0.125   0.03125 0.5     1.53125 3.125   5.28125 8.     ]\n\n\n이 플롯에서는 매끄럽게 보이는 곡선을 생성하기 위해 더 많은 수의 점을 사용합니다. 또한 \\(x\\) 및 \\(y\\) 축을 따라 틱을 구성하는 등 몇 가지 다른 옵션을 사용하여 이 플롯의 모양을 조정합니다. 눈금은 축을 따라 격자선과 숫자 레이블을 정의하는 숫자 목록입니다. texttt{plot}$ 메서드는 ticks*의 기본값을 제공하며, 새 값의 배열을 제공하여 변경할 수 있습니다.\n\nx = np.linspace(-2,4,100)\ny = 0.5*x**2\n\nfig, ax = plt.subplots()\nax.plot(x,y);\n\nax.set_xlim(-2,4);\nax.set_ylim(0,8);\n\nax.grid(True,ls='dotted');\n\nax.set_aspect('equal');\n\nax.set_xticks(np.linspace(-2,4,4));\nax.set_yticks(np.linspace(0,8,5));\n\n\n\n\n\nfig, ax = plt.subplots()\nax.plot(x,y,'g',ls='dashed');\n\nax.set_xlim(-3,5);\nax.set_ylim(-1,9);\n\nax.grid(True,ls='dotted');\n\nax.set_aspect('equal');\n\nax.set_xticks(np.linspace(-3,5,9));\nax.set_yticks(np.linspace(-1,9,11));\n\nax.axvline(color='k',linewidth = 1);\nax.axhline(color='k',linewidth = 1);"
  },
  {
    "objectID": "Gaussian_Elimination.html",
    "href": "Gaussian_Elimination.html",
    "title": "Gaussian Elimination",
    "section": "",
    "text": "이 섹션에서는 가장 직접적인 방법으로 선형 시스템을 푸는 데 도움이 되는 몇 가지 파이썬 함수를 정의하겠습니다. 이 알고리즘은 가우스 제거라고 알려져 있으며, 이 시점부터는 제거라고 간단히 부르겠습니다. 제거의 개념은 주어진 시스템을 해는 같지만 풀기가 훨씬 쉬운 다른 시스템과 교환하는 것입니다. 이를 위해 시스템의 해를 보존하면서 점차적으로 해에 더 쉽게 접근할 수 있도록 하는 행 연산이라는 일련의 단계를 수행합니다. 이러한 연산에는 세 가지가 있습니다. 1. 두 방정식의 위치 교환하기 2. 방정식에 0이 아닌 숫자를 곱하기\n3. 방정식을 그 자체의 합과 다른 방정식의 배수로 바꾸기."
  },
  {
    "objectID": "Gaussian_Elimination.html#example-1-row-operations-and-elimination",
    "href": "Gaussian_Elimination.html#example-1-row-operations-and-elimination",
    "title": "Gaussian Elimination",
    "section": "Example 1: Row operations and elimination",
    "text": "Example 1: Row operations and elimination\n예를 들어 보겠습니다.\n\\[\n\\begin{eqnarray*}\nx_1 - x_2 + x_3 & = & 3\\\\\n2x_1 + x_2 + 8x_3 & = & 18\\\\\n4x_1 + 2x_2 -3x_3 & = & -2\n\\end{eqnarray*}\n\\]\n첫 번째 방정식과 마지막 방정식을 바꿀 수 있습니다.\n\\[\n\\begin{eqnarray*}\n4x_1 + 2x_2 -3x_3 & = & -2 \\\\\n2x_1 + x_2 + 8x_3 & = & 18\\\\\nx_1 - x_2 + x_3 & = & 3\n\\end{eqnarray*}\n\\]\n또는 첫 번째 방정식에 \\(5\\)를 곱할 수 있습니다.\n\\[\n\\begin{eqnarray*}\n5x_1 - 5x_2 + 5x_3 & = & 15\\\\\n2x_1 + x_2 + 8x_3 & = & 18\\\\\n4x_1 + 2x_2 -3x_3 & = & -2\n\\end{eqnarray*}\n\\]\n또는 마지막 방정식에 첫 번째 방정식의 \\(2\\)배를 더할 수도 있습니다.\n\\[\n\\begin{eqnarray*}\nx_1 - x_2 + x_3 & = & 3\\\\\n2x_1 + x_2 + 3x_3 & = & 8\\\\\n6x_1 \\quad\\quad -x_3 & = & 4\n\\end{eqnarray*}\n\\]\n마지막 연산이 가장 중요한 이유는 방정식 중 하나에서 변수를 ’제거’할 수 있기 때문입니다. 세 번째 방정식에는 더 이상 \\(x_2\\) 항이 포함되어 있지 않다는 점에 유의하세요. 이것이 제거 알고리즘의 핵심입니다.\n계산을 위해 변수 이름과 “=” 기호를 생략하고 실제 숫자를 모두 배열로 정렬할 수 있습니다.\n\\[\n\\begin{equation}\n\\left[ \\begin{array}{rrrr} 1 & -1 & 1 & 3 \\\\ 2 & 1 & 8 & 18 \\\\ 4 & 2 & -3 & -2 \\end{array}\\right]\n\\end{equation}\n\\]\n이제 이 값으로 NumPy 배열을 만들어 보겠습니다. 나중에 참조할 수 있도록 배열에 \\(\\texttt{A}\\)라는 이름을 지정하겠습니다.\n\nimport numpy as np\nA=np.array([[1,-1,1,3],[2,1,8,18],[4,2,-3,-2]])\n\n배열에 대한 연산을 바로 시작할 수도 있지만, 그 대신 먼저 각 연산을 개별적으로 수행하는 몇 가지 코드를 작성하겠습니다. 각 연산을 파이썬 함수 안에 집어넣어 나중에 계산에 다시 사용할 수 있도록 하겠습니다.\n\ndef row_swap(A,k,l):\n    m = A.shape[0]  # m is number of rows in A\n    n = A.shape[1]  # n is number of columns in A\n    \n    B = np.copy(A).astype('float64')\n        \n    for j in range(n):\n        temp = B[k][j]\n        B[k][j] = B[l][j]\n        B[l][j] = temp\n        \n    return B\n\ndef row_scale(A,k,scale):\n    m = A.shape[0]  # m is number of rows in A\n    n = A.shape[1]  # n is number of columns in A\n    \n    B = np.copy(A).astype('float64')\n\n    for j in range(n):\n        B[k][j] *= scale\n        \n    return B\n\ndef row_add(A,k,l,scale):\n    m = A.shape[0]  # m is number of rows in A\n    n = A.shape[1]  # n is number of columns in A\n    \n    B = np.copy(A).astype('float64')\n        \n    for j in range(n):\n        B[l][j] += B[k][j]*scale\n        \n    return B \n\n이제 \\(\\texttt{row_swap}\\), \\(\\texttt{row_scale}\\), \\(\\texttt{row_add}\\)라는 세 가지 새로운 함수가 생겼습니다. 이 함수를 사용해 어떤 결과가 나오는지 살펴봅시다.\n\nB1 = row_swap(A,0,2)\nB2 = row_scale(A,2,0.5)\nB3 = row_add(A,0,1,2)\n\n\nprint(A)\nprint('\\n')\nprint(B2)\n\n[[ 1 -1  1  3]\n [ 2  1  8 18]\n [ 4  2 -3 -2]]\n\n\n[[ 1.  -1.   1.   3. ]\n [ 2.   1.   8.  18. ]\n [ 2.   1.  -1.5 -1. ]]\n\n\n제거의 목표는 이 배열에 행 연산을 수행하여 다음과 같은 구조의 새 배열을 생성하는 것입니다.\n\\[\n\\begin{equation}\n\\left[ \\begin{array}{cccc} 1 & * & * & * \\\\ 0 & 1 & * & * \\\\ 0 & 0 & 1 & * \\end{array}\\right]\n\\end{equation}\n\\]\n(여기서  기호는 0 또는 1이 될 수도 있고 아닐 수도 있는 다양한 미지의 값을 나타냅니다.)*.\n행 연산을 수행하고 각 단계마다 새로운 이름을 붙인 배열로 진행 상황을 저장합니다. 예를 들어 \\(\\texttt{A1}\\), \\(\\texttt{A2}\\), \\(\\texttt{A3}\\) 등으로 이름을 지정할 수 있습니다. 이렇게 하면 진행 상황을 확인하거나 원하는 경우 돌아가서 코드를 변경할 수 있습니다.\n\n## Add -2 times row 0 to row 1\nA1 = row_add(A,0,1,-2)\nprint(A1,'\\n')\n\n## Add -4 times row 0 to row 2\nA2 = row_add(A1,0,2,-4)\nprint(A2,'\\n')\n\n## Add -2 times row 1 to row 2\nA3 = row_add(A2,1,2,-2)\nprint(A3,'\\n')\n\n## Multiply row 1 by 1/3\nA4 = row_scale(A3,1,1.0/3)\nprint(A4,'\\n')\n\n## Multiply row 2 by 1/19\nA5 = row_scale(A4,2,1.0/-19.)\nprint(A5)\n\n[[ 1. -1.  1.  3.]\n [ 0.  3.  6. 12.]\n [ 4.  2. -3. -2.]] \n\n[[  1.  -1.   1.   3.]\n [  0.   3.   6.  12.]\n [  0.   6.  -7. -14.]] \n\n[[  1.  -1.   1.   3.]\n [  0.   3.   6.  12.]\n [  0.   0. -19. -38.]] \n\n[[  1.  -1.   1.   3.]\n [  0.   1.   2.   4.]\n [  0.   0. -19. -38.]] \n\n[[ 1. -1.  1.  3.]\n [ 0.  1.  2.  4.]\n [-0. -0.  1.  2.]]\n\n\n이제 이 배열을 모든 기호가 제자리에 있는 시스템 설명으로 다시 변환해 보겠습니다. \\[\n\\begin{eqnarray*}\nx_1 - x_2 + x_3 & = & 3\\\\\nx_2 + 2x_3 & = & 4\\\\\nx_3 & = & 2\n\\end{eqnarray*}\n\\]\n제거 단계가 끝나면 우리는 상부 삼각형 시스템이라고 알려진 것을 얻게 됩니다. 이 시스템의 해는 마지막 방정식을 거꾸로 풀면 큰 노력 없이 찾을 수 있습니다. 마지막 방정식은 \\(x_3 = 2\\)임을 알려줍니다. 이 값을 두 번째 방정식에 대입하면 \\(x_2 = 0\\)이 됩니다. 마지막으로, 이 값을 다시 첫 번째 방정식에 대입하면 \\(x_1 = 1\\)이 됩니다. 이처럼 위 삼각형 시스템의 해를 구하는 과정을 역치환이라고 합니다."
  },
  {
    "objectID": "Gaussian_Elimination.html#example-2-finding-pivots",
    "href": "Gaussian_Elimination.html#example-2-finding-pivots",
    "title": "Gaussian Elimination",
    "section": "Example 2: Finding pivots",
    "text": "Example 2: Finding pivots\n보시다시피, 마지막 예제의 코드는 배율을 계산하기 위해 나눈 배열의 항목 중 하나라도 0이 나타나면 실패합니다. 이러한 중요한 항목을 피벗이라고 하며, 매트릭스에서 해당 항목의 위치를 피벗 위치라고 합니다. 정의상 피벗은 0이 아니어야 합니다. 제거 단계에서 피벗 위치에 0이 발생하면 행의 순서를 바꿔서 0이 아닌 항목을 피벗 위치로 옮길 수 있습니다. 무작위 배열에서 작동하는 코드를 작성하기 전에 먼저 특정 배열에 대해 이 방법을 시도해 보겠습니다.\n\\[\n\\begin{eqnarray*}\nx_1 - x_2 + x_3 & = & 3\\\\\n2x_1 - 2x_2 + 4x_3 & = & 8\\\\\n3x_1 \\quad\\quad -9x_3 & = & 0\n\\end{eqnarray*}\n\\]\n\nG=np.array([[1,-1,1,3],[2,-2,4,8],[3,0,-9,0]])\nprint(G)\n\n[[ 1 -1  1  3]\n [ 2 -2  4  8]\n [ 3  0 -9  0]]\n\n\n\n## Add -2 times row 0 to row 1\nG1 = row_add(G,0,1,-2)\n## Add -3 times row 0 to row 2\nG2 = row_add(G1,0,2,-3)\nprint(G2)\n\n[[  1.  -1.   1.   3.]\n [  0.   0.   2.   2.]\n [  0.   3. -12.  -9.]]\n\n\n이제 중간 피벗 위치에 0이 있습니다. 제거를 계속하기 위해 중간 방정식과 마지막 방정식을 바꿀 수 있습니다.\n\n## Swap rows 1 and 2\nG3 = row_swap(G2,1,2)\n## Scale the new row 1 by 1/3\nG4 = row_scale(G3,1,1./3)\n## Scale the new row 2 by 1/2\nG5 = row_scale(G4,2,1./2)\nprint(G5)\n\n[[ 1. -1.  1.  3.]\n [ 0.  1. -4. -3.]\n [ 0.  0.  1.  1.]]\n\n\n시스템을 익숙한 방정식 집합으로 다시 작성합니다.\n\\[\n\\begin{eqnarray*}\nx_1 - x_2 + x_3 & = & 3\\\\\nx_2 - 4x_3 & = & -3\\\\\nx_3 & = & 1\n\\end{eqnarray*}\n\\]\n역치환을 적용하면 \\(x_2 = 1\\)과 \\(x_1=3\\)이 됩니다.\n행을 바꾸는 것은 정리의 문제로만 필요하다는 점에 주목할 필요가 있습니다. 다음은 제거를 수행하여 동일한 시스템으로 끝낼 수 있는 다른 방법입니다.\n\n## Scale row 1 by 1/2\nG3_alternative = row_scale(G2,1,1./2)\n## Scale row 2 by 1/3\nG4_alternative = row_scale(G3_alternative,2,1./3)\nprint(G4_alternative)\n\n[[ 1. -1.  1.  3.]\n [ 0.  0.  1.  1.]\n [ 0.  1. -4. -3.]]\n\n\n생성된 배열은 방정식의 순서는 물론 다르지만 동일한 단순화된 시스템을 나타냅니다.\n\\[\n\\begin{eqnarray*}\nx_1 - x_2 + x_3 & = & 3\\\\\nx_3 & = & 1 \\\\\nx_2 - 4x_3 & = & -3\n\\end{eqnarray*}\n\\]\n역치환의 개념은 이러한 형태의 시스템에서도 잘 작동하지만 알고리즘의 구성이 약간 더 복잡해집니다."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "Linear_Systems.html",
    "href": "Linear_Systems.html",
    "title": "Linear Systems",
    "section": "",
    "text": "이 첫 번째 장에서는 선형 방정식 시스템을 살펴보고 그 해를 구하는 방법을 모색합니다. 또한 이후 장에서 필요한 행렬 대수학의 기법을 소개하고 몇 가지 응용 프로그램으로 마무리합니다.\n미지수 \\(x_1\\), \\(x_2\\), \\(x_3\\), … \\(x_n\\)이 있는 \\(m\\) 방정식의 선형 시스템은 다음과 같은 형식으로 쓸 수 있는 방정식의 집합입니다.\n\\[\n\\begin{eqnarray*}\na_{11}x_1 + a_{12}x_2 + \\hspace{0.5cm} ... \\hspace{0.5cm} + a_{1n}x_n & = & b_1 \\\\\na_{21}x_1 + a_{22}x_2 + \\hspace{0.5cm} ... \\hspace{0.5cm} + a_{2n}x_n & = & b_2 \\\\\n\\vdots \\hspace{1.2cm} \\vdots \\hspace{3cm} \\vdots \\hspace{0.5cm}  & = & \\vdots \\\\\na_{m1}x_1 + a_{m2}x_2 + \\hspace{0.5cm} ... \\hspace{0.5cm} +  a_{mn}x_n & = & b_m \\\\\n\\end{eqnarray*}\n\\]\n선형 방정식의 해는 모든 방정식을 동시에 만족하는 미지수의 값 집합입니다. 이 시스템의 가능한 모든 해의 집합을 해집합이라고 합니다. 하나 이상의 해가 있는 선형 시스템은 일관성이 있다고 하며, 해가 없는 선형 시스템은 불일치한다고 합니다.\n두 개의 방정식과 두 개의 미지수가 있는 선형 시스템은 \\(x_1x_2\\) 좌표 평면에서 각 방정식을 만족하는 점의 집합을 쉽게 그래프로 그릴 수 있으므로 좋은 출발점이 됩니다. 두 변수의 단일 선형 방정식을 만족하는 점의 집합은 평면에서 선을 형성합니다. 이 설정에서 선형 시스템의 가능한 해집합을 보여드리기 위해 세 가지 예로 충분합니다."
  },
  {
    "objectID": "Linear_Systems.html#example-1-system-with-a-unique-solution",
    "href": "Linear_Systems.html#example-1-system-with-a-unique-solution",
    "title": "Linear Systems",
    "section": "Example 1: System with a unique solution",
    "text": "Example 1: System with a unique solution\n\\[\n\\begin{eqnarray*}\nx_1 + 3x_2 & = & 5 \\\\\nx_1 - 2x_2 & = & -5 \\\\\n\\end{eqnarray*}\n\\]\n각 방정식의 해집합은 선으로 나타낼 수 있으며, 선형 시스템의 해집합은 두 선에 놓인 모든 점으로 나타낼 수 있습니다. 이 경우 선은 한 점에서 교차하며 두 방정식을 모두 만족하는 값은 \\(x_1 = -1\\), \\(x_2 = 2\\) 한 쌍만 존재합니다. 이 선형 시스템은 일관성이 있습니다.\n\n%matplotlib inline\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nx=np.linspace(-5,5,100)\n\nfig, ax = plt.subplots()\nax.plot(x,(5-x)/3)\nax.plot(x,(5+x)/2)\n\nax.text(1,1.6,'$x_1+3x_2 = 5$')\nax.text(-3,0.5,'$x_1-2x_2 = -5$')\n\nax.set_xlim(-4,4)\nax.set_ylim(-2,6)\nax.axvline(color='k',linewidth = 1)\nax.axhline(color='k',linewidth = 1)\n\n## This options specifies the ticks based the list of numbers provided.\nax.set_xticks(list(range(-4,5)))\nax.set_aspect('equal')\nax.grid(True,ls=':')"
  },
  {
    "objectID": "Linear_Systems.html#example-2-system-with-no-solutions",
    "href": "Linear_Systems.html#example-2-system-with-no-solutions",
    "title": "Linear Systems",
    "section": "Example 2: System with no solutions",
    "text": "Example 2: System with no solutions\n\\[\n\\begin{eqnarray*}\nx_1 + 3x_2 & = & 5 \\\\\nx_1 + 3x_2 & = & 0 \\\\\n\\end{eqnarray*}\n\\]\n이 예에서 개별 방정식의 해집합은 평행한 선을 나타냅니다. 두 방정식을 동시에 만족하는 값 쌍은 없습니다. 이 선형 시스템은 일관성이 없습니다.\n\nfig, ax = plt.subplots()\nax.plot(x,(5-x)/3)\nax.plot(x,-x/3)\n\nax.text(1,1.6,'$x_1+3x_2 = 5$')\nax.text(0.3,-1.4,'$x_1+3x_2 = 0$')\n\nax.set_xlim(-4,4)\nax.set_ylim(-2,6)\nax.axvline(color='k',linewidth = 1)\nax.axhline(color='k',linewidth = 1)\n\n## This options specifies the ticks based the list of numbers provided.\nax.set_xticks(list(range(-4,5)))\nax.set_aspect('equal')\nax.grid(True,ls=':')"
  },
  {
    "objectID": "Linear_Systems.html#example-3-system-with-an-infinite-number-of-solutions",
    "href": "Linear_Systems.html#example-3-system-with-an-infinite-number-of-solutions",
    "title": "Linear Systems",
    "section": "Example 3: System with an infinite number of solutions",
    "text": "Example 3: System with an infinite number of solutions\n\\[\n\\begin{eqnarray*}\nx_1 + 3x_2 & = & 5 \\\\\n2x_1 + 6x_2 & = & 10 \\\\\n\\end{eqnarray*}\n\\]\n마지막 예제에서 두 번째 방정식은 첫 번째 방정식의 배수입니다. 두 방정식의 해는 모두 같은 선으로 표시되므로 선의 모든 점이 선형 시스템의 해입니다. 이 선형 시스템은 일관성이 있습니다.\n\nfig, ax = plt.subplots()\nax.plot(x,(5-x)/3)\nax.plot(x,(5-x)/3)\n\nax.text(1,1.6,'$x_1+3x_2 = 5$')\nax.text(-3,1.2,'$2x_1+6x_2 = 10$')\n\nax.set_xlim(-4,4)\nax.set_ylim(-2,6)\nax.axvline(color='k',linewidth = 1)\nax.axhline(color='k',linewidth = 1)\n\nax.set_xticks(list(range(-4,5)))\nax.set_aspect('equal')\nax.grid(True,ls=':')\n\n\n\n\n이 예는 두 개의 미지수가 있는 두 방정식의 시스템에서 발생할 수 있는 모든 유형의 해집합을 보여줍니다. 정확히 하나의 해가 있을 수도 있고, 해가 없을 수도 있으며, 무한한 해의 집합이 있을 수도 있습니다. 선형 시스템에 대한 기본적인 사실은 해집합이 이 세 가지 경우 중 하나라는 것입니다."
  }
]