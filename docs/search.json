[
  {
    "objectID": "Numpy_Basic.html",
    "href": "Numpy_Basic.html",
    "title": "Introduction to NumPy and Matplotlib",
    "section": "",
    "text": "Numpy는 선형 대수학 및 기타 과학 컴퓨팅 영역에 필요한 계산을 수행하는 데 필수적인 Python 패키지입니다. Matplotlib은 다양한 그래프를 생성하기 위한 Python 패키지입니다. 선형 대수학에서 접하게 되는 많은 계산에는 NumPy가 사용되지만, 개념을 시각적으로 유용하게 표현하기 위해서만 Matplotlib을 활용하는 것을 권장합니다."
  },
  {
    "objectID": "Numpy_Basic.html#numpy",
    "href": "Numpy_Basic.html#numpy",
    "title": "Introduction to NumPy and Matplotlib",
    "section": "NumPy",
    "text": "NumPy\n선형 대수에서 하는 거의 모든 계산은 숫자 배열을 다루는 작업이 포함됩니다. 배열은 행과 열로 배열되어 직사각형을 이루는 숫자의 집합으로 생각할 수 있는데, 아래 예는 행 2개와 열 4개로 이루어진 배열입니다.\n\\[\n\\begin{equation}\n\\left[ \\begin{array}{rrrr} 5 & -1 & 1 & 0 \\\\ 4 & 3 & 12 & -6 \\end{array}\\right]\n\\end{equation}\n\\]\n파이썬의 List 객체를 사용하여 배열을 표현할 수도 있지만, NumPy 배열 객체를 사용하겠습니다. NumPy는 배열을 표현하는 강력한 방법을 가지고 있으며, 배열을 효율적으로 처리하기 위한 많은 내장 도구가 있습니다. 수학 모듈과 마찬가지로, NumPy를 사용하기 전에 해당 패키진를 가져와야 합니다. 이번에는 모듈을 가져오되 입력하기 더 편리한 별칭이라고 하는 다른 이름을 지정하는 \\(\\texttt{import numpy as np}\\) 코드를 사용하겠습니다.\n위의 배열을 만드는 가장 쉬운 방법은 \\(\\texttt{array}\\) 함수를 사용하여 특정 형식의 모든 배열 항목 목록을 제공하는 것입니다. 행 항목은 쉼표로 구분하고 대괄호 []로 묶은 다음, 나열된 모든 행을 쉼표로 구분하고 또 다른 대괄호로 묶습니다.\n\nimport numpy as np\n\nA = np.array([[5, -1, 1, 0],[4, 3, 12, -6]])\nprint(A)\n\n[[ 5 -1  1  0]\n [ 4  3 12 -6]]\n\n\n원하는 배열을 만드는 또 다른 방법은 먼저 하나의 긴 행으로 된 배열을 만든 다음 \\(\\texttt{reshape}\\) 함수를 사용하는 것입니다. 대괄호를 추가로 입력하는 것보다 더 편리할 수 있습니다.\n\nB = np.array([5, -1, 1, 0, 4, 3, 12, -6])\nprint(\"This is B before reshaping.\")\nprint(B)\n\nC = B.reshape((2,4))\nprint(\"This is C, which is the entries of B formed into a new shape.\")\nprint(C)\n\nThis is B before reshaping.\n[ 5 -1  1  0  4  3 12 -6]\nThis is C, which is the entries of B formed into a new shape.\n[[ 5 -1  1  0]\n [ 4  3 12 -6]]\n\n\n우리는 종종 원본의 복사본을 유지하면서 배열을 수정하고 싶을 때가 있습니다. 이 경우 \\(\\texttt{copy}\\) 함수를 사용하여 기존 배열을 복제할 수 있습니다.\n\nD = np.copy(A)\nprint(D)\n\n[[ 5 -1  1  0]\n [ 4  3 12 -6]]\n\n\n배열의 개별 항목에 액세스하려면 한 쌍의 인덱스를 사용하여 액세스하려는 항목의 행과 열을 참조해야 합니다. 거의 모든 다른 컴퓨팅 언어와 마찬가지로 Python에서도 인덱스는 0부터 시작합니다! 즉, 첫 번째 행은 인덱스가 0이고 두 번째 행은 인덱스가 1이라는 뜻입니다. 열도 마찬가지입니다. 0에서 카운트를 시작하는 것은 어렵지 않지만, 프로그래밍을 처음 접하는 사람이라면 사고의 전환이 필요합니다.\n\nprint(A[0,2])\n\n1\n\n\n개별 배열 값에 새 번호를 할당하여 수정할 수 있습니다.\n\nA[0,2] = 8\nprint(A)\n\n[[ 5 -1  8  0]\n [ 4  3 12 -6]]\n\n\n때로는 대부분 0이 포함된 배열을 만드는 것이 유용할 때가 있습니다. 이 경우 모든 0이 포함된 배열을 만든 다음 0이 아닌 항목 몇 개를 수정할 수 있습니다.\n\n## Create a 4x4 array that is all zeros.\nD = np.zeros((4,4))\n## Set entries along the main diagonal to 2.\nfor i in range(4):\n    D[i,i] = 2\n    \nprint(D)\n\n[[2. 0. 0. 0.]\n [0. 2. 0. 0.]\n [0. 0. 2. 0.]\n [0. 0. 0. 2.]]\n\n\nNumPy에 포함된 많은 함수는 어떤 식으로든 선형 대수와 관련이 있습니다. 해당 선형대수 주제를 진행하면서 이러한 함수를 더 많이 시연해 보겠습니다.\n\nRandom module\n코드를 테스트하는 한 가지 방법은 많은 무작위 입력을 제공한 다음 각 인스턴스에서 올바른 결과가 생성되는지 확인하는 것입니다. 무작위 입력을 생성하기 위해 NumPy에 포함된 \\(\\texttt{random}\\) 모듈의 함수를 사용할 것입니다. 예를 들어, 인수가 없는 \\(\\texttt{rand}\\) 함수를 사용하여 0과 1 사이의 난수를 생성할 수 있습니다.\n\nr = np.random.rand()\nprint(r)\n\n0.6983335663800959\n\n\ntexttt{rand}$ 함수를 실행할 때마다 새로운 난수를 산출합니다. texttt{rand}$는 \\(\\texttt{random}\\) 모듈에 포함된 함수이며, 이 모듈은 다시 NumPy에 포함되어 있다는 점에 유의하세요. 따라서 접근하려면 점 표기법을 두 번 사용해야 합니다.\n또한 배열의 행과 열 수를 지정하는 두 개의 인수를 \\(\\texttt{rand}\\)에 전달하여 임의의 숫자 배열을 생성할 수도 있습니다.\n\nX = np.random.rand(3,2)\nprint(X)\n\n[[0.19443351 0.05665268]\n [0.37579411 0.92505324]\n [0.66751134 0.75502419]]\n\n\n임의의 정수를 생성하려면 \\(\\texttt{randint}\\) 함수를 사용할 수 있습니다. 이 함수에는 생성되는 숫자의 상한을 지정하는 인수가 하나 이상 필요합니다. 아래 코드는 0에서 19 사이의 정수 중에서 난수를 생성합니다.\n\nprint(np.random.randint(20))\n\n16\n\n\n무작위 배열을 생성하려면 \\(\\texttt{size}\\)라는 키워드 인수를 사용하여 행과 열의 개수를 지정해야 합니다. 키워드 인수*를 사용하려면 다음 예시와 같이 약간 다른 구문이 필요합니다.\n\nY = np.random.randint(10,size=(3,6))\nprint(Y)\n\n[[9 1 7 8 2 5]\n [4 6 0 9 7 0]\n [2 3 3 6 7 7]]\n\n\n파이썬 함수에서 키워드 인자를 사용하는 것은 매우 일반적입니다. 이 기능의 장점은 인수를 미리 지정된 순서대로 제공할 필요가 없다는 것입니다.\n\nprint(np.random.randint(size=(2,3),high=10,low=1))\n\n[[1 5 5]\n [4 3 8]]\n\n\n또한 \\(\\texttt{random}\\) 모듈에는 지정된 컬렉션에서 무작위로 선택된 값을 생성할 수 있는 \\(\\texttt{choice}\\)라는 함수가 있습니다. 이 함수는 숫자 목록을 인수로 받아 해당 목록에서 무작위로 선택된 값을 반환합니다.\n\nx = np.random.choice([0,3,7,42])\nprint(x)\n\n42\n\n\n또한 \\(\\texttt{choice}\\) 함수를 사용하여 지정된 컬렉션의 값으로 구성된 숫자 배열을 생성할 수도 있습니다. 이 경우 다시 \\(\\texttt{size}\\) 키워드 인수를 사용하면 됩니다.\n\nX = np.random.choice([0,3,7,42], size = (2,3))\nprint(X)\n\n[[ 7  7 42]\n [ 7 42  0]]"
  },
  {
    "objectID": "Numpy_Basic.html#matplotlib",
    "href": "Numpy_Basic.html#matplotlib",
    "title": "Introduction to NumPy and Matplotlib",
    "section": "Matplotlib",
    "text": "Matplotlib\nMatplotlib은 다양한 플로팅 기능과 생성된 그림을 정밀하게 사용자 정의할 수 있는 다양한 옵션을 제공합니다. 여기서는 Jupyter 선형 대수학 가이드에 나오는 특정 유형의 그림을 만드는 방법에 대한 설명만 제공하며, 대부분은 동일한 필수 패턴을 따릅니다. 필요한 코드에 대한 몇 가지 세부 사항을 제공하지만 데이터 구조를 엄격하게 설명하거나 라이브러리 내에서 사용할 수 있는 다양한 옵션에 대해 논의하지는 않습니다.\n\nExample 1\n첫 번째 그림에서는 \\((x,y)\\) 좌표가 있는 네 점의 간단한 플롯을 만들겠습니다. 좌표 목록은 NumPy 배열에 저장됩니다.\n\nx = np.array([1, 2.5, 3, 5.8])\ny = np.array([2, 1.2, 1.1, 0.8])\n\n다음 코드 셀에는 플롯을 생성하는 데 필요한 최소한의 지침이 포함되어 있습니다. 셀의 주석은 각 줄의 목적을 나타냅니다.\n\nimport matplotlib.pyplot as plt\n\n%config InlineBackend.figure_format = 'retina'\n\nfig, ax = plt.subplots()\nax.plot(x,y);\n\n\n\n\n\\(texttt{subplots}\\) 메서드는 그림과 축이라는 두 개의 Matplotlib 객체를 생성합니다. 그림은 Matplotlib의 기본 객체입니다. 축 객체는 그림 안에 포함되어 있으며, 우리가 가장 많이 상호작용할 객체입니다. 축 객체의 \\(\\texttt{plot}\\) 메서드는 실제로 좌표 집합을 축에 플롯하는 함수입니다. 결과를 보기 위해 \\(\\texttt{print}\\) 명령이 필요하지 않다는 점에 유의하세요.\n이 기본적인 \\(\\texttt{plot}\\) 메서드 사용으로 생성된 플롯은 데이터 포인트 좌표를 선으로 연결했습니다. 이것이 이 메서드의 기본 기능입니다. Matplotlib 메서드(그리고 실제로 다른 많은 파이썬 라이브러리의 메서드)는 최소한의 인수를 제공하여 생성되는 기본 기능을 가지고 있지만, 이 기본 기능을 변경하는 추가 인수를 제공할 수 있는 것이 일반적입니다. 이 예제에서는 \\(\\texttt{plot}\\) 메서드에 선택적 인수 \\(\\texttt{'b+'}\\)를 제공하여 데이터 좌표를 연결하는 선 대신 파란색 + 기호가 있는 플롯을 생성할 수 있습니다.\n\nfig, ax = plt.subplots()\nax.plot(x,y,'b+');\n\n\n\n\n데이터 요소를 플로팅하는 데 관심이 있는 경우 또 다른 대안은 동일한 구문을 사용할 수 있는 \\(\\texttt{scatter}\\) 메서드입니다.\n\nfig, ax = plt.subplots()\nax.scatter(x,y);\n\n\n\n\n다음은 이러한 플롯에서 사용할 수 있는 여러 옵션 중 일부를 구성하는 방법을 보여드리겠습니다. 플롯은 실제로 축 객체에서 구성되므로 플롯의 요소에 영향을 주는 모든 옵션은 해당 객체의 메서드라는 점을 기억하세요.\n\nfig, ax = plt.subplots()\nax.plot(x,y,'rx');\n\nax.set_xlim(0,8);\nax.set_ylim(0,4);\n\nax.grid(True);\n\nax.set_xlabel('Time');\nax.set_ylabel('Concentration');\n\n\n\n\n\nExample 2\n다음 예제에서는 \\([-2,4]\\) 간격의 \\(x\\)에 대한 곡선 \\(y=0.5x^2\\)를 플롯하는 것이 목표입니다. 동일한 방법을 사용하려면 주어진 간격에서 \\(x\\)에 대해 곡선 위에 놓이는 점 집합을 생성해야 합니다. 지정하는 점들은 직선으로 연결되므로 곡선이 들쭉날쭉한 모양이 되지 않도록 충분한 점을 생성해야 합니다. NumPy 메서드 \\(\\texttt{linspace}\\)는 점을 쉽게 생성할 수 있는 방법을 제공합니다. 이 메서드는 지정된 간격으로 숫자가 균등하게 배치된 NumPy 배열 객체를 생성합니다.\n\nx = np.linspace(-2,4,9)\nprint(x)\n\ny = 0.5*x**2\nprint(y)\n\n[-2.   -1.25 -0.5   0.25  1.    1.75  2.5   3.25  4.  ]\n[2.      0.78125 0.125   0.03125 0.5     1.53125 3.125   5.28125 8.     ]\n\n\n이 플롯에서는 매끄럽게 보이는 곡선을 생성하기 위해 더 많은 수의 점을 사용합니다. 또한 \\(x\\) 및 \\(y\\) 축을 따라 틱을 구성하는 등 몇 가지 다른 옵션을 사용하여 이 플롯의 모양을 조정합니다. 눈금은 축을 따라 격자선과 숫자 레이블을 정의하는 숫자 목록입니다. texttt{plot}$ 메서드는 ticks*의 기본값을 제공하며, 새 값의 배열을 제공하여 변경할 수 있습니다.\n\nx = np.linspace(-2,4,100)\ny = 0.5*x**2\n\nfig, ax = plt.subplots()\nax.plot(x,y);\n\nax.set_xlim(-2,4);\nax.set_ylim(0,8);\n\nax.grid(True,ls='dotted');\n\nax.set_aspect('equal');\n\nax.set_xticks(np.linspace(-2,4,4));\nax.set_yticks(np.linspace(0,8,5));\n\n\n\n\n\nfig, ax = plt.subplots()\nax.plot(x,y,'g',ls='dashed');\n\nax.set_xlim(-3,5);\nax.set_ylim(-1,9);\n\nax.grid(True,ls='dotted');\n\nax.set_aspect('equal');\n\nax.set_xticks(np.linspace(-3,5,9));\nax.set_yticks(np.linspace(-1,9,11));\n\nax.axvline(color='k',linewidth = 1);\nax.axhline(color='k',linewidth = 1);"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Index",
    "section": "",
    "text": "2023년 겨울 계절학기에 진행된 “공학선형대수학 (CB3500573-059)”에 사용된 Python 코드 및 간단한 예제등을 모아둔 곳 입니다. 선형대수학 공부에 도움이 되시길 바라니다."
  },
  {
    "objectID": "Gaussian_Elimination.html",
    "href": "Gaussian_Elimination.html",
    "title": "가우스 소거법(Gaussian Elimination)",
    "section": "",
    "text": "연립 선형방정식을 푸는 데 도움이 되는 몇 가지 파이썬 함수를 사용하여, 가우스 소거법에 대해서 알아보겠습니다. 가우스 소거법의 핵심은 해를 보존하면서 점차적으로 해에 더 쉽게 접근할 수 있도록 하는 행 연산이라는 일련의 단계를 적용하는 것 입니다. 기본 행 연산은 세 가지가 있습니다. 1. 두 방정식의 위치 교환하기(interchange) 2. 방정식에 0이 아닌 숫자를 곱하기(scaling) 3. 특정 행을 자기 자신과 다른 행의 배수 배를 합한 것으로 교체(replacement)"
  },
  {
    "objectID": "Gaussian_Elimination.html#예제-1-row-operations-and-elimination",
    "href": "Gaussian_Elimination.html#예제-1-row-operations-and-elimination",
    "title": "가우스 소거법(Gaussian Elimination)",
    "section": "예제 1: Row operations and elimination",
    "text": "예제 1: Row operations and elimination\n예를 들어 보겠습니다.\n\\[\n\\begin{matrix}\nx_1 - x_2 + x_3 & = & 3\\\\\n2x_1 + x_2 + 8x_3 & = & 18\\\\\n4x_1 + 2x_2 -3x_3 & = & -2\n\\end{matrix}\n\\]\n첫 번째 방정식과 마지막 방정식을 바꿀 수 있습니다.\n\\[\n\\begin{matrix}\n4x_1 + 2x_2 -3x_3 & = & -2 \\\\\n2x_1 + x_2 + 8x_3 & = & 18\\\\\nx_1 - x_2 + x_3 & = & 3\n\\end{matrix}\n\\]\n또는 첫 번째 방정식에 \\(5\\)를 곱할 수 있습니다.\n\\[\n\\begin{matrix}\n5x_1 - 5x_2 + 5x_3 & = & 15\\\\\n2x_1 + x_2 + 8x_3 & = & 18\\\\\n4x_1 + 2x_2 -3x_3 & = & -2\n\\end{matrix}\n\\]\n또는 마지막 방정식에 첫 번째 방정식의 \\(2\\)배를 더할 수도 있습니다.\n\\[\n\\begin{matrix}\nx_1 - x_2 + x_3 & = & 3\\\\\n2x_1 + x_2 + 3x_3 & = & 8\\\\\n6x_1 \\quad\\quad -x_3 & = & 4\n\\end{matrix}\n\\]\n마지막 연산이 가장 중요한 이유는 방정식 중 하나에서 변수를 ’제거’할 수 있기 때문입니다. 세 번째 방정식에는 더 이상 \\(x_2\\) 항이 포함되어 있지 않다는 점에 유의하세요. 이것이 ’가우스 소거법’의 핵심입니다.\n계산을 위해 변수 이름과 “=” 기호를 생략하고 실제 숫자를 모두 배열로 정렬할 수 있습니다.\n\\[\n\\begin{matrix}\n\\left[ \\begin{array}{ccc|c} 1 & -1 & 1 & 3 \\\\ 2 & 1 & 8 & 18 \\\\ 4 & 2 & -3 & -2 \\end{array}\\right]\n\\end{matrix}\n\\]\n이제 이 값으로 NumPy 배열을 만들어 보겠습니다. 나중에 참조할 수 있도록 배열에 \\(\\texttt{A}\\)라는 이름을 지정하겠습니다.\n\nimport numpy as np\nA=np.array([[1,-1,1,3],[2,1,8,18],[4,2,-3,-2]])\n\n기본 행 연산을 수행할 수 있는 간단한 함수를 작성하도록 하겠습니다.\n\ndef row_swap(A,k,l):\n    m = A.shape[0]  # m is number of rows in A\n    n = A.shape[1]  # n is number of columns in A\n    \n    B = np.copy(A).astype('float64')\n        \n    for j in range(n):\n        temp = B[k][j]\n        B[k][j] = B[l][j]\n        B[l][j] = temp\n        \n    return B\n\ndef row_scale(A,k,scale):\n    m = A.shape[0]  # m is number of rows in A\n    n = A.shape[1]  # n is number of columns in A\n    \n    B = np.copy(A).astype('float64')\n\n    for j in range(n):\n        B[k][j] *= scale\n        \n    return B\n\ndef row_add(A,k,l,scale):\n    m = A.shape[0]  # m is number of rows in A\n    n = A.shape[1]  # n is number of columns in A\n    \n    B = np.copy(A).astype('float64')\n        \n    for j in range(n):\n        B[l][j] += B[k][j]*scale\n        \n    return B \n\n이제 row_swap, row_scale, row_add라는 세 가지 새로운 함수가 생겼습니다. 이 함수를 사용해 어떤 결과가 나오는지 살펴봅시다.\n\nB1 = row_swap(A,0,2)\nB2 = row_scale(A,2,0.5)\nB3 = row_add(A,0,1,2)\n\n\nprint(A,'\\n')\nprint(B2,'\\n')\n\n가우스 소거법의 목표는 행 연산을 수행하여 다음과 같은 구조의 행렬을 생성하는 것입니다.\n\\[\n\\begin{equation}\n\\left[ \\begin{array}{ccc|c} 1 & * & * & * \\\\ 0 & 1 & * & * \\\\ 0 & 0 & 1 & * \\end{array}\\right]\n\\end{equation}\n\\]\n(여기서  기호는 0 또는 1이 될 수도 있고 아닐 수도 있는 다양한 미지의 값을 나타냅니다.)*.\n행 연산을 수행하고 각 단계마다 새로운 이름을 붙인 배열로 진행 상황을 저장합니다. 예를 들어 \\(\\texttt{A1}\\), \\(\\texttt{A2}\\), \\(\\texttt{A3}\\) 등으로 이름을 지정할 수 있습니다. 이렇게 하면 진행 상황을 확인하거나 원하는 경우 돌아가서 코드를 변경할 수 있습니다.\n\nA1 = row_add(A,0,1,-2)\nprint(A1,'\\n')\nA2 = row_add(A1,0,2,-4)\nprint(A2,'\\n')\nA3 = row_add(A2,1,2,-2)\nprint(A3,'\\n')\nA4 = row_scale(A3,1,1.0/3)\nprint(A4,'\\n')\nA5 = row_scale(A4,2,1.0/-19.)\nprint(A5,'\\n')\n\n이제 행렬을 연립 선형 방정식 형태로 다시 표현하도록 하겠습니다.\n\\[\n\\begin{matrix}\nx_1 - x_2 + x_3 & = & 3\\\\\nx_2 + 2x_3 & = & 4\\\\\nx_3 & = & 2\n\\end{matrix}\n\\]\n해는 마지막 방정식을 활용해서 대입을 진행하면 큰 노력 없이 찾을 수 있습니다. 즉, 마지막 방정식은 \\(x_3 = 2\\)임을 알려줍니다. 이 값을 두 번째 방정식에 대입하면 \\(x_2 = 0\\)이 됩니다. 마지막으로, 이 값을 다시 첫 번째 방정식에 대입하면 \\(x_1 = 1\\)이 됩니다."
  },
  {
    "objectID": "Gaussian_Elimination.html#예제-2-finding-pivots",
    "href": "Gaussian_Elimination.html#예제-2-finding-pivots",
    "title": "가우스 소거법(Gaussian Elimination)",
    "section": "예제 2: Finding pivots",
    "text": "예제 2: Finding pivots\n보시다시피, 마지막 예제의 코드는 배율을 계산하기 위해 나눈 배열의 항목 중 하나라도 0이 나타나면 실패합니다. 이러한 중요한 항목을 피벗이라고 하며, 행렬에서 해당 항목의 위치를 피벗 위치라고 합니다. 정의상 피벗은 0이 아니어야 합니다. 제거 단계에서 피벗 위치에 0이 발생하면 행의 순서를 바꿔서 0이 아닌 항목을 피벗 위치로 옮길 수 있습니다. 무작위 배열에서 작동하는 코드를 작성하기 전에 먼저 특정 배열에 대해 이 방법을 시도해 보겠습니다.\n\\[\n\\begin{matrix}\nx_1 - x_2 + x_3 & = & 3\\\\\n2x_1 - 2x_2 + 4x_3 & = & 8\\\\\n3x_1 \\quad\\quad -9x_3 & = & 0\n\\end{matrix}\n\\]\n\nG=np.array([[1,-1,1,3],[2,-2,4,8],[3,0,-9,0]])\nprint(G)\n\n\nG1 = row_add(G,0,1,-2)\nG2 = row_add(G1,0,2,-3)\nprint(G2)\n\n이제 중간 피벗 위치에 0이 있습니다. 제거를 계속하기 위해 중간 방정식과 마지막 방정식을 바꿀 수 있습니다.\n\nG3 = row_swap(G2,1,2)\nG4 = row_scale(G3,1,1./3)\nG5 = row_scale(G4,2,1./2)\nprint(G5)\n\n시스템을 익숙한 방정식 집합으로 다시 작성합니다.\n\\[\n\\begin{matrix}\nx_1 - x_2 + x_3 & = & 3\\\\\nx_2 - 4x_3 & = & -3\\\\\nx_3 & = & 1\n\\end{matrix}\n\\]\n역치환을 적용하면 \\(x_2 = 1\\)과 \\(x_1=3\\)이 됩니다.\n행을 바꾸는 것은 정리의 문제로만 필요하다는 점에 주목할 필요가 있습니다. 다음은 제거를 수행하여 동일한 시스템으로 끝낼 수 있는 다른 방법입니다.\n\nG3_alternative = row_scale(G2,1,1./2)\nG4_alternative = row_scale(G3_alternative,2,1./3)\nprint(G4_alternative)\n\n생성된 배열은 방정식의 순서는 물론 다르지만 동일한 단순화된 시스템을 나타냅니다.\n\\[\n\\begin{matrix}\nx_1 - x_2 + x_3 & = & 3\\\\\nx_3 & = & 1 \\\\\nx_2 - 4x_3 & = & -3\n\\end{matrix}\n\\]"
  },
  {
    "objectID": "Linear_Systems.html",
    "href": "Linear_Systems.html",
    "title": "연립 선형 방정식과 해집합",
    "section": "",
    "text": "선형 방정식을 살펴보고 그 해를 구하는 방법 소개합니다."
  },
  {
    "objectID": "Linear_Systems.html#선형-연립방정식system-of-linear-equations-혹은-선형계linear-system",
    "href": "Linear_Systems.html#선형-연립방정식system-of-linear-equations-혹은-선형계linear-system",
    "title": "연립 선형 방정식과 해집합",
    "section": "선형 연립방정식(system of linear equations, 혹은 선형계(linear system))",
    "text": "선형 연립방정식(system of linear equations, 혹은 선형계(linear system))\n미지수 \\(x_1\\), \\(x_2\\), \\(\\cdots\\), \\(x_n\\)에 대해서 다음과 같은 1차식으로 작성된 방정식을 선형방정식(linear equation)이라고 합니다.\n\\[\n\\begin{split}\n\\begin{matrix}\na_1 x_1 + a_2 x_2 + \\cdots + a_n x_n = b\n\\end{matrix}\n\\end{split}\n\\]\n미지수 \\(x_1\\), \\(x_2\\), \\(x_3\\), … \\(x_n\\)이 있는 \\(m\\)개의 연립 선형방정식은 다음과 같은 형식 표현할 수 있습니다.\n\\[\n\\begin{split}\n\\begin{matrix}\na_{11}x_1 + a_{12}x_2 + \\hspace{0.5cm} ... \\hspace{0.5cm} + a_{1n}x_n & = & b_1 \\\\\na_{21}x_1 + a_{22}x_2 + \\hspace{0.5cm} ... \\hspace{0.5cm} + a_{2n}x_n & = & b_2 \\\\\n\\vdots \\hspace{1.2cm} \\vdots \\hspace{3cm} \\vdots \\hspace{0.5cm}  & = & \\vdots \\\\\na_{m1}x_1 + a_{m2}x_2 + \\hspace{0.5cm} ... \\hspace{0.5cm} +  a_{mn}x_n & = & b_m \\\\\n\\end{matrix}\n\\end{split}\n\\]\n연립 선형방정식의 해는 모든 방정식을 동시에 만족하는 미지수의 집합 입니다. 이런 미지수의 값 혹은 해를 모아둔 집합을 해집합이라고 합니다. 해를 갖지 않는 연립 선형방정식은 해가 없다(inconsistent)라고 하며, 적어도 하나의 해가 존재하면 모순이 없다(consistent)라고 합니다.\n두 개의 방정식과 두 개의 미지수가 있는 연립 선형방정식은 \\(x_1x_2\\) 좌표 평면에서 각 방정식을 만족하는 점의 집합을 쉽게 그래프로 그릴 수 있습니다. 연립 선형방정식의 해집합을 시각적으로 확인하기 위해서 간단한 그래프를 작성해보도록 하겠습니다."
  },
  {
    "objectID": "Linear_Systems.html#예제1-unique-solution",
    "href": "Linear_Systems.html#예제1-unique-solution",
    "title": "연립 선형 방정식과 해집합",
    "section": "예제1: unique solution",
    "text": "예제1: unique solution\n\\[\n\\begin{matrix}\nx_1 + x_2 - 2 & = & 0 \\\\\nx_1 - x_2 -1 & = & 0 \\\n\\end{matrix}\n\\]\n각 방정식의 해집합은 선으로 나타낼 수 있으며, 선형 시스템의 해집합은 두 선에 놓인 모든 점으로 나타낼 수 있습니다. 이 경우 선은 한 점에서 교차하며 두 방정식을 모두 만족하는 값은 한 쌍만 존재합니다.\n\n%matplotlib inline\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nx=np.linspace(-5,5,100)\n\nfig, ax = plt.subplots()\nax.plot(x,(2-x))\nax.plot(x,(1+x))\n\nax.text(2,0,'$x_1+x_2 - 2 = 0$')\nax.text(-2,0,'$x_1-x_2 - 1 = 0$')\n\nax.set_xlim(-4,4)\nax.set_ylim(-4,6)\nax.axvline(color='k',linewidth = 1)\nax.axhline(color='k',linewidth = 1)\n\nax.set_xticks(list(range(-4,5)))\nax.set_aspect('equal')\nax.grid(True,ls=':')"
  },
  {
    "objectID": "Linear_Systems.html#예제-2-no-solutions",
    "href": "Linear_Systems.html#예제-2-no-solutions",
    "title": "연립 선형 방정식과 해집합",
    "section": "예제 2: no solutions",
    "text": "예제 2: no solutions\n\\[\n\\begin{matrix}\nx_1 + 3x_2 & = & 5 \\\\\nx_1 + 3x_2 & = & 0 \\\\\n\\end{matrix}\n\\]\n두 방정식을 동시에 만족하는 해는 없습니다.\n\nfig, ax = plt.subplots()\nax.plot(x,(5-x)/3)\nax.plot(x,-x/3)\n\nax.text(1,1.6,'$x_1+3x_2 = 5$')\nax.text(0.3,-1.4,'$x_1+3x_2 = 0$')\n\nax.set_xlim(-4,4)\nax.set_ylim(-2,6)\nax.axvline(color='k',linewidth = 1)\nax.axhline(color='k',linewidth = 1)\n\nax.set_xticks(list(range(-4,5)))\nax.set_aspect('equal')\nax.grid(True,ls=':')"
  },
  {
    "objectID": "Linear_Systems.html#예제-3-infinite-number-of-solutions",
    "href": "Linear_Systems.html#예제-3-infinite-number-of-solutions",
    "title": "연립 선형 방정식과 해집합",
    "section": "예제 3: infinite number of solutions",
    "text": "예제 3: infinite number of solutions\n\\[\n\\begin{matrix}\nx_1 + 3x_2 & = & 5 \\\\\n2x_1 + 6x_2 & = & 10 \\\\\n\\end{matrix}\n\\]\n마지막 예제에서 두 번째 방정식은 첫 번째 방정식의 배수입니다. 두 방정식의 해는 모두 같은 선으로 표시되므로 선의 모든 점이 선형 시스템의 해입니다.\n\nfig, ax = plt.subplots()\nax.plot(x,(5-x)/3)\nax.plot(x,(5-x)/3)\n\nax.text(1,1.6,'$x_1+3x_2 = 5$')\nax.text(-3,1.2,'$2x_1+6x_2 = 10$')\n\nax.set_xlim(-4,4)\nax.set_ylim(-2,6)\nax.axvline(color='k',linewidth = 1)\nax.axhline(color='k',linewidth = 1)\n\nax.set_xticks(list(range(-4,5)))\nax.set_aspect('equal')\nax.grid(True,ls=':')\n\n\n\n\n앞선 세 가지 예는 두 개의 미지수가 있는 연립 선형 방정식의 모든 유형의 해집합을 보여줍니다. 정확히 하나의 해가 있을 수도 있고, 해가 없을 수도 있으며, 해가 무한 할 수도 있습니다. 선형 시스템에 대한 기본적인 사실은 해집합이 이 세 가지 경우 중 하나라는 것입니다."
  }
]