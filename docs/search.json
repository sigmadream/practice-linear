[
  {
    "objectID": "Textbook_Solutions.html",
    "href": "Textbook_Solutions.html",
    "title": "프로그래밍 실습",
    "section": "",
    "text": "def calc(n):\n    sum = 0\n    for i in range(0, n+1):\n        sum += i\n    return sum\n\n\ncalc(10)\n\n55\n\n\n\n\n\n\nimport numpy as np\n\nA = np.array([[1,2,3], [4,5,6], [7,8,9]])\nv = np.array([[1], [2], [3]])\n\nprint(f\"A = {A}\")\nprint(f\"v = {v}\")\n\nA = [[1 2 3]\n [4 5 6]\n [7 8 9]]\nv = [[1]\n [2]\n [3]]\n\n\n\n\n\n\\[\nA =\n\\begin{matrix}\n\\left[\\begin{array}{ccc} 1 & 2 & 3 \\\\ 4 & 5 & 6 \\\\ 7 & 8 & 9 \\end{array}\\right]\n\\end{matrix}\n,\nv =\n\\begin{matrix}\n\\left[\\begin{array}{c} 1 \\\\ 2 \\\\ 3 \\end{array}\\right]\n\\end{matrix}\n,\nw = \\begin{matrix}\n\\left[\\begin{array}{c} 1 & 2 & 3 \\end{array}\\right]\n\\end{matrix}\n,\nB =\n\\begin{matrix}\n\\left[\\begin{array}{cc} 1 & 2 & 3\\\\ 4 & 5 & 6 \\end{array}\\right]\n\\end{matrix}\n\\]\n\nA = np.array([[1,2,3], [4,5,6], [7,8,9]])\nprint(f\"A = {A}\")\nprint(f\"A.shape = {A.shape}\")\n\nv = np.array([[1], [2], [3]])\nprint(f\"v = {v}\")\nprint(f\"v.shape = {v.shape}\")\n\nw = np.array([1, 2, 3])\nprint(f\"w = {w}\")\nprint(f\"w.shape = {w.shape}\")\n\nB = np.array([[1,2,3], [4,5,6]])\nprint(f\"B = {B}\")\nprint(f\"B.shape = {B.shape}\")\n\nA = [[1 2 3]\n [4 5 6]\n [7 8 9]]\nA.shape = (3, 3)\nv = [[1]\n [2]\n [3]]\nv.shape = (3, 1)\nw = [1 2 3]\nw.shape = (3,)\nB = [[1 2 3]\n [4 5 6]]\nB.shape = (2, 3)"
  },
  {
    "objectID": "Textbook_Solutions.html#장",
    "href": "Textbook_Solutions.html#장",
    "title": "프로그래밍 실습",
    "section": "",
    "text": "def calc(n):\n    sum = 0\n    for i in range(0, n+1):\n        sum += i\n    return sum\n\n\ncalc(10)\n\n55\n\n\n\n\n\n\nimport numpy as np\n\nA = np.array([[1,2,3], [4,5,6], [7,8,9]])\nv = np.array([[1], [2], [3]])\n\nprint(f\"A = {A}\")\nprint(f\"v = {v}\")\n\nA = [[1 2 3]\n [4 5 6]\n [7 8 9]]\nv = [[1]\n [2]\n [3]]\n\n\n\n\n\n\\[\nA =\n\\begin{matrix}\n\\left[\\begin{array}{ccc} 1 & 2 & 3 \\\\ 4 & 5 & 6 \\\\ 7 & 8 & 9 \\end{array}\\right]\n\\end{matrix}\n,\nv =\n\\begin{matrix}\n\\left[\\begin{array}{c} 1 \\\\ 2 \\\\ 3 \\end{array}\\right]\n\\end{matrix}\n,\nw = \\begin{matrix}\n\\left[\\begin{array}{c} 1 & 2 & 3 \\end{array}\\right]\n\\end{matrix}\n,\nB =\n\\begin{matrix}\n\\left[\\begin{array}{cc} 1 & 2 & 3\\\\ 4 & 5 & 6 \\end{array}\\right]\n\\end{matrix}\n\\]\n\nA = np.array([[1,2,3], [4,5,6], [7,8,9]])\nprint(f\"A = {A}\")\nprint(f\"A.shape = {A.shape}\")\n\nv = np.array([[1], [2], [3]])\nprint(f\"v = {v}\")\nprint(f\"v.shape = {v.shape}\")\n\nw = np.array([1, 2, 3])\nprint(f\"w = {w}\")\nprint(f\"w.shape = {w.shape}\")\n\nB = np.array([[1,2,3], [4,5,6]])\nprint(f\"B = {B}\")\nprint(f\"B.shape = {B.shape}\")\n\nA = [[1 2 3]\n [4 5 6]\n [7 8 9]]\nA.shape = (3, 3)\nv = [[1]\n [2]\n [3]]\nv.shape = (3, 1)\nw = [1 2 3]\nw.shape = (3,)\nB = [[1 2 3]\n [4 5 6]]\nB.shape = (2, 3)"
  },
  {
    "objectID": "Textbook_Solutions.html#장-1",
    "href": "Textbook_Solutions.html#장-1",
    "title": "프로그래밍 실습",
    "section": "2장",
    "text": "2장\n\n2.1 \\(2 \\times 3\\) 영행렬, 모든 성분이 1인 \\(2 \\times 2\\) 행렬, 모든 성분이 3인 \\(3 \\times 2\\) 행렬, \\(2 \\times 2\\) 단위행렬을 만들어 출력하는 프로그램을 작성하라.\n\na = np.zeros((2,3))\nprint(f\"a = {a}\")\n\nb = np.ones((2,2))\nprint(f\"b = {b}\")\n\nc = np.full((3,2),3)\nprint(f\"c = {c}\")\n\nd = np.eye(2)\nprint(f\"d = {d}\")\n\na = [[0. 0. 0.]\n [0. 0. 0.]]\nb = [[1. 1.]\n [1. 1.]]\nc = [[3 3]\n [3 3]\n [3 3]]\nd = [[1. 0.]\n [0. 1.]]\n\n\n\n\n2.2 가우스-조단 소거법을 수행하는 gauss( )라는 함수를 정의하고, 이 함수를 이용하여 다음 연립선형방정식의 해를 구하라. gauss(A)의 입력으로 주어지는 A는 주어진 연립선형방정 식에 대한 첨가행렬이다.\n\\[\n\\begin{matrix}\n2x_1 + 2x_2 + 4x_3 & = & 18 \\\\\nx_1 + 3x_2 + 2x_3 & = & 13 \\\\\n3x_1 + x_2 + 3x_3 & = & 14 \\\\\n\\end{matrix}\n\\]\n\ndef pprint(msg, A):\n    print(\"---\", msg, \"---\")\n    (n,m) = A.shape\n    for i in range(0, n):\n        line = \"\"\n        for j in range(0, m):\n            line += \"{0:.2f}\".format(A[i,j]) + \"\\t\"\n            if j == n-1:\n                line += \"| \"\n        print(line)\n    print(\"\")\n\n\ndef gauss(A):\n    (n,m) = A.shape\n\n    for i in range(0, min(n,m)):\n        # i번째 열에서 절댓값이 최대인 성분의 행 선택\n        maxEl = abs(A[i,i])\n        maxRow = i\n        for k in range(i+1, n):\n            if abs(A[k,i]) &gt; maxEl:\n                maxEl = abs(A[k,i])\n                maxRow = k\n\n        # 현재 i번째 행과 최댓값을 갖는 행 maxRow의 교환\n        for k in range(i, m):\n            tmp = A[maxRow,k]\n            A[maxRow,k] = A[i,k]\n            A[i,k] = tmp\n\n        # 추축성분을 1로 만들기\n        piv = A[i,i]\n        for k in range(i, m):\n            A[i,k] = A[i,k]/piv\n\n        # 현재 i번째 열의 i번째 행을 제외한 모두 성분을 0으로 만들기\n        for k in range(0, n):\n            if k != i:\n                c = A[k,i]/A[i,i]\n                for j in range(i, m):\n                    if i == j:\n                        A[k,j] = 0\n                    else:\n                        A[k,j] = A[k,j] - c * A[i,j]\n\n        pprint(str(i+1)+\"번째 반복\", A) # 중간 과정 출력\n\n    # Ax=b의 해 반환\n    x = np.zeros(m-1)\n    for i in range(0,m-1):\n        x[i] = A[i,m-1]\n    return x\n\n# 주어진 연립선형방정식에 대한 첨가행렬\nA = np.array([[2., 2., 4., 18.], [1., 3., 2., 13.], [3., 1., 3., 14.]])\n\npprint(\"주어진 문제\", A) # 첨가행렬 출력\nx = gauss(A) # 가우스-조단 소거법 적용\n\n# 출력 생성\n(n,m) = A.shape\nline = \"해:\\t\"\nfor i in range(0, m-1):\n    line += \"{0:.2f}\".format(x[i]) + \"\\t\"\nprint(line)\n\n--- 주어진 문제 ---\n2.00    2.00    4.00    | 18.00 \n1.00    3.00    2.00    | 13.00 \n3.00    1.00    3.00    | 14.00 \n\n--- 1번째 반복 ---\n1.00    0.33    1.00    | 4.67  \n0.00    2.67    1.00    | 8.33  \n0.00    1.33    2.00    | 8.67  \n\n--- 2번째 반복 ---\n1.00    0.00    0.88    | 3.63  \n0.00    1.00    0.38    | 3.12  \n0.00    0.00    1.50    | 4.50  \n\n--- 3번째 반복 ---\n1.00    0.00    0.00    | 1.00  \n0.00    1.00    0.00    | 2.00  \n0.00    0.00    1.00    | 3.00  \n\n해:  1.00    2.00    3.00"
  },
  {
    "objectID": "Textbook_Solutions.html#장-2",
    "href": "Textbook_Solutions.html#장-2",
    "title": "프로그래밍 실습",
    "section": "3장",
    "text": "3장\n\n3.1 다음 벡터 \\(v_1\\) , \\(v_2\\), \\(v_3\\)를 행으로 하는 행렬 A와 열로 하는 행렬 B 를 이들 벡터를 사용하여 만들고, 행렬 \\(C\\) 에 \\(v_3\\)를 열로 추가하여 행렬 \\(D\\)를 만들어라. 또한 행렬 \\(E\\)의 1행 4열의 성분, 2 행 3열의 성분, 1~2 행의 3열에 해당하는 부분행렬, 1~2행의 3~4열에 해당하는 부분행렬, 3행에 해당하는 부분행렬을 출력하라. 마지막으로 행렬 \\(E\\)의 1행 1열의 성분을 -1로 변경하고 행렬 \\(E\\)를 출력하라.\n\nprint(\"벡터의 결합에 의한 행렬 생성\")\nv1 = np.array([1, 2, 3])\nv2 = np.array([4, 5, 6])\nv3 = np.array([7, 8, 9])\n\nA = np.vstack([v1, v2, v3]) # v1, v2, v3를 각각 행으로 하는 행렬 A 생성\nprint(\"A =\", A)\n\nB = np.column_stack([v1, v2, v3]) # v1, v2, v3를 각각 열로 하는 행렬 B 생성\nprint(\"B =\", B)\n\nC = np.array([[1, 2], [3, 4], [5, 6]])\nprint(\"C =\", C)\n\nD = np.column_stack([C, v3]) # 행렬 C에 v3를 열로 추가하여 행렬 D 생성\nprint(\"D =\", D)\n\nprint(\"행렬의 성분 접근\")\nE = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])\n\nprint(\"E[0,3] =\", E[0,3]) # 1행 4열의 성분\nprint(\"E[1,2] =\", E[1,2]) # 2행 3열의 성분\n\nprint(\"E[0:2, 2] =\", E[0:2, 2]) # E의 1~2행의 3열에 해당하는 부분행렬\nprint(\"E[0:2, 2:4] =\", E[0:2, 2:4]) # E의 1~2행의 3~4열에 해당하는 부분행렬\nprint(\"E[2, :] =\", E[2, :]) # E의 3행에 해당하는 부분행렬\n\nprint(\"성분의 변경\")\nprint(\"E =\", E)\n\nprint(\"E[0,0] = \", E[0, 0])\nE[0, 0] = -1 # E의 1행 1열 성분을 -1로 변경\nprint(E)\nprint(\"E[0,0] = \", E[0, 0])\n\n벡터의 결합에 의한 행렬 생성\nA = [[1 2 3]\n [4 5 6]\n [7 8 9]]\nB = [[1 4 7]\n [2 5 8]\n [3 6 9]]\nC = [[1 2]\n [3 4]\n [5 6]]\nD = [[1 2 7]\n [3 4 8]\n [5 6 9]]\n행렬의 성분 접근\nE[0,3] = 4\nE[1,2] = 7\nE[0:2, 2] = [3 7]\nE[0:2, 2:4] = [[3 4]\n [7 8]]\nE[2, :] = [ 9 10 11 12]\n성분의 변경\nE = [[ 1  2  3  4]\n [ 5  6  7  8]\n [ 9 10 11 12]]\nE[0,0] =  1\n[[-1  2  3  4]\n [ 5  6  7  8]\n [ 9 10 11 12]]\nE[0,0] =  -1\n\n\n\n\n3.2 다음과 같은 행렬과 벡터를 이용하여 \\(A + B\\), \\(A - B\\), \\(3A\\), \\(2v\\), \\(AB\\), \\(AC\\), \\(Av\\), \\(A^2\\), \\(A^3\\), A 와 B 의 대응 성분별 곱셈 \\(A*B\\), A와 B의 대응 성분별 나눗셈 \\(A/B\\), 성분별 거듭제곱 \\(A**2\\), \\(A^T\\) , \\(v^T\\) , 대각행렬 \\(diag(1, 2, 3)\\)의 생성, \\(D_{11}\\), \\(D_{12}\\), \\(D_{21}\\), \\(D_{22}\\)를 사용한 블록행렬 \\(D\\)의 생성 연산을 수행하고 결과를 출력하는 프로그램을 작성하라.\n\nA = np.array([[1., 2.], [3., 4.]])\nB = np.array([[2., 2.], [1., 3.]])\nC = np.array([[4., 5., 6.], [7., 8., 9.]])\nv = np.array([[10.], [20.]])\n\npprint(\"A+B\", A+B) # 행렬의 합 A+B\npprint(\"A-B\", A-B) # 행렬의 차 A-B\n\npprint(\"3*A \", 3*A) # 행렬의 스칼라배 3A\npprint(\"2*v \", 2*v) # 벡터의 스칼라배 2v\n\npprint(\"matmul(A,B)\", np.matmul(A,B)) # 행렬의 곱 AB\npprint(\"matmul(A,C)\", np.matmul(A,C)) # 행렬의 곱 AC\npprint(\"A*v\", A*v) # 행렬과 벡터의 곱 Av\n\npprint(\"matrix_power(A, 2)\", np.linalg.matrix_power(A, 2)) # 행렬의 거듭제곱 A2\npprint(\"matrix_power(A, 3)\", np.linalg.matrix_power(A, 3)) # 행렬의 거듭제곱 A3\n\npprint(\"A*B\", A*B) # 행렬의 성분별 곱셈 A*B\npprint(\"A/B\", A/B) # 행렬의 성분별 나눗셈 A/B\npprint(\"A**2 == A*A\", A**2) # 행렬의 성분별 거듭제곱 A**2\n\npprint(\"A.T\", A.T) # 행렬의 전치 AT\npprint(\"v.T\", v.T) # 벡터의 전치 vT\n\nM = np.diag([1, 2, 3]) # 대각행렬 diag(1,2,3) 생성\npprint(\"diag(1,2,3) =\", M)\n\nD11 = np.array([[1, 2], [3, 4]])\nD12 = np.array([[5], [6]])\nD21 = np.array([[7, 7]])\nD22 = np.array([[8]])\nD = np.block([[D11, D12], [D21, D22]]) # 블록행렬 D 생성\npprint(\"block matrix\", D)\n\n--- A+B ---\n3.00    4.00    \n4.00    7.00    \n\n--- A-B ---\n-1.00   0.00    \n2.00    1.00    \n\n--- 3*A  ---\n3.00    6.00    \n9.00    12.00   \n\n--- 2*v  ---\n20.00   \n40.00   \n\n--- matmul(A,B) ---\n4.00    8.00    \n10.00   18.00   \n\n--- matmul(A,C) ---\n18.00   21.00   24.00   \n40.00   47.00   54.00   \n\n--- A*v ---\n10.00   20.00   \n60.00   80.00   \n\n--- matrix_power(A, 2) ---\n7.00    10.00   \n15.00   22.00   \n\n--- matrix_power(A, 3) ---\n37.00   54.00   \n81.00   118.00  \n\n--- A*B ---\n2.00    4.00    \n3.00    12.00   \n\n--- A/B ---\n0.50    1.00    \n3.00    1.33    \n\n--- A**2 == A*A ---\n1.00    4.00    \n9.00    16.00   \n\n--- A.T ---\n1.00    3.00    \n2.00    4.00    \n\n--- v.T ---\n10.00   20.00   \n\n--- diag(1,2,3) = ---\n1.00    0.00    0.00    \n0.00    2.00    0.00    \n0.00    0.00    3.00    \n\n--- block matrix ---\n1.00    2.00    5.00    \n3.00    4.00    6.00    \n7.00    7.00    8.00"
  },
  {
    "objectID": "Textbook_Solutions.html#장-3",
    "href": "Textbook_Solutions.html#장-3",
    "title": "프로그래밍 실습",
    "section": "4장",
    "text": "4장\n\n4.1 다음 행렬 A의 역행렬을 구한 다음, 행렬 A와 구한 역행렬의 곱이 단위행렬 I인지 확인하라. 그다음 난수로 3x3 행렬 B를 만들고 그 역행렬을 구한 후，B와 B 의 역행렬을 곱하여 결과를 출력하라. 또한 다음 행렬 C와 D에 대한 행렬방정식 Cx= D의 해를 역행렬을 이용하여 구한 다음, 해가 맞는지 확인하라.\n\nA = np.array([[1., 2.], [3., 4.]])\npprint(\"A\", A)\n\nAinv1 = np.linalg.matrix_power(A, -1) # matrix_power( )를 사용한 역행렬 A-1 계산\npprint(\"linalg.matrix_power(A, -1) =&gt; Ainv1\", Ainv1)\n\nAinv2 = np.linalg.inv(A) # inv( )를 사용한 역행렬 A-1 계산\npprint(\"np.linalg.inv(A) =&gt; Ainv2\", Ainv2)\n\npprint(\"A*Ainv1\", np.matmul(A, Ainv1)) # 행렬 A와 역행렬 A-1의 곱\npprint(\"A*Ainv2\", np.matmul(A, Ainv2)) # 행렬 A와 역행렬 A-1의 곱\n\nB = np.random.rand(3,3) # 난수를 이용한 3x3 행렬 B 생성\npprint(\"B =\", B)\nBinv = np.linalg.inv(B) # 역행렬 B-1 계산\npprint(\"Binv =\", Binv)\npprint(\"B*Binv =\", np.matmul(B, Binv)) # 행렬 B와 역행렬 B-1의 곱\n\n# CX = D의 해 계산\nC = np.array([[5, 3, 2, 1], [6, 2, 4, 5], [7, 4, 1, 3], [4, 3, 5, 2]])\nD = np.array([[4], [2], [5], [1]])\nx = np.matmul(np.linalg.inv(C), D)\npprint(\"x\", x) # 해 x 출력\npprint(\"C*x\", np.matmul(C, x)) # C*x의 결과가 D와 같은지 확인\n\n--- A ---\n1.00    2.00    \n3.00    4.00    \n\n--- linalg.matrix_power(A, -1) =&gt; Ainv1 ---\n-2.00   1.00    \n1.50    -0.50   \n\n--- np.linalg.inv(A) =&gt; Ainv2 ---\n-2.00   1.00    \n1.50    -0.50   \n\n--- A*Ainv1 ---\n1.00    0.00    \n0.00    1.00    \n\n--- A*Ainv2 ---\n1.00    0.00    \n0.00    1.00    \n\n--- B = ---\n0.29    0.40    0.50    \n0.55    0.49    0.21    \n0.89    0.29    0.99    \n\n--- Binv = ---\n-2.66   1.57    1.01    \n2.22    1.00    -1.32   \n1.73    -1.71   0.50    \n\n--- B*Binv = ---\n1.00    -0.00   0.00    \n0.00    1.00    -0.00   \n0.00    -0.00   1.00    \n\n--- x ---\n1.31    \n-0.38   \n-0.31   \n-0.77   \n\n--- C*x ---\n4.00    \n2.00    \n5.00    \n1.00    \n\n\n\n\n\n4.2 임의의 크기의 정방행렬 A 를 LU 분해하는 함수 LU(A)를 사용하여 Ax = b의 해를 구하는 프로그램을 작성하라. [프로그래밍 실습 문제 4-1]의 연립선형방정식을 행렬방정식 Ax = b로 간주하고, 작성한 함수로 계수행렬 A 를 LU 분해하여 이 연립선형방정식의 해를 구하라.\n\n#LU 분해 함수\ndef LU(A):\n    (n,m) = A.shape\n    L = np.zeros((n,n)) # 행렬 L 초기화\n    U = np.zeros((n,n)) # 행렬 U 초기화\n    \n    # 행렬 L과 U 계산\n    for i in range(0, n):\n        for j in range(i, n):\n            U[i, j] = A[i, j]\n            for k in range(0, i):\n                U[i, j] = U[i, j] - L[i, k]*U[k, j]\n        L[i,i] = 1\n        if i &lt; n-1:\n            p = i + 1\n            for j in range(0,p):\n                L[p, j] = A[p, j]\n                for k in range(0, j):\n                    L[p, j] = L[p, j] - L[p, k]*U[k, j]\n                    L[p,j] = L[p,j]/U[j,j]\n    return L, U\n\n# LU 분해를 이용한 Ax=b의 해 구하기\ndef LU_solver(A, b):\n    L, U = LU(A)\n    n = len(L)\n    # Ly=b 계산\n    y = np.zeros((n,1))\n    for i in range(0,n):\n        y[i] = b[i]\n        for k in range(0,i):\n            y[i] -= y[k]*L[i,k]\n    # Ux=y 계산\n    x = np.zeros((n,1))\n    for i in range(n-1, -1, -1):\n        x[i] = y[i]\n        if i &lt; n-1:\n            for k in range(i+1,n):\n                x[i] -= x[k]*U[i,k]\n        x[i] = x[i]/float(U[i,i])\n    return x\n\nA = np.array([[5, 3, 2, 1], [6, 2, 4, 5], [7, 4, 1, 3], [4, 3, 5, 2]])\nb = np.array([[4], [2], [5], [1]])\n\n# 행렬 A의 LU 분해\nL, U = LU(A)\npprint(\"A\", A)\npprint(\"L\", L)\npprint(\"U\", U)\n\n# LU 분해를 이용한 Ax=b의 해 구하기\nx = LU_solver(A,b)\npprint(\"x\", x)\n\n--- A ---\n5.00    3.00    2.00    1.00    \n6.00    2.00    4.00    5.00    \n7.00    4.00    1.00    3.00    \n4.00    3.00    5.00    2.00    \n\n--- L ---\n1.00    0.00    0.00    0.00    \n6.00    1.00    0.00    0.00    \n7.00    1.06    1.00    0.00    \n4.00    0.56    -1.15   1.00    \n\n--- U ---\n5.00    3.00    2.00    1.00    \n0.00    -16.00  -8.00   -1.00   \n0.00    0.00    -4.50   -2.94   \n0.00    0.00    0.00    -4.81   \n\n--- x ---\n-0.06   \n1.54    \n-0.38   \n0.46"
  },
  {
    "objectID": "Textbook_Solutions.html#임의의-크기의-정방행렬에-대한-행렬식을-계산하는-프로그램을-작성하고-이를-이용하여-다음-행렬-a의-행렬식을-구하라.",
    "href": "Textbook_Solutions.html#임의의-크기의-정방행렬에-대한-행렬식을-계산하는-프로그램을-작성하고-이를-이용하여-다음-행렬-a의-행렬식을-구하라.",
    "title": "프로그래밍 실습",
    "section": "5.1 임의의 크기의 정방행렬에 대한 행렬식을 계산하는 프로그램을 작성하고, 이를 이용하여 다음 행렬 A의 행렬식을 구하라.",
    "text": "5.1 임의의 크기의 정방행렬에 대한 행렬식을 계산하는 프로그램을 작성하고, 이를 이용하여 다음 행렬 A의 행렬식을 구하라.\n\nimport numpy as np\n\ndef get_minor_matrix(A,i,j): # 행렬 A의 i행과 j열을 제거하고 만든 행렬 생성\n    n = len(A)\n    M = np.zeros((n-1, n-1))\n    for a in range(0,n-1):\n        k = a if (a &lt; i) else a+1\n        for b in range(0, n-1):\n            l = b if (b &lt; j) else b+1\n            M[a, b] = A[k, l]\n    return M\n\ndef determinant(M): # 행렬식 계산\n    if len(M) == 2: # 2x2 행렬의 행렬식 계산\n        return M[0,0]*M[1,1]-M[0,1]*M[1,0]\n\n    detVal = 0\n    for c in range(len(M)):\n        detVal += ((-1)**c)*M[0,c]*determinant(get_minor_matrix(M,0,c))\n    return detVal\n\nA = np.array([[-4, 0, 2, -1, 0], [1, 3, -3, -1, 4], [2, 0, 1, 3, 0],\n              [-2, 1, -3, -1, 5], [1, -5, 1, 0, 5]])\nprint(\"A = \", A)\nprint(\"det(A) = \", determinant(A))\n\nA =  [[-4  0  2 -1  0]\n [ 1  3 -3 -1  4]\n [ 2  0  1  3  0]\n [-2  1 -3 -1  5]\n [ 1 -5  1  0  5]]\ndet(A) =  -997.0"
  },
  {
    "objectID": "Textbook_Solutions.html#수반행렬을-이용한-역행렬-계산-방법을-구현하여-다음-행렬-a의-역행렬을-계산하라.",
    "href": "Textbook_Solutions.html#수반행렬을-이용한-역행렬-계산-방법을-구현하여-다음-행렬-a의-역행렬을-계산하라.",
    "title": "프로그래밍 실습",
    "section": "5.2 수반행렬을 이용한 역행렬 계산 방법을 구현하여, 다음 행렬 A의 역행렬을 계산하라.",
    "text": "5.2 수반행렬을 이용한 역행렬 계산 방법을 구현하여, 다음 행렬 A의 역행렬을 계산하라.\n\nimport numpy as np\n\ndef cofactor(A, i, j): # 여인수 계산\n    (n,m) = A.shape\n    M = np.zeros((n-1, m-1))\n    for a in range(0, n-1):\n        k = a if (a &lt; i) else a+1\n        for b in range(0, m-1):\n            l = b if (b &lt; j) else b+1\n            M[a,b] = A[k, l]\n\n    return (-1)**(i+j)*np.linalg.det(M)\n\ndef inverse_by_adjoint_matrix(A): # 수반행렬을 이용한 A의 역행렬 계산\n    detA = np.linalg.det(A) # A의 행렬식 계산\n    (n,m) = A.shape\n    adjA = np.zeros((n, m))\n\n    for i in range(0,n): # 수반행렬 생성\n        for j in range(0, m):\n            adjA[j,i] = cofactor(A, i, j)\n    if detA != 0.0:\n        return (1./detA) * adjA\n    else:\n        return 0\n    \nA = np.array([[-4, 0, 2, -1, 0], [1, 3, -3, -1, 4], [2, 0, 1, 3, 0],\n              [-2, 1, -3, -1, 5], [1, -5, 1, 0, 5]])\nprint(\"A = \", A)\n\nAinv = inverse_by_adjoint_matrix(A)\nprint(\"A inverse = \", Ainv)\n\nA =  [[-4  0  2 -1  0]\n [ 1  3 -3 -1  4]\n [ 2  0  1  3  0]\n [-2  1 -3 -1  5]\n [ 1 -5  1  0  5]]\nA inverse =  [[-0.07321966  0.2106319  -0.03610832 -0.24573721  0.0772317 ]\n [ 0.16950853  0.26579739  0.09729188 -0.14343029 -0.06920762]\n [ 0.32397192  0.30090271  0.09127382 -0.35105316  0.11033099]\n [-0.05917753 -0.24072217  0.32698094  0.28084253 -0.08826479]\n [ 0.11935807  0.16349047  0.08625878 -0.02407222  0.09327984]]"
  },
  {
    "objectID": "Textbook_Solutions.html#크래머-공식을-이용하여-연립선형방정식의-해를-구하는-방법을-구현하여-다음-연립선형방정식의-해를-구하라.",
    "href": "Textbook_Solutions.html#크래머-공식을-이용하여-연립선형방정식의-해를-구하는-방법을-구현하여-다음-연립선형방정식의-해를-구하라.",
    "title": "프로그래밍 실습",
    "section": "5.3 크래머 공식을 이용하여 연립선형방정식의 해를 구하는 방법을 구현하여, 다음 연립선형방정식의 해를 구하라.",
    "text": "5.3 크래머 공식을 이용하여 연립선형방정식의 해를 구하는 방법을 구현하여, 다음 연립선형방정식의 해를 구하라.\n\nimport numpy as np\n\ndef solve_by_cramer(A, B): # 크래머 공식을 이용한 연립선형방정식 AX=B의 풀이\n    X = np.zeros(len(B))\n    C = np.copy(A)\n    for i in range(0, len(B)):\n        for j in range(0, len(B)):\n            C[j,i] = B[j].item()\n            if i&gt;0:\n                C[j,i-1] = A[j,i-1]\n        X[i] = np.linalg.det(C)/np.linalg.det(A)\n    return X\n\n# AX = B의 해\nA = np.array([[2,-1,5,1], [3,2,2,-6], [1,3,3,-1], [5,-2,-3,3]])\nB = np.array([[-3], [-32], [-47], [49]])\nX = solve_by_cramer(A, B)\nprint(\"A = \", A)\nprint(\"B = \", B)\nprint(\"X = \", X)\n\nA =  [[ 2 -1  5  1]\n [ 3  2  2 -6]\n [ 1  3  3 -1]\n [ 5 -2 -3  3]]\nB =  [[ -3]\n [-32]\n [-47]\n [ 49]]\nX =  [  2. -12.  -4.   1.]"
  },
  {
    "objectID": "Textbook_Solutions.html#다음과-같이-방향과-크기가-주어진-r2-공간의-두-힘을-결합한-힘의-방향과-크기를-구하라.",
    "href": "Textbook_Solutions.html#다음과-같이-방향과-크기가-주어진-r2-공간의-두-힘을-결합한-힘의-방향과-크기를-구하라.",
    "title": "프로그래밍 실습",
    "section": "6.1 다음과 같이 방향과 크기가 주어진 \\(R^2\\) 공간의 두 힘을 결합한 힘의 방향과 크기를 구하라.",
    "text": "6.1 다음과 같이 방향과 크기가 주어진 \\(R^2\\) 공간의 두 힘을 결합한 힘의 방향과 크기를 구하라.\n\nimport numpy as np\n\ndef get_vector(mag, deg): # 주어진 크기와 방향에 대응하는 벡터 생성\n    vec = np.zeros(2)\n    vec[0] = mag*np.cos(deg*2*np.pi/360)\n    vec[1] = mag*np.sin(deg*2*np.pi/360)\n    return vec\n\ndef get_mag_deg(vec): # 벡터의 크기와 방향 계산\n    mag = np.sqrt(vec[0]*vec[0]+vec[1]*vec[1])\n    deg = np.arctan(vec[1]/vec[0]) * 360/(2*np.pi)\n    return mag, deg\n\nF1 = get_vector(100, 30) # 크기 100N, 방향 30˚인 힘\nF2 = get_vector(120, 60) # 크기 120N, 방향 60˚인 힘\nFsum = F1 + F2\nmagn, angle = get_mag_deg(Fsum)\nprint(\"결합한 힘의 크기 : \", magn)\nprint(\"결합한 힘의 방향 : \", angle)\n\n결합한 힘의 크기 :  212.56671821060448\n결합한 힘의 방향 :  46.395392948206855"
  },
  {
    "objectID": "Textbook_Solutions.html#다음-벡터-a-b-의-사잇각과-a-의-b-위로의-정사영을-구하라.",
    "href": "Textbook_Solutions.html#다음-벡터-a-b-의-사잇각과-a-의-b-위로의-정사영을-구하라.",
    "title": "프로그래밍 실습",
    "section": "6.2 다음 벡터 A, B 의 사잇각과, A 의 B 위로의 정사영을 구하라.",
    "text": "6.2 다음 벡터 A, B 의 사잇각과, A 의 B 위로의 정사영을 구하라.\n\nimport numpy as np\n\ndef angle_to_vectors(v, w): # 두 벡터의 사잇각 계산\n    vnorm = np.linalg.norm(v)\n    wnorm = np.linalg.norm(w)\n    vwdot = np.dot(v.T, w)\n    angle = np.arctan(vwdot/(vnorm*wnorm))*360/np.pi\n    return angle\n\ndef orth_proj(u, x): # 정사영 계산\n    xu_dot = np.dot(x.T, u)\n    uu_dot = np.dot(u.T, u)\n    projux = (xu_dot/uu_dot)*u\n    return projux\n\nA = np.array([[2], [4], [1]])\nB = np.array([[1], [-1], [3]])\nangle = angle_to_vectors(A, B)\nprojAB = orth_proj(B, A)\nprint(\"A와 B의 사잇각 : \", angle)\nprint(\"A의 B 위로의 정사영 : \\n\", projAB)\n\nA와 B의 사잇각 :  [[7.52871961]]\nA의 B 위로의 정사영 : \n [[ 0.09090909]\n [-0.09090909]\n [ 0.27272727]]"
  },
  {
    "objectID": "Textbook_Solutions.html#다음의-네-점-a-b-c-d-에-대해-선분-overlineab-overlineac-overlinead-로-만들어지는-평행육면체의-부피를-구하라.",
    "href": "Textbook_Solutions.html#다음의-네-점-a-b-c-d-에-대해-선분-overlineab-overlineac-overlinead-로-만들어지는-평행육면체의-부피를-구하라.",
    "title": "프로그래밍 실습",
    "section": "6.3 다음의 네 점 A, B, C, D 에 대해, 선분 \\(\\overline{AB}\\), \\(\\overline{AC}\\), \\(\\overline{AD}\\) 로 만들어지는 평행육면체의 부피를 구하라.",
    "text": "6.3 다음의 네 점 A, B, C, D 에 대해, 선분 \\(\\overline{AB}\\), \\(\\overline{AC}\\), \\(\\overline{AD}\\) 로 만들어지는 평행육면체의 부피를 구하라.\n\nimport numpy as np\n\ndef triple_product(u, v, w): # 스칼라 삼중적 u ․ (v × w) 계산\n    M = np.zeros((3,3))\n    M[0:] = u\n    M[1:] = v\n    M[2:] = w\n    val = np.linalg.det(M) # 행벡터가 u, v, w인 행렬의 행렬식 계산\n    return val\n\nA = np.array([1, 2, 3])\nB = np.array([0, 5, 2])\nC = np.array([2, 2, 4])\nD = np.array([2, 4, 1])\nu = B-A\nv = C-A\nw = D-A\nval = triple_product(u, v, w)\nprint(\"부피 : \", np.absolute(val))\n\n부피 :  9.000000000000002"
  },
  {
    "objectID": "Textbook_Solutions.html#다음과-같은-점-a-를-포함하고-법선벡터가-w-인-평면과-점-p-사이의-거리를-계산하라a234-w123-p012",
    "href": "Textbook_Solutions.html#다음과-같은-점-a-를-포함하고-법선벡터가-w-인-평면과-점-p-사이의-거리를-계산하라a234-w123-p012",
    "title": "프로그래밍 실습",
    "section": "6.4 다음과 같은 점 A 를 포함하고 법선벡터가 W 인 평면과 점 P 사이의 거리를 계산하라(A=(2,3,4), W=(1,2,3), P=(0,1,2))",
    "text": "6.4 다음과 같은 점 A 를 포함하고 법선벡터가 W 인 평면과 점 P 사이의 거리를 계산하라(A=(2,3,4), W=(1,2,3), P=(0,1,2))\n\nimport numpy as np\n\ndef dist_pt_to_pl(A, W, P): # 거리 계산\n    num = np.dot((P-A).T, W)\n    deno = np.linalg.norm(W)\n    val = np.absolute(num)/deno\n    return val\n\nA = np.array([2, 3, 4])\nW = np.array([1, 2, 3])\nP = np.array([0, 1, 2])\nprint(\"거리 : \", dist_pt_to_pl(A, W, P))\n\n거리 :  3.2071349029490928"
  },
  {
    "objectID": "A1_Numpy_Basic.html",
    "href": "A1_Numpy_Basic.html",
    "title": "Introduction to NumPy",
    "section": "",
    "text": "넘파이Numpy는 파이썬으로 수치 계산을 하기 위한 패키지 혹은 라이브러리입니다. 다차원 배열을 효율적으로 구현한 넘파이 배열과 배여 간 빠른 연산을 할 수 있는 연산을 제공합니다. 다차원 배열을 사용해서 선형대수에서 다루는 대규모 행렬등을 활용하여 계산합니다. 따라서 넘파이는 선형 대수학 및 기타 과학 컴퓨팅 영역에 필요한 계산을 수행하는 데 필수적인 파이썬(Python) 패키지입니다. 이와 함께 Matplotlib은 다양한 그래프를 생성하기 위한 Python 패키지입니다. 선형 대수학에서 접하게 되는 대부분의 계산에는 넘파이가 사용되지만, 개념을 시각적으로 유용하게 표현하기 위해서만 Matplotlib을 활용하는 것을 권장합니다."
  },
  {
    "objectID": "A1_Numpy_Basic.html#numpy",
    "href": "A1_Numpy_Basic.html#numpy",
    "title": "Introduction to NumPy",
    "section": "NumPy",
    "text": "NumPy\n선형 대수에서 하는 거의 모든 계산은 숫자를 행렬 형태로 다루는 연산이 포함됩니다. 행렬은 행과 열로 구성되어 있으며, 직사각형 혹은 정사각형으로 이루는 숫자 혹은 문자의 집합입니다.\n\\[\n\\begin{matrix}\n\\left[ \\begin{array}{rrrr} 1 & 2 & 3 & 4 \\\\ -5 & -6 & -7 & -8 \\end{array}\\right]\n\\end{matrix}\n\\]\n행렬은 파이썬의 리스트(List) 객체를 사용하여 표현할 수도 있지만, 넘파이 배열 객체를 사용하겠습니다. 넘파이는 행렬을 표현하는 강력한 방법을 제공합니다. 행렬을 효율적으로 처리하기 위한 많은 내장 도구도 제공합니다. 수학 모듈과 마찬가지로, NumPy를 사용하기 전에 해당 패키지를 사용할 수 있도록 준비되어야 하니다.\n넘파이 패키지를 가져오는 방법으로 import numpy as np과 같은 형태의 코드를 사용합니다. 이후 코드에서 넘파이는 np로 축약해서 사용됩니다.\n\n왜 넘파이를 사용하는가?\n\nimport numpy as np\n\nA = np.array([[1, 2, 3, 4],[-5, -6, -7, -8]])\nprint(f\"행렬 A의 형태는 {A.shape}입니다.\")\nprint(f\"행렬 A의 자료형은 {A.dtype}입니다.\")\n\n행렬 A의 형태는 (2, 4)입니다.\n행렬 A의 자료형은 int64입니다.\n\n\n원하는 행렬은 만드는 또 다른 방법은 먼저 하나의 긴 행으로 된 배열을 만든 다음 reshape 함수를 사용하는 것입니다. 대괄호를 추가로 입력하는 것보다 더 편리할 수 있습니다.\n\nB = np.array([1, 2, 3, 4, -5, -6, -7, -8])\nprint(f\"배열 {B}\")\n\nC = B.reshape((2,4))\nprint(f\"배열 B에 reshape 함수를 사용하여 만든 2행 4열 행렬 \\n {C}\")\n\n배열 [ 1  2  3  4 -5 -6 -7 -8]\n배열 B에 reshape 함수를 사용하여 만든 2행 4열 행렬 \n [[ 1  2  3  4]\n [-5 -6 -7 -8]]\n\n\n기존 행렬의 데이터를 유지하면서 수정하고 해야 할 때는 copy 함수를 사용하면 됩니다.\n\nD = np.copy(A)\nprint(D)\n\n[[ 1  2  3  4]\n [-5 -6 -7 -8]]\n\n\n행렬의 개별 항목에 접근하기 위해서는 행과 열을 기반으로 인덱스(index)를 사용하면 됩니다. 다른 언어와 마찬가지로 Python에서도 배열 또는 행렬의 인덱스는 0부터 시작합니다! 즉, 첫 번째 행은 인덱스가 0이고 두 번째 행은 인덱스가 1이라는 뜻입니다. 열도 마찬가지입니다. 0에서 카운트를 시작하는 것은 어렵지 않지만, 프로그래밍을 처음 접하는 사람이라면 해당 부분은 항상 주의해야 합니다.\n\nprint(A[0,2]) # 1행 3열의 원소는 `3`\n\n3\n\n\n인덱스를 사용하면 행렬의 원소에 새로운 값을 수정(정확히는 할당) 할 수 있습니다.\n\nA[0,2] = 8\nprint(A)\n\n[[ 1  2  8  4]\n [-5 -6 -7 -8]]\n\n\n넘파이를 사용하면 파이썬만 사용하는 것에 비해서 적은 수의 코드를 사용할 수 있으며, 빠르게 연계할 수 있습니다. 예를 들어 두 개의 행렬을 더하는 연산을 하기 위해선 파이썬의 리스트를 사용한다고 가정하면 아래와 같이 개별 원소의 합을 별도로 해줘야 합니다.\n\nT = []\nfor a, b in zip(A,D):\n    T.append(a+b)\nprint(T)\n\n[array([ 2,  4, 11,  8]), array([-10, -12, -14, -16])]\n\n\n넘파이는 개별 원소끼리 연산(element-wise)하는 벡터라이제이션(vectorization)을 지원하기 때문에 별도의 반복문을 사용하지 않고도 빠르게 연산할 수 있습니다.\n\nT = A + D\nprint(T)\n\n[[  2   4  11   8]\n [-10 -12 -14 -16]]\n\n\n따라서 가능하면 넘파이 배열을 사용해서 행렬을 생성하는 방법을 다양하게 익혀둬야 합니다.\n파이썬의 리스트를 사용하면 최댓값, 최소값, 총합, 평균 등을 구할 수 있습니다. 따라서 넘파이 배열도 해당 연산이 제공됩니다. 예를 들어 X 행렬의 합을 구해보도록 하겠습니다.\n\nprint(f\"D 행렬은 다음과 같습니다. \\n {D}\")\nprint(f\"D 행렬의 총합은 {D.sum()} 입니다.\")\n\nD 행렬은 다음과 같습니다. \n [[ 1  2  3  4]\n [-5 -6 -7 -8]]\nD 행렬의 총합은 -16 입니다.\n\n\n만약, 각 행의 합계가 필요하다면 덧셈의 방향을 axis 인자로 지정하면 됩니다. axis=0이면 열 방향으로 연산이 진행되고, axis=1이면 행 방향으로 연산이 진행됩니다.\n\nprint(f\"D 행렬은 다음과 같습니다. \\n {D}\")\nprint(f\"D 행렬의 각 열의 합은 {D.sum(axis=0)} 입니다.\")\nprint(f\"D 행렬의 각 행의 합은 {D.sum(axis=1)} 입니다.\")\n\nD 행렬은 다음과 같습니다. \n [[ 1  2  3  4]\n [-5 -6 -7 -8]]\nD 행렬의 각 열의 합은 [-4 -4 -4 -4] 입니다.\nD 행렬의 각 행의 합은 [ 10 -26] 입니다.\n\n\n\n\n정해진 크기의 행렬 생성\n행렬의 데이터 개수를 알고 있을 때 사용할 수 있는 함수들입니다. 행렬의 크기와 원소의 자료형을 알고 있다면 아래 행렬을 생성하는 함수를 활용하세요.예를 들어, 모든 원소의 성분이 \\(0\\)으로 구성된 행렬을 만들어야 할 때, 아래와 같이 zeros 함수를 사용하면 됩니다.\n\n# 모든 원소 성분이 0인 4x4 행렬을 만듭니다.\nZ = np.zeros((4,4))\n\n# 주 대각선의 원소를 2로 수정합니다.\nfor i in range(4):\n    Z[i,i] = 2\n        \nprint(Z)\n\n[[2. 0. 0. 0.]\n [0. 2. 0. 0.]\n [0. 0. 2. 0.]\n [0. 0. 0. 2.]]\n\n\n반면 모든 원소의 값이 \\(1\\)로 되어 있는 행렬은 ones로 생성할 수 있습니다.\n\n# 모든 원소 성분이 1인 4x4 행렬을 만듭니다.\nD1 = np.ones((4,4))\nprint(D1)\n\n# 모든 원소 성분이 정수 1로 되어있는 4x4 행렬을 만듭니다.\nD2 = np.ones((4,4), dtype=int)\nprint(D2)\n\n[[1. 1. 1. 1.]\n [1. 1. 1. 1.]\n [1. 1. 1. 1.]\n [1. 1. 1. 1.]]\n[[1 1 1 1]\n [1 1 1 1]\n [1 1 1 1]\n [1 1 1 1]]\n\n\nempty 함수는 초기화되지 않은 행렬을 생성하는데, 위 두 함수와 달리 원소 값을 초기화하지 않았기 때문에 생성속도가 월등히 빠르다. 하지만, 최기화되지 않았기 때문에 행렬에 어떤 값이 포함될지 예상할 수 없다.\n\n# 모든 원소 성분이 1인 4x4 행렬을 만듭니다.\nD3 = np.empty((6,6))\nprint(D3)\n\n[[0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0.]]\n\n\n선형대수를 학습하는 과정에서 다양한 관찰을 할 필요가 있습니다. 이 때는 다양한 형태의 행렬이 필요합니다. 다양한 선형대수의 특징을 관찰하기 위해서 무작위 행렬을 작성하기 위한 방법이 필요합니다. 넘파이에 포함된 random 모듈의 함수를 사용하면 됩니다. 예를 들어, rand 함수를 사용하여 \\(0\\)과 \\(1\\) 사이의 난수를 사용한 실수를 생성할 수 있습니다.\n\nr = np.random.rand()\nprint(r)\n\n0.334658180736659\n\n\nrand 함수를 실행할 때마다 새로운 난수를 만듭니다. 행렬을 쉽게 만들기 위해서는 rand 함수에 매개변수로 행과 열을 지정하면 됩니다. 행과 열을 지정하기 위해서는 두 개의 매개변수가 필요합니다.\n\nD4 = np.random.rand(3,3)\nprint(D4)\n\n[[0.89757374 0.89818687 0.57359603]\n [0.90339897 0.89786722 0.04970749]\n [0.34844154 0.55234007 0.1282334 ]]\n\n\n행렬의 연산을 관찰하는 과정에서 실수가 아닌 정수로 이루어진 행렬이 필요하다면, randint 함수를 사용하면 됩니다. 정수의 특성상 상한을 정하는 매개변수 1개가 반드시 필요합니다.\n\nprint(np.random.randint(20))\n\n7\n\n\n무작위 배열을 생성하려면 size라는 키워드 인자(keyword arguments)를 사용하여 행과 열의 개수를 지정해야 합니다. 키워드 인수의 사용법은 아래 코드로 확인할 수 있습니다.\n\nD5 = np.random.randint(10,size=(3,3))\nprint(D5)\n\n[[5 0 3]\n [0 8 9]\n [3 0 5]]\n\n\n참고로 파이썬의 함수에서 키워드 인자를 사용하는 경우가 많습니다. 키워드 인자를 사용하면 순서대로 함수 인자를 활용하지 않아도 된다는 점 입니다. 무엇보다 함수를 읽기 쉽다는 점도 한 몫 합니다.\n\nprint(np.random.randint(size=(3,3),high=10,low=1))\n\n[[1 3 7]\n [6 8 1]\n [3 8 9]]\n\n\n또한 random 모듈에는 지정된 목록(List)에서 무작위로 선택된 값을 생성할 수 있는 choice라는 함수가 있습니다. 이 함수는 숫자 목록을 인수로 받아 해당 목록에서 무작위로 선택된 값을 반환합니다.\n\nx = np.random.choice([0,1,3,31])\nprint(x)\n\n3\n\n\n또한 choice 함수를 사용하여 지정된 목록 값으로 구성된 행렬을 생성할 수 있습니다. 행렬은 size 인자를 사용하면 됩니다.\n\nD6 = np.random.choice([0,1,3,31], size = (3,3))\nprint(D6)\n\n[[1 1 3]\n [1 0 0]\n [0 0 1]]\n\n\n\n\n연속된 값을 가진 행렬 생성\n\n# 0에서 10까지 정수 중에서 마지막 값이 포함되지 않은 1차원 배열을 만듭니다.\n# 이 때, 간격은 1씩 증가합니다.\nE1 = np.arange(10)\nprint(E1)\n\n[0 1 2 3 4 5 6 7 8 9]\n\n\n\n# 0에서 100까지 정수 중에서 마지막 값이 포함되지 않은 1차원 배열을 만듭니다.\n# 이 때, 간격은 10씩 증가합니다.\nE2 = np.arange(0,100,10)\nprint(E2)\n\n[ 0 10 20 30 40 50 60 70 80 90]\n\n\n\n# 0에서 10까지 정수 중에서 마지막 값이 포함된 1차원 배열 50개를 만듭니다.\n# 이 때, 간격은 균등합니다.\nE3 = np.linspace(0,10)\nprint(E3)\n\n[ 0.          0.20408163  0.40816327  0.6122449   0.81632653  1.02040816\n  1.2244898   1.42857143  1.63265306  1.83673469  2.04081633  2.24489796\n  2.44897959  2.65306122  2.85714286  3.06122449  3.26530612  3.46938776\n  3.67346939  3.87755102  4.08163265  4.28571429  4.48979592  4.69387755\n  4.89795918  5.10204082  5.30612245  5.51020408  5.71428571  5.91836735\n  6.12244898  6.32653061  6.53061224  6.73469388  6.93877551  7.14285714\n  7.34693878  7.55102041  7.75510204  7.95918367  8.16326531  8.36734694\n  8.57142857  8.7755102   8.97959184  9.18367347  9.3877551   9.59183673\n  9.79591837 10.        ]\n\n\n\n# 0에서 10까지 정수 중에서 마지막 값이 포함된 1차원 배열 5개를 만듭니다.\n# 이 때, 간격은 균등합니다.\nE4 = np.linspace(0,10,5)\nprint(E4)\n\n[ 0.   2.5  5.   7.5 10. ]\n\n\n\n\n행렬 형태 변경\n앞서 확인했던 reshape을 사용하면 배열을 행렬로 손쉽게 변경할 수 있습니다.\n\n# 16개의 원소를 가진 1차원 배열을 만듭니다.\nX = np.arange(16)\nprint(f\"X = {X}\")\n\nX1 = X.reshape(-1,8)\nprint(f\"X1 = {X1}\")\n\nX2 = X.reshape(8,-1)\nprint(f\"X2 = {X2}\")\n\nX3 = X.reshape(2,8)\nprint(f\"X3 = {X3}\")\n\nX4 = X.reshape(8,2)\nprint(f\"X4 = {X4}\")\n\nX = [ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15]\nX1 = [[ 0  1  2  3  4  5  6  7]\n [ 8  9 10 11 12 13 14 15]]\nX2 = [[ 0  1]\n [ 2  3]\n [ 4  5]\n [ 6  7]\n [ 8  9]\n [10 11]\n [12 13]\n [14 15]]\nX3 = [[ 0  1  2  3  4  5  6  7]\n [ 8  9 10 11 12 13 14 15]]\nX4 = [[ 0  1]\n [ 2  3]\n [ 4  5]\n [ 6  7]\n [ 8  9]\n [10 11]\n [12 13]\n [14 15]]\n\n\nreshape을 사용하게 되면 원본 행렬과 데이터를 공유해서 사용하게 되니, 가능하면 copy 함수를 사용해서 별도의 행렬로 복사해서 사용하도록 하세요.\n\nX = np.arange(16)\nprint(f\"X = {X}\")\n\nX1 = X.reshape(-1,8)\nprint(f\"X1 = {X1}\")\n\nX1[0,0] = 100\nprint(f\"X = {X}\")\n\nX = [ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15]\nX1 = [[ 0  1  2  3  4  5  6  7]\n [ 8  9 10 11 12 13 14 15]]\nX = [100   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15]\n\n\n\nX = np.arange(16)\nprint(f\"X = {X}\")\n\nX1_copy = X.reshape(-1,8).copy()\nprint(f\"X1_copy = {X1_copy}\")\n\nX1_copy[0,0] = 100\nprint(f\"X = {X}\")\nprint(f\"X1_copy = {X1_copy}\")\n\nX = [ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15]\nX1_copy = [[ 0  1  2  3  4  5  6  7]\n [ 8  9 10 11 12 13 14 15]]\nX = [ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15]\nX1_copy = [[100   1   2   3   4   5   6   7]\n [  8   9  10  11  12  13  14  15]]\n\n\nrevel 함수는 반대로 행렬을 배열로 변경합니다. 이 함수도 원본과 데이터를 공유하기 때문에 copy 함수를 사용하세요.\n\nX = np.array([[1,2,3],[4,5,6]])\nprint(f\"X = {X}\")\n\nX1 = X.ravel()\nprint(f\"X1 = {X1}\")\n\nX2 = X.ravel().copy()\nprint(f\"X2 = {X2}\")\n\nX = [[1 2 3]\n [4 5 6]]\nX1 = [1 2 3 4 5 6]\nX2 = [1 2 3 4 5 6]\n\n\n\n\n연산\n\nX = np.array([[1,2],[3,4]])\nY = np.array([[5,6],[7,8]])\n\nprint(f\"X+Y = {X+Y}\") # 행렬 덧셈\nprint(f\"X-Y = {X-Y}\") # 행렬 뺄셈\nprint(f\"X*Y = {X*Y}\") # 행렬 곱셈이 아닌 원소별 곱셈\nprint(f\"X/Y = {X/Y}\") # 행렬 나눗셈\nprint(f\"X@Y = {X@Y}\") # 행렬 곱셈\n\nX+Y = [[ 6  8]\n [10 12]]\nX-Y = [[-4 -4]\n [-4 -4]]\nX*Y = [[ 5 12]\n [21 32]]\nX/Y = [[0.2        0.33333333]\n [0.42857143 0.5       ]]\nX@Y = [[19 22]\n [43 50]]"
  },
  {
    "objectID": "A1_Numpy_Basic.html#matplotlib",
    "href": "A1_Numpy_Basic.html#matplotlib",
    "title": "Introduction to NumPy",
    "section": "Matplotlib",
    "text": "Matplotlib\nMatplotlib은 다양한 플로팅 기능과 생성된 그림을 정밀하게 사용자 정의할 수 있는 다양한 옵션을 제공합니다. 이 문서는 필요한 코드에 대한 몇 가지 세부 사항을 제공하지만 데이터 구조를 엄격하게 설명하거나 라이브러리 내에서 사용할 수 있는 다양한 옵션에 대해 논의하지는 않습니다.\n\nExample 1\n첫 번째 그림에서는 \\((x,y)\\) 좌표가 있는 네 점의 간단한 플롯을 만들겠습니다. 좌표 목록은 NumPy 배열에 저장됩니다.\n\nx = np.array([1, 2.5, 3, 5.8])\ny = np.array([2, 1.2, 1.1, 0.8])\n\n다음 코드에는 그래프를 생성하는 데 필요한 최소한의 지침이 포함되어 있습니다.\n\nimport matplotlib.pyplot as plt\n\n%config InlineBackend.figure_format = 'retina'\n\nfig, ax = plt.subplots()\nax.plot(x,y);\n\n\n\n\nsubplots 메서드는 fig과 ax이라는 두 개의 Matplotlib 객체를 생성합니다. fig은 Matplotlib의 기본 객체입니다. ax 객체는 fig 안에 포함되어 있으며, 우리가 가장 많이 상호작용할 객체입니다. ax 객체의 plot 메서드는 실제로 좌표 집합을 ax에 그림을 그리는 함수입니다.\nMatplotlib 메서드(그리고 실제로 다른 많은 파이썬 라이브러리의 메서드)는 최소한의 인수를 제공하여 생성되는 기본 기능을 가지고 있지만, 이 기본 기능을 변경하는 추가 인수를 제공할 수 있는 것이 일반적입니다. 이 예제에서는 plot 메서드에 선택적 인수 b+를 제공하여 데이터 좌표를 연결하는 선 대신 파란색 + 기호가 있는 플롯을 생성할 수 있습니다.\n\nfig, ax = plt.subplots()\nax.plot(x,y,'b+');\n\n\n\n\n데이터 요소를 플로팅하는 데 관심이 있는 경우 또 다른 대안은 동일한 구문을 사용할 수 있는 scatter 메서드입니다.\n\nfig, ax = plt.subplots()\nax.scatter(x,y);\n\n\n\n\n다음은 이러한 플롯에서 사용할 수 있는 여러 옵션 중 일부를 구성하는 방법을 보여드리겠습니다. 플롯은 실제로 축 객체에서 구성되므로 플롯의 요소에 영향을 주는 모든 옵션은 해당 객체의 메서드라는 점을 기억하세요.\n\nfig, ax = plt.subplots()\nax.plot(x,y,'rx');\n\nax.set_xlim(0,8);\nax.set_ylim(0,4);\n\nax.grid(True);\n\nax.set_xlabel('Time');\nax.set_ylabel('Concentration');\n\n\n\n\n\n\n예제 2\n다음 예제에서는 \\([-2,4]\\) 간격의 \\(x\\)에 대한 곡선 \\(y=0.5x^2\\)를 플롯하는 것이 목표입니다. 동일한 방법을 사용하려면 주어진 간격에서 \\(x\\)에 대해 곡선 위에 놓이는 점 집합을 생성해야 합니다. 지정하는 점들은 직선으로 연결되므로 곡선이 들쭉날쭉한 모양이 되지 않도록 충분한 점을 생성해야 합니다. NumPy 메서드 \\(\\texttt{linspace}\\)는 점을 쉽게 생성할 수 있는 방법을 제공합니다. 이 메서드는 지정된 간격으로 숫자가 균등하게 배치된 NumPy 배열 객체를 생성합니다.\n\nx = np.linspace(-2,4,9)\nprint(x)\n\ny = 0.5*x**2\nprint(y)\n\n[-2.   -1.25 -0.5   0.25  1.    1.75  2.5   3.25  4.  ]\n[2.      0.78125 0.125   0.03125 0.5     1.53125 3.125   5.28125 8.     ]\n\n\n이 플롯에서는 매끄럽게 보이는 곡선을 생성하기 위해 더 많은 수의 점을 사용합니다. 또한 \\(x\\) 및 \\(y\\) 축을 따라 ticks을 구성하는 등 몇 가지 다른 옵션을 사용하여 이 플롯의 모양을 조정합니다. 눈금은 축을 따라 격자선과 숫자 레이블을 정의하는 숫자 목록입니다. plot 메서드는 ticks의 기본값을 제공하며, 새 값의 배열을 제공하여 변경할 수 있습니다.\n\nx = np.linspace(-2,4,100)\ny = 0.5*x**2\n\nfig, ax = plt.subplots()\nax.plot(x,y);\n\nax.set_xlim(-2,4);\nax.set_ylim(0,8);\n\nax.grid(True,ls='dotted');\n\nax.set_aspect('equal');\n\nax.set_xticks(np.linspace(-2,4,4));\nax.set_yticks(np.linspace(0,8,5));\n\n\n\n\n\nfig, ax = plt.subplots()\nax.plot(x,y,'g',ls='dashed');\n\nax.set_xlim(-3,5);\nax.set_ylim(-1,9);\n\nax.grid(True,ls='dotted');\n\nax.set_aspect('equal');\n\nax.set_xticks(np.linspace(-3,5,9));\nax.set_yticks(np.linspace(-1,9,11));\n\nax.axvline(color='k',linewidth = 1);\nax.axhline(color='k',linewidth = 1);"
  },
  {
    "objectID": "21_Planar_Transformations.html",
    "href": "21_Planar_Transformations.html",
    "title": "변환(평면)",
    "section": "",
    "text": "이전 섹션에서 설명한 것처럼, 모든 선형 변환 \\(T:\\mathbb{R}^2 \\to \\mathbb{R}^2\\)로의 변환은 \\(2 \\times 2\\) 행렬과 좌표 벡터의 곱셈으로 나타낼 수 있습니다. 현재 좌표는 이전과 마찬가지로 표준 기준 \\(\\{E_1,E_2\\}\\)에 대한 것입니다. 그러면 행렬의 열은 기저 벡터의 이미지가 됩니다.\n\\[\n\\begin{matrix}\nA = \\left[ \\begin{array}{c|c} T(E_1) & T(E_2) \\end{array} \\right]\n\\end{matrix}\n\\]\n\n예제 1: Horizontal Stretch\n첫 번째 예로 다음 이미지로 정의된 변환을 살펴보겠습니다.\n\\[\n\\begin{matrix}\nT\\left(\\left[ \\begin{array}{r} 1 \\\\ 0  \\end{array}\\right]\\right)= \\left[ \\begin{array}{r} 2 \\\\ 0  \\end{array}\\right] \\hspace{1in}  T\\left(\\left[ \\begin{array}{r} 0 \\\\ 1  \\end{array}\\right]\\right)= \\left[ \\begin{array}{r} 0 \\\\ 1  \\end{array}\\right]  \n\\end{matrix}\n\\]\n그러면 변환에 해당하는 행렬은 다음과 같습니다.\n\\[\n\\begin{matrix}\nA = \\left[ \\begin{array}{cc} 2 & 0 \\\\ 0 & 1 \\end{array}\\right]\n\\end{matrix}\n\\]\n성분 \\(c_1\\)과 \\(c_2\\)를 갖는 일반 벡터의 이미지는 기저 벡터의 이미지의 선형 조합으로 주어집니다.\n\\[\n\\begin{matrix}\nT\\left(\\left[ \\begin{array}{r} c_1 \\\\ c_2  \\end{array}\\right]\\right) = T\\left(c_1\\left[ \\begin{array}{r} 1 \\\\ 0  \\end{array}\\right] + c_2 \\left[ \\begin{array}{r} 0 \\\\ 1  \\end{array}\\right]\\right) = c_1T\\left(\\left[ \\begin{array}{r} 1 \\\\ 0  \\end{array}\\right]\\right) + c_2 T\\left(\\left[ \\begin{array}{r} 0 \\\\ 1  \\end{array}\\right]\\right)  = c_1\\left[ \\begin{array}{r} 2 \\\\ 0  \\end{array}\\right] + c_2\\left[ \\begin{array}{r} 0 \\\\ 1  \\end{array}\\right]  = \\left[ \\begin{array}{cc} 2 & 0 \\\\ 0 & 1 \\end{array}\\right] \\left[\\begin{array}{c} c_1 \\\\ c_2 \\end{array}\\right]\n\\end{matrix}\n\\]\n변환을 시각적으로 이해하기 위해 여러 입력 벡터와 그에 해당하는 이미지를 표시하는 플롯을 생성합니다. 각 벡터에 동일한 행렬을 곱할 것이므로 입력 벡터와 일치하는 열로 행렬을 구성하여 계산을 정리할 수 있습니다. 이 행렬은 아래 코드에서 \\(\\texttt{coords}\\)라는 레이블이 붙은 배열입니다. 배열 슬라이싱을 사용하여 첫 번째 행 \\(\\texttt{x}\\)에 레이블을 지정하고, 두 번째 행 \\(\\texttt{y}\\)에는 플로팅을 위해 레이블을 지정합니다.\n\nfrom math import pi, sin, cos\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ncoords = np.array([[0,0],[0.5,0.5],[0.5,1.5],[0,1],[0,0]])\ncoords = coords.transpose()\ncoords\nx = coords[0,:]\ny = coords[1,:]\n\nA = np.array([[2,0],[0,1]])\nA_coords = A@coords\n\n배열 \\(\\texttt{A\\_coords}\\)의 열은 \\(\\texttt{coords}\\)의 열을 구성하는 벡터의 이미지입니다. 좌표를 플롯하고 변환의 효과를 살펴봅시다. 다시 말하지만, 슬라이싱을 통해 첫 번째와 두 번째 행에 접근해야 합니다. 빨간색 점은 원래 좌표를 나타내고 새 좌표는 파란색으로 표시됩니다.\n\nx_LT1 = A_coords[0,:]\ny_LT1 = A_coords[1,:]\n\n# Create the figure and axes objects\nfig, ax = plt.subplots()\n\n# Plot the points.  x and y are original vectors, x_LT1 and y_LT1 are images\nax.plot(x,y,'ro')\nax.plot(x_LT1,y_LT1,'bo')\n\n# Connect the points by lines\nax.plot(x,y,'r',ls=\"--\")\nax.plot(x_LT1,y_LT1,'b')\n\n# Edit some settings \nax.axvline(x=0,color=\"k\",ls=\":\")\nax.axhline(y=0,color=\"k\",ls=\":\")\nax.grid(True)\nax.axis([-2,2,-1,2])\nax.set_aspect('equal')\nax.set_title(\"Horizontal Stretch\");\n\n\n\n\n변환의 결과로 다각형이 수평 방향으로 늘어난 것을 관찰할 수 있습니다.\n\n\n예제 2: Reflection\n이제 \\(\\texttt{coords}\\) 행렬에 벡터 집합이 저장되었으므로 행렬 \\(B\\)로 정의되는 또 다른 변환을 살펴봅시다.\n\\[\n\\begin{matrix}\nB = \\left[ \\begin{array}{cc} -1 & 0 \\\\ 0 & 1 \\end{array}\\right]\n\\end{matrix}\n\\]\n새로운 배열 \\(B\\)를 만들되, 이전 예제의 플로팅 코드를 재사용합니다.\n\nB = np.array([[-1,0],[0,1]])\nB_coords = B@coords\n\nx_LT2 = B_coords[0,:]\ny_LT2 = B_coords[1,:]\n\n# Create the figure and axes objects\nfig, ax = plt.subplots()\n\n# Plot the points.  x and y are original vectors, x_LT1 and y_LT1 are images\nax.plot(x,y,'ro')\nax.plot(x_LT2,y_LT2,'bo')\n\n# Connect the points by lines\nax.plot(x,y,'r',ls=\"--\")\nax.plot(x_LT2,y_LT2,'b')\n\n# Edit some settings \nax.axvline(x=0,color=\"k\",ls=\":\")\nax.axhline(y=0,color=\"k\",ls=\":\")\nax.grid(True)\nax.axis([-2,2,-1,2])\nax.set_aspect('equal')\nax.set_title(\"Reflection\");\n\n\n\n\n이 변환이 Y축으로 대칭되는 것을 볼 수 있습니다.\n\n\n예제 3: Rotation\n평면에서 벡터를 회전하려면 각도 \\(\\theta\\)를 선택하고 시계 반대 방향으로의 회전을 나타내는 행렬을 각도 \\(\\theta\\)만큼 적습니다. 이 경우 기본 삼각법을 사용하여 열을 계산할 수 있습니다.\n\\[\n\\begin{matrix}\nR = \\left[ \\begin{array}{cc} \\cos\\theta & -\\sin\\theta \\\\ \\sin\\theta & \\cos\\theta \\end{array}\\right]\n\\end{matrix}\n\\]\n\ntheta = pi/6\nR = np.array([[cos(theta),-sin(theta)],[sin(theta),cos(theta)]])\nR_coords = R@coords\n\nx_LT3 = R_coords[0,:]\ny_LT3 = R_coords[1,:]\n\n# Create the figure and axes objects\nfig, ax = plt.subplots()\n\n# Plot the points.  x and y are original vectors, x_LT1 and y_LT1 are images\nax.plot(x,y,'ro')\nax.plot(x_LT3,y_LT3,'bo')\n\n# Connect the points by lines\nax.plot(x,y,'r',ls=\"--\")\nax.plot(x_LT3,y_LT3,'b')\n\n# Edit some settings \nax.axvline(x=0,color=\"k\",ls=\":\")\nax.axhline(y=0,color=\"k\",ls=\":\")\nax.grid(True)\nax.axis([-2,2,-1,2])\nax.set_aspect('equal')\nax.set_title(\"Rotation\");\n\n\n\n\n\n\n예제 4: Shear\n역학 연구에서 전단력은 한 힘이 신체의 일부에 작용하는 동시에 다른 힘이 신체의 다른 부분에 작용하지만 반대 방향으로 작용할 때 발생합니다. 이를 시각화하기 위해 카드 한 벌이 테이블 위에 놓여 있고, 그 위에 손을 얹은 상태에서 손을 테이블과 평행하게 미끄러뜨린다고 상상해 보세요.\n전단 변환은 방향 이동과 평행하고 원점을 통과하는 선으로부터의 원래(부호 있는) 거리에 비례하는 양만큼 주어진 방향의 점을 이동시키는 변환입니다. 예를 들어, 벡터에 수평 전단을 적용하면 벡터의 \\(x\\) 좌표에 \\(y\\) 좌표의 값으로 스케일링된 값을 더합니다(또는 \\(y\\) 좌표가 음수인 경우 빼기). 수직 전단은 아래 첫 번째 행렬과 같은 형태의 행렬로 표현되며, 수평 전단은 두 번째 행렬로 표현되는데, 여기서 \\(k \\in \\mathbb{R}\\)를 전단 계수라고 합니다.\n\\[\n\\begin{matrix}\n\\left[ \\begin{array}{r} 1 & 0 \\\\ k & 1  \\end{array}\\right] \\hspace{1in}  \n\\left[ \\begin{array}{r} 1 & k \\\\ 0 & 1  \\end{array}\\right]  \n\\end{matrix}\n\\]\n\nS = np.array([[1,2],[0,1]])\nS_coords = S@coords\n\nx_LT4 = S_coords[0,:]\ny_LT4 = S_coords[1,:]\n\n# Create the figure and axes objects\nfig, ax = plt.subplots()\n\n# Plot the points.  x and y are original vectors, x_LT1 and y_LT1 are images\nax.plot(x,y,'ro')\nax.plot(x_LT4,y_LT4,'bo')\n\n# Connect the points by lines\nax.plot(x,y,'r',ls=\"--\")\nax.plot(x_LT4,y_LT4,'b')\n\n# Edit some settings \nax.axvline(x=0,color=\"k\",ls=\":\")\nax.axhline(y=0,color=\"k\",ls=\":\")\nax.grid(True)\nax.axis([-2,4,-1,2])\nax.set_aspect('equal')\nax.set_title(\"Shear\");\n\n\n\n\n\n\n예제 5: Composition of transformations\n선형 변환을 행렬로 표현할 때의 강력한 측면 중 하나는 행렬 곱셈으로 구성을 형성할 수 있다는 것입니다. 예를 들어, 예제 3의 회전과 예제 2의 반사가 뒤따르는 \\(B \\circ R\\)의 구성을 나타내는 행렬을 찾으려면 개별 변환을 나타내는 행렬을 곱하기만 하면 됩니다.\n\\[\n\\begin{matrix}\n[B][R] = \\left[ \\begin{array}{cc} -1 & 0 \\\\ 0 & 1 \\end{array}\\right]\n\\left[ \\begin{array}{cc} \\cos\\theta & -\\sin\\theta \\\\ \\sin\\theta & \\cos\\theta \\end{array}\\right]\n=\\left[ \\begin{array}{cc} -\\cos\\theta & \\sin\\theta \\\\ \\sin\\theta & \\cos\\theta \\end{array}\\right]\n\\end{matrix}\n\\]\n\nC = np.array([[-cos(theta),sin(theta)],[sin(theta),cos(theta)]])\nC_coords = C@coords\n\nx_LT5 = C_coords[0,:]\ny_LT5 = C_coords[1,:]\n\n# Create the figure and axes objects\nfig, ax = plt.subplots()\n\n# Plot the points.  x and y are original vectors, x_LT1 and y_LT1 are images\nax.plot(x,y,'ro')\nax.plot(x_LT5,y_LT5,'bo')\n\n# Connect the points by lines\nax.plot(x,y,'r',ls=\"--\")\nax.plot(x_LT5,y_LT5,'b')\n\n# Edit some settings \nax.axvline(x=0,color=\"k\",ls=\":\")\nax.axhline(y=0,color=\"k\",ls=\":\")\nax.grid(True)\nax.axis([-2,2,-1,2])\nax.set_aspect('equal')"
  },
  {
    "objectID": "15_Applications_VS.html",
    "href": "15_Applications_VS.html",
    "title": "벡터공간의 응용",
    "section": "",
    "text": "객체가 여러 개의 구성 요소로 이루어진 경우, 객체를 구성 요소당 하나의 항목이 있는 벡터로 표현하는 것이 유용할 때가 많습니다. 이 섹션에서 설명하는 예는 원자로 구성된 분자와 단어로 구성된 텍스트 문서를 포함합니다. 어떤 경우에는 객체와 관련된 방정식이 벡터 방정식을 생성하기도 합니다. 다른 경우에는 행렬 대수를 사용하여 벡터에 대한 연산을 수행해야 할 이유가 있습니다."
  },
  {
    "objectID": "15_Applications_VS.html#화학-방정식",
    "href": "15_Applications_VS.html#화학-방정식",
    "title": "벡터공간의 응용",
    "section": "화학 방정식",
    "text": "화학 방정식\n화학 방정식의 균형을 맞출 때, 방정식의 양쪽에서 각 유형의 원자 수를 동일하게 유지하면서 생성물 분자의 수를 형성하는 반응물 분자의 수를 결정하려고 합니다. 다음은 에탄올 연소에 대한 예시입니다.\n\\[\n\\begin{matrix}\nC_2H_5OH + O_2 \\to CO_2 + H_2O\n\\end{matrix}\n\\]\n이 방정식은 양쪽에 같은 수의 탄소 원자(\\(C\\))나 같은 수의 수소 원자(\\(H\\))가 포함되어 있지 않으므로 올바르지 않습니다. 각 분자를 곱하는 미지의 계수를 사용하여 방정식을 다시 작성해 보겠습니다.\n\\[\n\\begin{matrix}\nx_1C_2H_5OH + x_2O_2 \\to x_3CO_2 + x_4H_2O\n\\end{matrix}\n\\]\n이제 문제는 방정식의 양 변에 각각 탄소, 산소, 수소의 원자 수가 같도록 \\(x_1\\), \\(x_2\\), \\(x_3\\), \\(x_4\\)의 값을 구하는 것입니다. 또한 분자는 불연속적인 단위이므로 미지 계수는 양수 정수여야 합니다.\n이 시나리오에서는 각 분자를 방정식의 각 원자 유형에 대해 하나씩 세 개의 항목이 있는 벡터로 생각하는 것이 유용합니다. 첫 번째 항목은 탄소 원자의 수, 두 번째 항목은 산소 원자의 수, 세 번째 항목은 수소 원자의 수라고 가정해 보겠습니다. 따라서 다음 벡터는 \\(C_2H_5OH\\)를 나타냅니다.\n\\[\n\\begin{matrix}\n\\left[\\begin{array}{c} 2 \\\\ 6 \\\\ 1 \\end{array}\\right]\n\\end{matrix}\n\\]\n화학 방정식은 매우 자연스럽게 벡터 방정식으로 표현됩니다.\n\\[\n\\begin{matrix}\nx_1\\left[\\begin{array}{c} 2 \\\\ 6 \\\\ 1 \\end{array}\\right]\n+ x_2\\left[\\begin{array}{c} 0 \\\\ 0 \\\\ 2 \\end{array}\\right]\n= x_3\\left[\\begin{array}{c} 1 \\\\ 0 \\\\ 2 \\end{array}\\right]\n+ x_4\\left[\\begin{array}{c} 0 \\\\ 2 \\\\ 1 \\end{array}\\right]\n\\end{matrix}\n\\]\n미지수가 있는 모든 항이 왼쪽에 오도록 재배열하면 이 벡터 방정식이 균질 시스템을 나타낸다는 것을 알 수 있습니다.\n\\[\n\\begin{matrix}\n\\left[\\begin{array}{rrr} 2 & 0 & -1 & 0 \\\\ 6 & 0 & 0 & -2 \\\\ 1 & 2 & -2 & -1 \\end{array}\\right]\n\\left[\\begin{array}{r} x_1 \\\\ x_2 \\\\ x_3 \\\\ x_4 \\end{array}\\right]\n= \\left[\\begin{array}{r} 0 \\\\ 0 \\\\ 0  \\end{array}\\right]\n\\end{matrix}\n\\]\n해를 찾기 전에 이 장의 결과 중 일부를 적용해 봅시다. 우리는 사소한 해(\\(x_1=x_2=x_3=x_4=0\\))가 항상 가능한 해이기 때문에 동질계는 항상 일관성이 있다는 것을 알고 있습니다. 또한 계수 행렬의 모양(\\(4 \\times 3\\))을 살펴봄으로써 추가적인 결론을 내릴 수 있습니다. 행당 피벗은 하나만 있을 수 있으므로 피벗은 최대 3개까지만 존재한다는 것을 알 수 있습니다. 이는 4개의 열 각각에 피벗이 있을 수 없다는 것을 의미하며, 이는 시스템에 적어도 하나의 자유 변수가 있고 사소한 해가 유일한 해가 아니라는 것을 의미합니다.\n이제 RREF를 사용해 해를 찾아보겠습니다. 이 시스템은 동형 시스템이기 때문에 오른쪽을 나타내는 증강 행렬의 마지막 열은 모두 0이라는 것을 기억하세요. 수행된 행 연산에 관계없이 모든 항목이 0으로 유지되므로 계산에서 이 마지막 열을 생략하겠습니다.\n\nimport numpy as np\nimport linear_solver as ls\n\nA = np.array([[2, 0, -1, 0],[6, 0, 0, -2],[1, 2, -2, -1]])\nA_reduced = ls.full_row_reduction(A)\nprint(A_reduced)\n\n[[ 1.          0.          0.         -0.33333333]\n [ 0.          1.          0.         -1.        ]\n [ 0.          0.          1.         -0.66666667]]\n\n\n열에 \\(x_4\\)에 해당하는 피벗이 없으므로 \\(x_4\\)를 자유 변수로 취급합니다. 이 응용에서는 특별히 정수인 솔루션을 찾고 있으므로 \\(x_4=3\\)을 사용합니다. 이렇게 하면 \\(x_3=2\\), \\(x_2=3\\), \\(x_1=1\\)이 됩니다. 화학 반응에 대한 올바른 방정식은 다음과 같습니다.\n\\[\n\\begin{matrix}\nC_2H_5OH + 3O_2 \\to 2CO_2 + 3H_2O\n\\end{matrix}\n\\]"
  },
  {
    "objectID": "15_Applications_VS.html#정보-검색",
    "href": "15_Applications_VS.html#정보-검색",
    "title": "벡터공간의 응용",
    "section": "정보 검색",
    "text": "정보 검색\n정보 검색에서 잘 알려진 아이디어는 데이터베이스의 문서를 \\(\\mathbb{R}^n\\)의 벡터로 표현하는 벡터 공간 모델의 개념입니다. 키워드 검색과 가장 연관성이 높은 문서를 데이터베이스에서 검색하는 알고리즘은 이 벡터 표현을 활용할 수 있습니다. 이러한 알고리즘이 어떻게 작동하는지에 대한 몇 가지 간단한 예를 제공합니다.\n벡터로 문서를 모델링하는 것부터 시작해 보겠습니다. 우리에게 정말로 필요한 것은 데이터베이스에서 검색할 수 있는 \\(n\\)개의 단어 목록입니다. 이 목록은 전체 문서 컬렉션에 있는 각각의 고유한 단어 목록일 수도 있지만, 영어에는 모든 문서에 많이 나타나기 때문에 키워드로 사용할 수 없는 일반적인 단어(the, as, in, it 등)가 많이 있습니다. 이제 데이터베이스의 각 문서는 해당 키워드가 문서에 나타나면 \\(n\\)번째 항목이 1로, 그렇지 않으면 0으로 설정된 \\(\\mathbb{R}^n\\)의 벡터로 나타낼 수 있습니다.\n예를 들어, 데이터베이스가 단순히 정보 검색과 관련된 콘텐츠가 포함된 웹페이지 목록이라고 가정해 보겠습니다. 키워드 집합은 다음과 같을 수 있습니다.\n{algorithm, engine, information, google, computations, matrix, optimization, retrieval, search, theory }\n데이터베이스의 각 웹 페이지는 이러한 단어에 해당하는 항목이 있는 \\(\\mathbb{R}^{10}\\)의 벡터입니다. 이러한 벡터는 열 벡터의 \\(10 \\times 1\\)보다는 행 벡터의 \\(1 \\times 10\\)로 작성하는 것이 가장 편리합니다. 예를 들어, 검색 엔진 알고리즘은 \\([1, 1, 0, 0, 0, 0, 0, 0, 1, 0]\\)로 표현할 수 있습니다. 그러면 데이터베이스는 각 제목에 대한 행이 있는 \\(n \\times 10\\) 행렬로 표현됩니다. 이 예제에서는 다음과 같은 6개의 제목이 있다고 가정해 보겠습니다.\n\nSearch Engine Algorithms\nHow Google Search Optimization Works\nInformation Retrieval Theory\nMatrix Models of Information Retrieval\nTheory Behind Search Engines\nComputations in Information Retrieval\n\n각 타이틀에 대한 벡터를 만든 다음 이를 행렬 \\(D\\)로 조합합니다.\n\nT1 = np.array([[1, 1, 0, 0, 0, 0, 0, 0, 1, 0]])\nT2 = np.array([[0, 0, 0, 1, 0, 0, 1, 0, 1, 0]])\nT3 = np.array([[0, 0, 1, 0, 0, 0, 0, 1, 0, 1]])\nT4 = np.array([[0, 0, 1, 0, 0, 1, 0, 1, 0, 0]])\nT5 = np.array([[0, 1, 0, 0, 0, 0, 0, 0, 1, 1]])\nT6 = np.array([[0, 0, 1, 0, 0, 0, 0, 1, 0, 0]])\n\nD = np.vstack((T1,T2,T3,T4,T5,T6))\nprint(D)\n\n[[1 1 0 0 0 0 0 0 1 0]\n [0 0 0 1 0 0 1 0 1 0]\n [0 0 1 0 0 0 0 1 0 1]\n [0 0 1 0 0 1 0 1 0 0]\n [0 1 0 0 0 0 0 0 1 1]\n [0 0 1 0 0 0 0 1 0 0]]\n\n\n다음으로 키워드 검색을 수행하는 방법을 고려해 보겠습니다. “정보”, “검색”, “이론”이라는 단어와 일치하는 항목을 검색하고 싶다고 가정해 보겠습니다. 이 키워드에 해당하는 1의 항목이 있는 \\(10 \\times 1\\) 쿼리 벡터 \\(X\\)를 만들 수 있습니다. 이 경우 쿼리 벡터는 \\([0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1]^T\\)입니다. 이제 행렬-벡터 곱 \\(DX\\)에는 데이터베이스의 각 제목과 일치하는 검색 단어 수를 나타내는 항목이 포함됩니다.\n\nX = np.array([[0, 0, 1, 0, 0, 0, 0, 1, 0, 1]])\nresults = D@X.transpose()\nprint(results)\n\n[[0]\n [0]\n [3]\n [2]\n [1]\n [2]]\n\n\n세 번째 항목인 \\(DX\\)가 가장 크므로 데이터베이스의 세 번째 웹페이지가 검색 키워드 목록과 가장 잘 일치합니다. 마지막 세 개의 제목은 부분 검색 일치로 보고될 수도 있습니다. 데이터베이스 검색은 단일 행렬 곱셈과 벡터 \\(DX\\)를 검색하여 가장 큰 항목을 찾는 것에 불과하다는 점에 유의하세요.\n데이터베이스의 문서가 표현될 수 있는 다른 방법도 있습니다. 한 가지 방법은 각 문서 벡터의 \\(n\\)번째 항목이 해당 문서에서 해당 단어의 빈도와 같도록 하는 것입니다. 예를 들어, 7번째 키워드가 문서에 53번 등장하는 경우, 해당 문서를 나타내는 벡터의 7번째 항목은 53번이 됩니다. 그 결과 일치하는 키워드의 인스턴스가 많이 포함된 문서가 해당 단어의 인스턴스가 적은 문서보다 검색에서 더 높은 순위를 차지하게 됩니다.\n또 다른 아이디어는 \\(n\\)번째 항목을 해당 문서에서 연관된 키워드의 상대적 빈도와 동일하게 설정하는 것입니다. 상대적 빈도는 빈도를 문서에 있는 모든 키워드의 총 수로 나눈 값입니다. 아래는 검색 가능한 단어가 10개만 있는 경우 키워드 수가 어떻게 표시되는지 보여주는 예입니다.\n\n\n\nKeyword\nDocument 1\n\n\n\n\nalgorithm\n19\n\n\nengine\n23\n\n\ninformation\n0\n\n\ngoogle\n2\n\n\ncompuations\n0\n\n\nmatrix\n11\n\n\noptimization\n0\n\n\nretrieval\n10\n\n\nsearch\n31\n\n\ntheory\n4\n\n\n\n키워드 일치 항목이 총 100개이므로 각 항목을 100으로 나누면 문서 1에 해당하는 행 벡터는 \\([0.19, 0.23, 0, 0.02, 0, 0.11, 0, 0.1, 0.31, 0.04]\\)가 됩니다. 실제로 검색 가능한 단어의 수와 각 문서의 단어 수는 각각 수만 개에 달할 수 있습니다. 쿼리 벡터는 다시 검색 단어에 해당하는 엔트리가 1이고 다른 모든 엔트리가 0으로 설정된 열 벡터입니다. 검색은 단일 행렬 곱셈으로 실행된 다음 가장 큰 항목에 대한 결과 벡터를 검색하는 방식으로 수행됩니다. 이 표현의 효과는 빈도를 사용하는 것과 비슷하지만, 이제 30000단어에 50개의 일치 항목이 있는 문서가 100000단어에 50개의 일치 항목이 있는 문서보다 더 높은 평가를 받게 됩니다.\n\nReferences\n\nBerry, Michael W. and Murray Browne. Understanding Serach Engines: Mathematical Modeling and Text Retrieval. 2nd ed., SIAM, 2005\nLay, David, et al. Linear Algebra and its Applications. 5th ed., Pearson., 2016\nLeon, Steven J. Linear Algebra with Applications. 9th ed., Pearson., 2015"
  },
  {
    "objectID": "13_Bases.html",
    "href": "13_Bases.html",
    "title": "기저",
    "section": "",
    "text": "벡터 공간 또는 부분 공간으로 작업할 때, 임의의 벡터를 기저 라고 알려진 주어진 벡터 집합의 선형 조합으로 표현하는 것이 유용할 때가 많습니다. 벡터 공간(또는 부분 공간)의 기저는 공간에 걸쳐 있는 선형적으로 독립적인 벡터의 집합입니다. 이 정의는 선형 독립성과 스패닝 집합의 개념을 결합하여 벡터 공간의 구성 요소로 이해할 수 있는 벡터 집합을 설명합니다.\n벡터 집합 \\(\\{V_1, V_2, V_3, ... V_n\\}\\) 의 벡터 집합과 \\(\\mathbb{R}^n\\) 의 벡터 \\(Y\\) 가 주어지면, 벡터 방정식 \\(c_1V_1 + c_2V_2 + ... c_nV_n = Y\\) 를 생각해 봅시다. 이 벡터 방정식은 선형 시스템을 나타내며, 행렬 방정식 \\(AX=Y\\)로도 표현할 수 있는데, 여기서 \\(A\\)는 벡터 \\(V_i\\)를 열로 갖는 \\(n\\ times n\\) 행렬입니다. 이전 섹션에서 우리는 이 시스템과 관련하여 두 가지 중요한 결론을 내렸습니다.\n\\(AX=Y\\)는 \\(A\\)의 열이 선형적으로 독립적이고, 공간 \\(\\mathbb{R}^n\\)에 걸쳐 있는 경우에만 \\(\\mathbb{R}^n\\)의 각 \\(Y\\)에 대해 정확히 하나의 해를 갖는다는 것을 알 수 있습니다. 다시 말해, 벡터 방정식 \\(c_1V_1 + c_2V_2 + ... c_nV_n = Y\\)는 벡터 집합 \\(\\{V_1, V_2, V_3, ... V_n \\}\\)의 경우에만 \\(\\mathbb{R}^n\\)의 모든 \\(Y\\)에 대해 고유한 해를 갖습니다. \\(\\{V_n\\}\\) 은 \\(\\mathbb{R}^n\\) 의 기저입니다."
  },
  {
    "objectID": "13_Bases.html#dimension",
    "href": "13_Bases.html#dimension",
    "title": "기저",
    "section": "Dimension",
    "text": "Dimension\n이제 기저를 형성하지 않는 벡터 집합을 살펴보겠습니다. 이러한 예시를 살펴보면서 기저와 직접적으로 관련된 개념을 발견할 수 있습니다.\n다음 벡터 집합은 \\(\\mathbb{R}^5\\) 의 기저가 아닌 집합입니다.\n\\[\n\\begin{matrix}\nV_1 = \\left[ \\begin{array}{r} -3 \\\\ 3 \\\\ 2 \\\\ -3 \\\\ -2 \\end{array}\\right] \\hspace{0.7cm}\nV_2 = \\left[ \\begin{array}{r} 3 \\\\ 3 \\\\ 2 \\\\ -1 \\\\ 3  \\end{array}\\right] \\hspace{0.7cm}\nV_3 = \\left[ \\begin{array}{r} 2 \\\\ 0 \\\\ -2 \\\\ 2 \\\\ 2 \\end{array}\\right] \\hspace{0.7cm}\nV_4 = \\left[ \\begin{array}{r} -3 \\\\ -1 \\\\ 2 \\\\ -1 \\\\ 3 \\end{array}\\right] \\hspace{0.7cm}\nV_5 = \\left[ \\begin{array}{r} -2 \\\\ 0 \\\\ -3 \\\\ 3 \\\\ -2 \\end{array}\\right] \\hspace{0.7cm}\nV_6 = \\left[ \\begin{array}{r} -1 \\\\ 0 \\\\ 2 \\\\ 2 \\\\ 1 \\end{array}\\right]\n\\end{matrix}\n\\]\n이러한 벡터를 열로 하는 \\(5 \\times 6\\) 행렬을 조립하고 이전과 같이 RREF를 계산할 수 있지만, 행렬의 모양 때문에 각 열에 피벗이 없다는 것을 예상해야 합니다. 각 행은 최대 하나의 피벗만 가질 수 있으므로 행렬에는 최대 5개의 피벗이 있다는 것을 기억하세요. 열이 6개이므로 열 중 하나에는 피벗이 없습니다. 이것은 벡터 집합이 선형 의존적이며 따라서 기준이 아님을 보여줍니다.\n\nB = np.array([[-3,3,2,-3,-2,-1],[3,3,0,-1,0,0],[2,2,-2,2,-3,2],[-3,-1,2,-1,3,2],[-2,3,2,3,-2,1]])\nprint(ls.full_row_reduction(B))\n\n[[ 1.   0.   0.   0.   0.  -1.6]\n [ 0.   1.   0.   0.   0.   1.8]\n [ 0.   0.   1.   0.   0.  -2.9]\n [ 0.   0.   0.   1.   0.   0.6]\n [ 0.   0.   0.   0.   1.   1.8]]\n\n\n다음 벡터 집합은 \\(\\mathbb{R}^5\\) 의 기저가 아닌 집합입니다.\n\\[\n\\begin{matrix}\nV_1 = \\left[ \\begin{array}{r} -3 \\\\ 3 \\\\ 2 \\\\ -3 \\\\ -2 \\end{array}\\right] \\hspace{0.7cm}\nV_2 = \\left[ \\begin{array}{r} 3 \\\\ 3 \\\\ 2 \\\\ -1 \\\\ 3  \\end{array}\\right] \\hspace{0.7cm}\nV_3 = \\left[ \\begin{array}{r} 2 \\\\ 0 \\\\ -2 \\\\ 2 \\\\ 2 \\end{array}\\right] \\hspace{0.7cm}\nV_4 = \\left[ \\begin{array}{r} -3 \\\\ -1 \\\\ 2 \\\\ -1 \\\\ 3 \\end{array}\\right] \\hspace{0.7cm}\n\\end{matrix}\n\\]\n이러한 열 벡터로 구성된 행렬은 5개의 행과 4개의 열로 구성됩니다. 각 열에는 피벗이 1개만 포함될 수 있으므로 피벗은 최대 4개까지만 있습니다. 이는 RREF에 적어도 하나의 0 행이 있다는 것을 의미하며, \\(\\mathbb{R}^5\\)의 모든 \\(B\\)에 대해 \\(AX = B\\) 시스템이 일관적이지 않다는 것을 의미합니다.\n\nB = np.array([[-3,3,2,-3],[3,3,0,-1],[2,2,-2,2],[-3,-1,2,-1],[-2,3,2,3]])\nprint(ls.full_row_reduction(B))\n\n[[1. 0. 0. 0.]\n [0. 1. 0. 0.]\n [0. 0. 1. 0.]\n [0. 0. 0. 1.]\n [0. 0. 0. 0.]]\n\n\n이 두 예는 정확히 5개의 벡터를 포함하지 않는 벡터 집합이 \\(\\mathbb{R}^5\\)의 기준이 될 수 없는 이유를 설명합니다. 우리는 공간이 5차원이기 때문에 정확히 5개의 벡터가 필요하다고 생각할 수 있으며, 이는 거의 맞습니다. 공간의 기저에 벡터가 5개 있어야 하기 때문에 \\(\\mathbb{R}^5\\)는 5차원이라고 말하는 것이 더 정확합니다. 벡터 공간(또는 부분 공간)의 차원은 공간의 모든 기저에 있는 벡터의 수로 정의됩니다."
  },
  {
    "objectID": "13_Bases.html#coordinates",
    "href": "13_Bases.html#coordinates",
    "title": "기저",
    "section": "Coordinates",
    "text": "Coordinates\n이제 기저 \\(\\{V_1, V_2, V_3, ... V_n\\}\\) 의 기저 \\(\\mathbb{R}^n\\) 과 \\(\\mathbb{R}^n\\) 의 벡터 \\(X\\) 가 주어지면, 기저 벡터의 고유한 선형 조합이 \\(X\\) 와 같다는 것을 알 수 있습니다. 이 기저에 대한 \\(X\\)의 좌표는 벡터 방정식 \\(X=c_1V_1 + c_2V_2 + ... c_nV_n\\)을 만족하는 고유한 가중치 \\(c_1\\), \\(c_2\\), … \\(c_n\\)의 집합입니다. 이 시점에서 논의 중인 기저에 레이블을 지정하는 것이 유용해집니다. 예를 들어, \\(\\beta = \\{V_1, V_2, V_3, ... V_n\\}\\)라고 하고, \\(\\beta\\)에 대한 \\(X\\)의 좌표를 참조할 수 있습니다. 이러한 가중치를 \\(n \\times 1\\) 배열로 모으는 것은 당연한 일이며, 여기에 \\([X]_{\\beta}\\)라는 표기법을 할당할 것입니다. 혼동할 수 있지만, 이 배열을 “좌표 벡터”라고 부릅니다.\n이를 설명하기 위해 예제 1에 주어진 \\(\\mathbb{R}^5\\)의 기저를 사용하고 \\(\\beta\\)라는 레이블을 지정한다고 가정해 보겠습니다. 이제 \\(\\beta\\)에 대한 벡터 \\(X\\)의 좌표를 구하는 데 필요한 계산을 생각해 봅시다.\n\\[\n\\begin{matrix}\nX = \\left[ \\begin{array}{r} 3 \\\\ 5 \\\\ -3 \\\\ -2 \\\\ -7 \\end{array}\\right]=\nc_1\\left[ \\begin{array}{r} -3 \\\\ 3 \\\\ 2 \\\\ -3 \\\\ -2 \\end{array}\\right]\n+c_2\\left[ \\begin{array}{r} 3 \\\\ 3 \\\\ 2 \\\\ -1 \\\\ 3  \\end{array}\\right]\n+c_3\\left[ \\begin{array}{r} 2 \\\\ 0 \\\\ -2 \\\\ 2 \\\\ 2 \\end{array}\\right]\n+c_4\\left[ \\begin{array}{r} -3 \\\\ -1 \\\\ 2 \\\\ -1 \\\\ 3 \\end{array}\\right]\n+c_5\\left[ \\begin{array}{r} -2 \\\\ 0 \\\\ -3 \\\\ 3 \\\\ -2 \\end{array}\\right]\n\\end{matrix}\n\\]\n좌표를 구하려면 선형 시스템 \\(A[X]_{\\beta} = X\\)를 풀어야 하는데, 여기서 \\(A\\)는 기저 벡터를 열로 하는 행렬이고, \\([X]_{\\beta}\\)는 미지수의 벡터입니다.\n\nA = np.array([[-3,3,2,-3,-2],[3,3,0,-1,0],[2,2,-2,2,-3],[-3,-1,2,-1,3],[-2,3,2,3,-2]])\nX = np.array([[3],[5],[-3],[-2],[-7]])\nX_beta = ls.solve_system(A,X)\nprint(X_beta)\n\n[[ 2.]\n [-1.]\n [ 2.]\n [-2.]\n [-1.]]\n\n\n좌표를 계산할 때는 항상 선형 시스템을 풀어야 하므로, 선형 시스템 \\(AX=B\\)를 풀 때마다 실제로는 \\(A\\)의 열에 대한 \\(B\\)의 좌표를 구하는 것임을 기억하면 도움이 될 수 있습니다."
  },
  {
    "objectID": "11_Linear_Combinations.html",
    "href": "11_Linear_Combinations.html",
    "title": "선형 결합",
    "section": "",
    "text": "선형대수학의 많은 아이디어의 핵심은 벡터의 선형 조합(linear combination) 이라는 개념입니다. 벡터 집합 \\(\\{V_1, V_2, V_3, ... V_n\\}\\) 벡터 집합에서 선형 조합을 만들려면 덧셈과 스칼라 곱셈이라는 두 가지 대수 연산을 사용합니다. 스칼라를 나타내기 위해 \\(a_1, a_2, ..., a_n\\) 기호를 사용하면 선형 조합은 다음과 같이 보입니다.\n\\[\n\\begin{matrix}\na_1V_1 + a_2V_2 + a_3V_3 + .... + a_nV_n\n\\end{matrix}\n\\]\n스칼라 \\(a_1, a_2, ..., a_n\\)을 가중치(weights) 라고 부르기도 합니다.\n구체적인 예를 들기 위해 벡터를 정의해 보겠습니다.\n\\[\n\\begin{matrix}\nV_1 = \\left[ \\begin{array}{r} 2 \\\\ -2 \\\\ 1 \\end{array}\\right] \\hspace{1cm}\nV_2 = \\left[ \\begin{array}{r} 1 \\\\  0 \\\\ -1  \\end{array}\\right] \\hspace{1cm}\nV_3 = \\left[ \\begin{array}{r} 0 \\\\ -1 \\\\  6 \\end{array}\\right]\n\\end{matrix}\n\\]\n이제 \\(3V_1 + 2V_2 +4V_3\\), \\(V_1-V_2+V_3\\), \\(3V_2 -V_3\\)는 모두 벡터 집합 \\(\\{V_1, V_2, V_3\\}\\)의 선형 조합의 예이며, 필요한 경우 명시적으로 계산할 수 있습니다.\n\\[\n\\begin{matrix}\n3V_1+ 2V_2+ 4V_3 = 3\\left[ \\begin{array}{r} 2 \\\\ -2 \\\\ 1 \\end{array}\\right]\n+2 \\left[ \\begin{array}{r} 1 \\\\  0 \\\\ -1  \\end{array}\\right]\n+4 \\left[ \\begin{array}{r} 0 \\\\ -1 \\\\  6 \\end{array}\\right] =\n\\left[ \\begin{array}{r} 8 \\\\ -10 \\\\  25 \\end{array}\\right]\n\\end{matrix}\n\\]\n벡터의 선형 조합 개념은 선형 방정식 시스템을 푸는 문제를 재해석하는 데 사용할 수 있습니다. 다음 시스템을 고려해 보겠습니다.\n\\[\n\\begin{matrix}\nx_1 + 2x_2  & = & 0\\\\\n3x_1 - x_2  & = & 14 \\\\\n\\end{matrix}\n\\]\n행렬 곱셈을 사용하여 이 시스템을 작성하는 방법에 대해서는 이미 설명했습니다.\n\\[\n\\begin{matrix}\n\\left[ \\begin{array}{cc} 1 & 2 \\\\ 3 & -1 \\end{array}\\right]\n\\left[ \\begin{array}{c} x_1 \\\\ x_2 \\end{array}\\right]=\n\\left[ \\begin{array}{c} 0 \\\\ 14 \\end{array}\\right]\n\\end{matrix}\n\\]\n또한 이 행렬 방정식을 벡터 방정식으로 표현하는 방법도 살펴봤습니다.\n\\[\n\\begin{matrix}\nx_1\\left[ \\begin{array}{r} 1 \\\\ 3 \\end{array}\\right] +\nx_2\\left[ \\begin{array}{r} 2 \\\\ -1  \\end{array}\\right] =\n\\left[ \\begin{array}{r} 0 \\\\ 14  \\end{array}\\right]\n\\end{matrix}\n\\]\n이제 계수 행렬의 열을 벡터로 간주하면 선형 조합에 대한 연결이 명확해집니다. 선형 방정식 시스템의 해를 구하는 것은 방정식의 오른쪽에 있는 벡터와 일치하는 이러한 열 벡터의 선형 조합을 찾는 것과 같습니다."
  },
  {
    "objectID": "11_Linear_Combinations.html#spans",
    "href": "11_Linear_Combinations.html#spans",
    "title": "선형 결합",
    "section": "Spans",
    "text": "Spans\n선형 결합의 집합을 설명하는 용어를 소개하는 것입니다.\n벡터 집합 \\(\\{V_1, V_2, V_3, ...\\}\\)의 span. \\(\\{V_n\\}\\)은 이 집합에서 가능한 모든 벡터의 선형 결합의 집합입니다. 모든 계수 \\(a_1, a_2, ..., a_n\\)에 대해 벡터 \\(a_1V_1 + a_2V_2 + a_3V_3 + ..... + a_nV_n\\) 는 \\(\\{V_1, V_2, V_3, ... V_n\\}\\).\n우리는 주어진 선형 시스템이 해를 갖는지 결정하려고 할 때, 선형 시스템과 벡터의 선형 결합 사이의 직접적인 연관성을 감안하자면 주어진 벡터, 예를 들어 \\(B\\)가 어떤 벡터 집합 \\(\\{V_1, V_2, V_3, ... V_n\\}\\)입니다. \\(B\\)가 \\(\\{V_1, V_2, V_3, ... V_n\\}\\)의 범위에 있는지 확인하려고 한다고 말할 수 있습니다.\n\\(\\{V_n\\}\\)의 범위에 있는지 확인하려고 합니다."
  },
  {
    "objectID": "11_Linear_Combinations.html#예제-1-span-in-mathbbr4",
    "href": "11_Linear_Combinations.html#예제-1-span-in-mathbbr4",
    "title": "선형 결합",
    "section": "예제 1: Span in \\(\\mathbb{R}^4\\)",
    "text": "예제 1: Span in \\(\\mathbb{R}^4\\)\n이제 선형 시스템의 경험을 사용해서 선형 결합의 범위를 찾는 데 적용할 수 있습니다.\n다음 정의가 주어졌을 때 \\(B\\)가 \\(\\{V_1, V_2, V_3\\}\\)의 범위에 있는지 확인하려고 한다고 가정해 보겠습니다.\n\\[\n\\begin{matrix}\nV_1 = \\left[ \\begin{array}{r} 2 \\\\ -1 \\\\ 0 \\\\ 3 \\end{array}\\right] \\hspace{1cm}\nV_2 = \\left[ \\begin{array}{r} 2 \\\\ 2 \\\\ 6 \\\\ -4  \\end{array}\\right] \\hspace{1cm}\nV_3 = \\left[ \\begin{array}{r} -1 \\\\ -1 \\\\ -1 \\\\ 0 \\end{array}\\right] \\hspace{1cm}\nB = \\left[ \\begin{array}{r}  4 \\\\ -2 \\\\ 4 \\\\ 2 \\end{array}\\right]\n\\end{matrix}\n\\]\n다음 벡터 방정식이 참인 숫자 \\(a_1\\), \\(a_2\\), \\(a_3\\)이 있는지 확인해야 합니다.\n\\[\n\\begin{matrix}\na_1\\left[ \\begin{array}{r} 2 \\\\ -1 \\\\ 0 \\\\ 3 \\end{array}\\right]+\na_2\\left[ \\begin{array}{r} 2 \\\\ 2 \\\\ 6 \\\\ -4  \\end{array}\\right] +\na_3\\left[ \\begin{array}{r} -1 \\\\ -1 \\\\ -1 \\\\ 0 \\end{array}\\right] =\n\\left[ \\begin{array}{r}  4 \\\\ -2 \\\\ 4 \\\\ 2 \\end{array}\\right]\n\\end{matrix}\n\\]\n이 벡터 방정식은 다음 선형 시스템이 일관성이 있는지 확인하는 것과 같습니다.\n\\[\n\\begin{matrix}\n2a_1 + 2a_2 - a_3 & = & 4\\\\\n-a_1 + 2a_2 - a_3 & = & -2\\\\\n\\quad\\quad 6a_2 - a_3 & = & 4 \\\\\n3a_1 -4a_2 \\quad\\quad & = & 2\n\\end{matrix}\n\\]\n\nimport numpy as np\nimport linear_solver as ls\n\nA_augmented = np.array([[2,2,-1,4],[-1,2,-1,-2],[0,6,-1,4],[3,-4,0,2]])\nA_augmented_reduced = ls.row_reduction(A_augmented)\nprint(A_augmented_reduced)\n\nPivot could not be found in column 3 .\n[[ 1.   1.  -0.5  2. ]\n [ 0.   1.  -0.5  0. ]\n [ 0.   0.   1.   2. ]\n [ 0.   0.   0.   0. ]]\n\n\nRREF를 확인하면, 해당 선형 시스템은 일관성을 유지합니다.\n행 연산은 한 행을 그 행의 합과 다른 행의 배수로 대체한다는 점을 기억하세요. 즉, 행은 행의 특정 선형 조합으로 대체될 수 있습니다. RREF 첫번째 행은 원래 시스템의 네 가지 방정식 중 하나가 실제로는 다른 방정식의 선형 조합이었음을 나타냅니다(제거 과정에서 행이 섞였을 수 있으므로 어떤 방정식이 중복되었는지는 확실하지 않습니다).\n나머지 방정식 집합은 이전과 마찬가지로 역치환을 통해 해를 구할 수 있습니다(\\(a_1 = 2\\), \\(a_2 = 1\\), \\(a_3=2\\)).\n\\[\n\\begin{matrix}\na_1 + a_2 - 0.5a_3 & = & 2\\\\\na_2 - 0.5a_3 & = & 0\\\\\na_3 & = & 2\n\\end{matrix}\n\\]"
  },
  {
    "objectID": "11_Linear_Combinations.html#예제-2-span-in-mathbbr4",
    "href": "11_Linear_Combinations.html#예제-2-span-in-mathbbr4",
    "title": "선형 결합",
    "section": "예제 2: Span in \\(\\mathbb{R}^4\\)",
    "text": "예제 2: Span in \\(\\mathbb{R}^4\\)\n다른 예로, \\(C\\)로 주어진 벡터가 \\(\\{V_1, V_2, V_3\\}\\)의 범위에 있는지 확인해 보겠습니다.\n\\[\n\\begin{matrix}\nC = \\left[ \\begin{array}{r}  4 \\\\ -2 \\\\ 4 \\\\ 0 \\end{array}\\right]\n\\end{matrix}\n\\]\n다시 말하지만, 선형 시스템이 일관성이 있는지 확인해야 합니다.\n\\[\n\\begin{matrix}\n2a_1 + 2a_2 - a_3 & = & 4\\\\\n-a_1 + 2a_2 - a_3 & = & -2\\\\\n\\quad\\quad 6a_2 - a_3 & = & 4 \\\\\n3a_1 -4a_2 \\quad\\quad & = & 0\n\\end{matrix}\n\\]\n\nB_augmented = np.array([[2,2,-1,4],[-1,2,-1,-2],[0,6,-1,4],[3,-4,0,0]])\nB_reduced = ls.row_reduction(B_augmented)\nprint(B_reduced)\n\n[[ 1.   1.  -0.5  2. ]\n [ 0.   1.  -0.5  0. ]\n [ 0.   0.   1.   2. ]\n [-0.  -0.  -0.   1. ]]\n\n\nRREF에서 확인할 수 있듯이 이 선형 시스템은 해가 없음을 나타냅니다. 실제로 표현된 시스템을 살펴보면 마지막 방정식을 만족하는 \\(a_1\\), \\(a_2\\), \\(a_3\\)의 값이 없다는 것을 바로 알 수 있습니다.\n\\[\n\\begin{matrix}\na_1 + a_2 - 0.5a_3 & = & 2\\\\\na_2 - 0.5a_3 & = & 0\\\\\n\\quad\\quad a_3 & = & 2 \\\\\n0 & = & 1\n\\end{matrix}\n\\]\n\n스팬과 일관성 없음(inconsistent)\n스팬의 개념은 일반적인 선형 시스템 \\(AX = B\\)와 직접적으로 연결되어 있는데, 여기서 \\(A\\)는 \\(m \\times n\\) 행렬이고, \\(X\\)는 \\(\\mathbb{R}^n\\), \\(B\\)는 \\(\\mathbb{R}^m\\)에 속합니다.\n\\(AX\\)는 \\(A\\) 열의 선형 조합이므로, \\(AX=B\\) 시스템은 \\(B\\)가 \\(A\\) 열의 범위에 있는 경우에만 해를 구할 수 있습니다. 이는 행렬-벡터 곱셈과 스팬의 정의에 따른 직접적인 결과입니다.\n이 동등성만으로는 시스템을 푸는 데 직접적인 도움이 되지는 않지만, 좀 더 일반적인 질문을 던질 수 있습니다. 주어진 \\(m \\times n\\) 행렬 \\(A\\)에 대해 선형 시스템 \\(AX=B\\)는 \\(\\mathbb{R}^m\\)의 모든 벡터 \\(B\\)에 대한 해를 가질 수 있을까요?\n일관성 없는 시스템 \\(AX=B\\)를 나타내는 RREF의 구조를 생각해 보겠습니다(\\(A\\)는 \\(4 \\times 4\\) 행렬). 한 가지 가능성은 다음과 같습니다.\n\\[\n\\begin{matrix}\n\\left[ \\begin{array}{ccccc}\n1 & * & * & * & * \\\\ 0 & 1 & * & * & *  \\\\ 0 & 0 & 0 & 1 & * \\\\ 0 & 0 & 0 & 0 & 1  \n\\end{array}\\right]\n\\end{matrix}\n\\]\n일관성 없는 시스템의 대표적인 특징은 RREF에 가장 오른쪽 열에 피벗(\\(1\\))이 있는 행이 있다는 것입니다. 이러한 행은 \\(0=1\\) 방정식을 나타냅니다. 이제 계수 행렬 \\(A\\)의 RREF에 모든 항목이 0인 행이 하나 이상 포함되어 있으면 \\(AX=B\\) 시스템이 불일치할 수 있다는 것을 알 수 있습니다.\n이 아이디어를 통해 해의 존재에 대한 일반적인 진술을 할 수 있습니다. A$가 모든 행에 피벗을 갖는다면 선형 시스템 \\(AX=B\\)는 모든 벡터 \\(B\\)에 대한 해를 갖습니다.\n\n\n예제 3: Sets of vectors that span a space\n두 가지 계수 행렬과 해당 계수 행렬의 RREF를 제공하여 가능성을 보여드리겠습니다. 아래 논의는 계수 행렬를 사용해서 논의하고 진행하고 있다는 점을 기억해야 합니다.\n\\[\n\\begin{matrix}\nP = \\left[ \\begin{array}{rrrr}\n1 & -2 & 4 & -2 \\\\ 4 & 3 & 5 & -4  \\\\ -3 & -2 & 4 & 2 \\\\  -4 & 1 & 1 & 1  \n\\end{array}\\right] \\hspace{0.75cm} \\to \\hspace{0.75cm}\n\\left[ \\begin{array}{rrrr}\n1 & 0 & 0 & 0 \\\\ 0 & 1 & 0 & 0  \\\\ 0 & 0 & 1 & 0 \\\\  0 & 0 & 0 & 1  \n\\end{array}\\right]\n\\end{matrix}\n\\]\n\\[\n\\begin{matrix}\nR = \\left[ \\begin{array}{rrrr}\n1 & 1 & 0 & -1 \\\\ 1 & 1 & 0 & 1  \\\\ -1 & -1 & 1 & -1 \\\\ 1 & 1 & -2 & 0   \n\\end{array}\\right] \\hspace{0.75cm} \\to \\hspace{0.75cm}\n\\left[ \\begin{array}{rrrr}\n1 & 1 & 0 & 0 \\\\ 0 & 0 & 1 & 0  \\\\ 0 & 0 & 0 & 1 \\\\  0 & 0 & 0 & 0  \n\\end{array}\\right]\n\\end{matrix}\n\\]\n\nP = np.array([[1,-2,4,-2],[4,3,5,-4],[-3,-2,4,2],[-4,1,1,1]])\nprint(ls.full_row_reduction(P), '\\n')\n\nR = np.array([[1,1,0,-1],[1,1,0,1],[-1,-1,1,-1],[1,1,-2,0]])\nprint(ls.full_row_reduction(R))\n\n[[1. 0. 0. 0.]\n [0. 1. 0. 0.]\n [0. 0. 1. 0.]\n [0. 0. 0. 1.]] \n\n[[1. 1. 0. 0.]\n [0. 0. 1. 0.]\n [0. 0. 0. 1.]\n [0. 0. 0. 0.]]\n\n\n\\(PX=B\\) 시스템은 모든 행에 피벗이 있기 때문에 \\(\\mathbb{R}^4\\)의 모든 \\(B\\)에 대한 해를 갖습니다. 어떤 \\(B\\)가 주어지더라도 \\(PX=B\\) 시스템은 항상 일관성이 있습니다. 이와 대조적으로, \\(RX=B\\) 시스템은 일부 \\(B\\)에 대한 해를 갖지만, 모든 \\(B\\)에 대한 해는 \\(\\mathbb{R}^4\\)에 없습니다. \\(P\\)의 열의 범위는 \\(\\mathbb{R}^4\\) 공간의 모든 벡터를 포함합니다. 이 경우 \\(P\\)의 열은 공간 \\(\\mathbb{R}^4\\) 에 걸쳐있다고 말합니다."
  },
  {
    "objectID": "11_Linear_Combinations.html#subspaces",
    "href": "11_Linear_Combinations.html#subspaces",
    "title": "선형 결합",
    "section": "Subspaces",
    "text": "Subspaces\n벡터공간의 부분공간을 고려하는 것은 종종 유용합니다.간단하게 부분공간이라고 부릅니다. 부분 공간 은 벡터공간의 일부분으로, 부분공간에 있는 벡터의 선형 조합은 다른 벡터도 부분공간에 있다는 특성을 가집니다.\n공식적으로 표현하자면, \\(V_1\\)과 \\(V_2\\)가 주어진 부분공간에 속하는 벡터이고 \\(c_1\\)과 \\(c_2\\)가 스칼라라면, 벡터 \\(c_1V_1 + c_2V_2\\)도 부분공간에 속합니다.\n\nSubspace 예제\n중간 성분이 \\(0\\)인 \\(\\mathbb{R}^3\\)의 벡터 집합은 \\(\\mathbb{R}^3\\)의 부분공간입니다. 그 이유를 이해하기 위해서는 부분공간에 있는 두 임의의 벡터의 임의의 선형 조합을 살펴보고, 그 선형 조합이 부분공간에도 있는지 확인해야 합니다.\n\\(X\\)와 \\(Y\\)를 임의의 첫 번째와 세 번째 성분을 가진 벡터로 두고 선형 조합을 계산하면 선형 조합도 중간 성분이 \\(0\\)이므로 같은 공간에 있음을 알 수 있습니다.\n\\[\n\\begin{matrix}\nc_1X + c_2Y =\nc_1\\left[ \\begin{array}{c} x_1 \\\\ 0 \\\\ x_3 \\end{array}\\right]+\nc_2\\left[ \\begin{array}{c} y_1 \\\\ 0 \\\\ y_3  \\end{array}\\right] =\n\\left[ \\begin{array}{c} x_1+y_1 \\\\ 0 \\\\ x_3+y_3 \\end{array}\\right]\n\\end{matrix}\n\\]\n\n\nSubspace 반례\n다음 선형 시스템의 모든 해의 집합은 \\(\\mathbb{R}^3\\)의 부분공간이 아닌 집합입니다.\n\\[\n\\begin{matrix}\n\\left[ \\begin{array}{r} 2 & 1 & 2  \\\\ 3 & 0 & -1 \\end{array}\\right]\n\\left[ \\begin{array}{r} x_1 \\\\ x_2 \\\\ x_3 \\end{array}\\right]=\n\\left[ \\begin{array}{r} 0 \\\\ 2 \\end{array}\\right]\n\\end{matrix}\n\\]\n\nA_augmented = np.array([[2,1,2,0],[3,0,-1,2]])\nA_augmented_reduced = ls.full_row_reduction(A_augmented)\nprint(A_augmented_reduced)\n\n[[ 1.          0.         -0.33333333  0.66666667]\n [ 0.          1.          2.66666667 -1.33333333]]\n\n\n이 시스템에서 \\(x_3\\)은 자유 변수입니다. \\(x_3\\)의 두 값을 선택하면 두 개의 서로 다른 해 벡터를 얻을 수 있으며, 이를 \\(X_p\\)와 \\(X_q\\)라고 부릅니다.\n\\[\n\\begin{matrix}\nX_p = \\left[ \\begin{array}{r} 1 \\\\ -4 \\\\ 1 \\end{array}\\right] \\hspace{1cm}\nX_q\\left[ \\begin{array}{r} 2 \\\\ -12 \\\\ 4   \\end{array}\\right] \\hspace{1cm}\n\\end{matrix}\n\\]\n이 두 벡터의 합이 시스템에 대한 해가 아니라는 것은 쉽게 확인할 수 있습니다.\n\\[\n\\begin{matrix}\nX_p + X_q = \\left[ \\begin{array}{r} 3 \\\\ -16 \\\\ 5   \\end{array}\\right]\n\\hspace{2cm}\n\\left[ \\begin{array}{r} 2 & 1 & 2  \\\\ 3 & 0 & -1 \\end{array}\\right]\n\\left[ \\begin{array}{r} 3 \\\\ -16 \\\\ 5 \\end{array}\\right]=\n\\left[ \\begin{array}{r} 0 \\\\ 4 \\end{array}\\right]\n\\end{matrix}\n\\]\n사실, 일반적으로 \\(A\\)가 \\(m \\times n\\) 행렬인 경우, \\(AX=B\\) 시스템에 대한 해는 \\(R^m\\)의 부분공간을 형성하지 않는다는 것은 사실입니다. 만약 \\(X_p\\)와 \\(X_q\\)가 시스템에 대한 두 개의 특정 해(\\(AX_p=B\\)와 \\(AX_q=B\\))라면, \\(A(X_p + X_q) = AX_p + AX_q = B + B = 2B\\)이므로 이들의 합은 해가 아닙니다(\\(B=0\\)일 때 \\(2B=B\\)이므로, \\(AX=0\\)에 대한 해의 집합은 부분공간을 형성한다는 것에 유의하세요. 이 중요한 예외는 다음에서 설명합니다.)\n\n\nSpans and subspaces\n모든 벡터 집합의 스팬은 반드시 부분 공간이어야 하므로 부분 공간의 개념은 스팬의 개념과 관련이 있습니다. 벡터 \\(X\\)와 \\(Y\\)가 \\(\\{V_1, V_2, V_3, ... V_n\\}\\)의 범위에 있는 벡터라고 가정합니다. 즉, \\(X = a_1V_1 + a_2V_2 + a_3V_3 + .... + a_nV_n\\) 및 $Y = b_1V_1 + b_2V_2 + b_3V_3 + …. $ 가중치 \\(a_1, a_2, ... a_n\\) 및 \\(b_1, b_2, ... b_n\\)의 일부 집합에 대해 \\(b_1V_1 + b_nV_n\\)입니다. 임의의 선형 조합 \\(c_1X + c_2Y\\) 역시 \\(\\{V_1, V_2, V_3, ... V_n\\}\\)의 범위에 있으므로 이 벡터들의 다른 선형 조합입니다.\n\\[\n\\begin{matrix}\nc_1X + c_2Y & = & c_1(a_1V_1 + a_2V_2 + a_3V_3 + .... + a_nV_n) + c_2(b_1V_1 + b_2V_2 + b_3V_3 + .... + b_nV_n)\\\\\n& = & (c_1a_1 + c_2b_1)V_1 + (c_1a_2 + c_2b_2)V_2 + (c_1a_3 + c_2b_3)V_3 + .... + (c_1a_n + c_2b_n)V_n\n\\end{matrix}\n\\]\n또한 모든 부분 공간은 어떤 벡터 집합의 범위로 설명할 수 있다는 것도 사실입니다. 이 개념을 살펴보겠습니다."
  },
  {
    "objectID": "11_Linear_Combinations.html#column-space",
    "href": "11_Linear_Combinations.html#column-space",
    "title": "선형 결합",
    "section": "Column space",
    "text": "Column space\n모든 \\(m \\times n\\) 행렬 \\(A\\)에는 선형 시스템 \\(AX=B\\)의 가능한 해를 이해하는 데 중요한 네 가지 기본 하위 공간이 연관되어 있습니다. 여기서는 열 공간이라고 하는 이러한 하위 공간 중 첫 번째 공간을 살펴보겠습니다.\n\n행렬 \\(A\\)의 열 공간은 행렬 \\(A\\)의 열들의 스팬으로 정의됩니다. 우리는 \\(A\\)의 열을 \\(\\mathbb{R}^m\\)의 벡터로 생각하므로, \\(A\\)의 열 공간은 \\(\\mathbb{R}^m\\)의 부분공간을 형성합니다. 열 공간을 나타낼 때 \\(\\mathcal{C}(A)\\)라는 표기법을 사용합니다.\n\\(X\\)가 \\(\\mathbb{R}^n\\)의 벡터라면, 행렬-벡터 곱 \\(AX\\)는 \\(\\mathbb{R}^m\\)의 벡터입니다. 이 곱이 \\(A\\)의 열을 선형적으로 조합하여 형성된다는 것을 상기하면, 벡터 \\(AX\\)는 정의상 \\(\\mathcal{C}(A)\\)여야 한다는 것을 알 수 있습니다. 여기서 중요한 연관성은 선형 시스템 \\(AX=B\\)는 벡터 \\(B\\)가 \\(\\mathcal{C}(A)\\)에 있는 경우에만 일관성이 있다는 것입니다.\n\n컬럼 공간의 개념이 실제로 특정 시스템을 푸는 데 도움이 되지는 않지만, 보다 추상적인 수준에서 문제를 논의할 수 있는 능력을 향상시켜 줍니다. 예를 들어, 이제 스팬의 정의와 앞서 논의한 내용을 통합하여 모든 시스템에 적용되는 광범위한 진술을 할 수 있습니다. A$가 \\(m \\times n\\) 행렬이라면, \\(\\mathcal{C}(A) = \\mathbb{R}^m\\)인 경우에만 \\(AX=B\\) 시스템은 \\(\\mathbb{R}^m\\)의 모든 \\(B\\)에 대해 일관성이 있습니다. 이러한 결론은 실용적인 의미를 갖는 추가 아이디어를 개발하는 데 매우 중요합니다."
  },
  {
    "objectID": "06_Applications_LS.html",
    "href": "06_Applications_LS.html",
    "title": "연립선형방정식의 응용",
    "section": "",
    "text": "선형 시스템을 풀어야 할 필요성은 다양한 분야에서 발생합니다. 선형 시스템의 예를 보여드리겠습니다. 또한 행렬 대수를 암호화와 그래프 이론에 적용하는 방법에 대해서도 설명합니다."
  },
  {
    "objectID": "06_Applications_LS.html#interpolation",
    "href": "06_Applications_LS.html#interpolation",
    "title": "연립선형방정식의 응용",
    "section": "Interpolation",
    "text": "Interpolation\n보간은 알려진 값 사이에 있는 미지의 데이터 값을 추정하는 프로세스입니다. 이 프로세스에는 일반적으로 알려진 데이터 포인트 집합을 통해 곡선을 피팅하여 미지의 값을 예측하는 작업이 포함됩니다. 곡선은 일련의 매개변수로 설명되며, ’곡선을 맞추는 것’은 곡선이 데이터를 가장 잘 나타내도록 매개변수를 선택하는 것을 의미합니다. 곡선을 맞추는 간단한 방법은 곡선이 제공된 모든 데이터를 통과하도록 하는 것입니다.\n데이터 포인트 \\((2,8)\\), \\((5,12)\\), \\((6,14)\\) 및 \\((15,15)\\)를 예로 들어 보겠습니다.\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport linear_solver as ls\n\nx = np.array([2,5,6,15])\ny = np.array([8,12,14,15])\n\nfig,ax = plt.subplots()\nax.scatter(x,y,color='red');\n\nax.set_xlim(0,20);\nax.set_ylim(0,20);\nax.set_xlabel('x');\nax.set_ylabel('y');\nax.grid(True)\n\n\n\n\n다항식은 보간에 사용되는 일반적인 곡선입니다. 이 경우 데이터 포인트가 4개이므로 그래프가 각 포인트를 통과하기 위해 충족해야 하는 방정식이 4개가 있습니다. 방정식을 만족하는 매개변수가 4개이므로 3차 다항식인 \\(P_3\\)을 선택합니다.\n\\[\n\\begin{matrix}\nP_3(x) = a_0 + a_1x + a_2x^2 + a_3x^3\n\\end{matrix}\n\\]\n데이터는 \\(P_3(2) = 8\\), \\(P_3(5) = 12\\), \\(P_3(6) = 14\\), \\(P_3(15) = 15\\)의 네 가지 방정식을 제공합니다. 이 방정식 집합은 미지 계수에 대한 선형 시스템입니다.\n\\[\n\\begin{matrix}\na_0 + 2a_1 + 2^2a_2 + 2^3a_3 & = & 8\\\\\na_0 + 5a_1 + 5^2a_2 + 5^3a_3 & = & 12\\\\\na_0 + 6a_1 + 6^2a_2 + 6^3a_3 & = & 14\\\\\na_0 + 15a_1 + 15^2a_2 + 15^3a_3 & = & 15\n\\end{matrix}\n\\]\n행렬 \\(A\\)와 오른쪽 벡터 \\(B\\)를 NumPy 배열로 조합합니다.\n\nA = np.zeros((4,4))\nB = np.zeros((4,1))\n\nfor i in range(4):\n    B[i,0] = y[i]\n    for j in range(4):\n        A[i,j] = x[i]**(j)\n        \nprint(A,'\\n')\nprint(B)\n\n[[1.000e+00 2.000e+00 4.000e+00 8.000e+00]\n [1.000e+00 5.000e+00 2.500e+01 1.250e+02]\n [1.000e+00 6.000e+00 3.600e+01 2.160e+02]\n [1.000e+00 1.500e+01 2.250e+02 3.375e+03]] \n\n[[ 8.]\n [12.]\n [14.]\n [15.]]\n\n\n이제 제거를 통해 \\(AX=B\\) 시스템을 풀 수 있습니다. x$ 변수와 혼동을 피하기 위해, 다항식의 계수를 나타내므로 해의 이름을 coeffs로 지정하겠습니다.\n\ncoeffs = ls.solve_system(A,B)\nprint(coeffs)\n\n[[ 8.64102564]\n [-1.25555556]\n [ 0.52222222]\n [-0.02735043]]\n\n\n마지막으로 데이터 위에 다항식 그래프를 그려서 적합도를 확인합니다.\n\nx_fit = np.linspace(x[0],x[3],50)\ny_fit = coeffs[0] + coeffs[1]*x_fit + coeffs[2]*x_fit**2 + coeffs[3]*x_fit**3\n\nfig,ax = plt.subplots()\n\nax.scatter(x,y,color='red');\nax.plot(x_fit,y_fit,'b');\nax.set_xlim(0,20);\nax.set_ylim(0,30);\nax.set_xlabel('x');\nax.set_ylabel('y');\nax.grid(True);\n\n\n\n\n우리가 생성하는 곡선이 실제로 각 데이터 포인트를 통과하지만, 이 다항식은 기본 프로세스의 최상의 모델이 아닐 수 있습니다. 한 가지 잠재적인 우려는 곡선이 세 번째와 네 번째 데이터 요소를 직접 연결하는 것이 아니라 진동을 나타내는 것처럼 보인다는 것입니다. 데이터 포인트 집합에 맞는 곡선을 만들 때 단순히 곡선이 각 포인트를 통과하도록 하는 것보다 더 중요한 다른 요소가 있을 수 있습니다."
  },
  {
    "objectID": "04_Inverse_Matrices.html",
    "href": "04_Inverse_Matrices.html",
    "title": "역행렬",
    "section": "",
    "text": "행렬 형식으로 작성된 연립 선형 방정식에 대해서 다시 한 번 생각해보도록 하겠습니다.\n\\[\nAX = B\n\\]\n다시 말하지만, \\(A\\)는 계수행렬이고, \\(B\\)는 미지수 벡터이며, \\(X\\)는 상수 벡터입니다. 만약 \\(A\\), \\(B\\), \\(X\\)가 숫자로만 이루어진다면, 우리는 \\(X\\)를 해결하는 방법이 방정식의 양변을 \\(A\\)로 나누는 것임을 즉시 알 수 있습니다(\\(A\\neq 0\\)이면). 이 시스템에 대해 자연스럽게 던질 수 있는 질문은 “행렬 나누기를 정의할 수 있는가?”입니다.\n대부분이 아는 것 처럼 당연히 아니다 입니다. 하지만 \\(A\\), \\(B\\), \\(X\\)가 숫자인 경우 \\(1/A\\)를 곱하면 해를 구할 수 있다는 점을 이해하면 진전을 이룰 수 있습니다. 이 미묘한 차이가 중요한 이유는 나눗셈을 정의할 필요가 없다는 것을 의미하기 때문입니다. 우리는 \\(A\\)를 곱하면 1이 되는 숫자만 찾으면 됩니다. 이 숫자를 \\(A\\)의 곱셈 역수라고 하며, \\(A\\neq 0\\)인 경우 \\(1/A\\)로 표기합니다.\n이 아이디어를 \\(A\\), \\(B\\), \\(X\\)가 행렬인 상황으로 확장할 수 있습니다. \\(AX=B\\) 시스템을 풀기 위해 \\(A\\)를 곱하면 행렬 \\(I\\)가 되는 특정 행렬을 곱하고 싶습니다. 이 행렬을 역행렬이라고 하며, 기호는 \\(A^{-1}\\)입니다.\n\\(A\\)가 정방행렬인 경우 \\(A^{-1}\\)(“A의 역행렬, A inverse”으로 읽음)를 다음이 참인 행렬로 정의합니다.\n\\[\nA^{-1}A = I \\hspace{3cm}AA^{-1} = I\n\\]"
  },
  {
    "objectID": "04_Inverse_Matrices.html#역행렬의-구성",
    "href": "04_Inverse_Matrices.html#역행렬의-구성",
    "title": "역행렬",
    "section": "역행렬의 구성",
    "text": "역행렬의 구성\n\\(C\\)를 예제를 통해서 역행렬을 어떻게 만들 수 있는지 생각해 보겠습니다.\n\\[\nC = \\left[ \\begin{array}{rrrr} 1 & 0 & 2 & -1 \\\\ 3 & 1 & -3 & 2 \\\\ 2 & 0 & 4 & 4 \\\\ 2 & 1 & -1 & -1 \\end{array}\\right]\n\\]\n행렬 곱 \\(CC^{-1}= I\\)를 \\(C^{-1}\\)의 열에 대해 생각해 봅시다. 예를 들어 세 번째 열에 초점을 맞추고, 알 수 없는 항목에는 \\(y_i\\)로 레이블을 지정합니다. 알 수 없는 * 항목도 있지만 지금은 무시하겠습니다.\n\\[\nCC^{-1}=\n\\left[ \\begin{array}{rrrr} 1 & 0 & 2 & -1 \\\\ 3 & 1 & -3 & 2 \\\\ 2 & 0 & 4 & 4 \\\\ 2 & 1 & -1 & -1 \\end{array}\\right]\n\\left[ \\begin{array}{rrrr} * & * & y_1& * \\\\ * & * & y_2 & * \\\\ * & * & y_3 & * \\\\ * & * & y_4 & *  \\end{array}\\right]=\n\\left[ \\begin{array}{rrrr} 1 & 0 & 0 & 0 \\\\ 0 & 1 & 0 & 0 \\\\ 0 & 0 & 1 & 0 \\\\ 0 & 0 & 0 & 1 \\end{array}\\right]=\nI\n\\]\n이제 \\(C\\)에 \\(C^{-1}\\)의 세 번째 열을 곱하면 \\(I\\)의 세 번째 열이 나온다는 것을 기억하세요. 이렇게 하면 \\(y_i\\)를 풀 수 있는 선형 시스템이 생깁니다.\n\\[\n\\left[ \\begin{array}{rrrr} 1 & 0 & 2 & -1 \\\\ 3 & 1 & -3 & 2 \\\\ 2 & 0 & 4 & 4 \\\\ 2 & 1 & -1 & -1 \\end{array}\\right]\n\\left[ \\begin{array}{r}  y_1 \\\\  y_2  \\\\ y_3 \\\\ y_4  \\end{array}\\right]=\n\\left[ \\begin{array}{r}  0 \\\\  0  \\\\ 1 \\\\ 0  \\end{array}\\right]\n\\]\n\nimport numpy as np\nimport linear_solver as ls\n\n\n## Solve CY = I3\nC = np.array([[1,0,2,-1],[3,1,-3,2],[2,0,4,4],[2,1,-1,-1]])\nI3 = np.array([[0],[0],[1],[0]])\nY3 = ls.solve_system(C,I3)\nprint(Y3)\n\n[[-0.16666667]\n [ 0.66666667]\n [ 0.16666667]\n [ 0.16666667]]\n\n\n\\(C^{-1}\\)의 다른 열은 동일성 행렬의 해당 열로 유사한 시스템을 풀면 찾을 수 있습니다. 그런 다음 열을 하나의 행렬로 조합하여 \\(C^{-1}\\)를 만들고, \\(C^{-1}C\\)와 \\(CC^{-1}\\)의 곱을 확인하여 결과를 테스트할 수 있습니다.\n\nI1 = np.array([[1],[0],[0],[0]])\nI2 = np.array([[0],[1],[0],[0]])\nI4 = np.array([[0],[0],[0],[1]])\n\nY1 = ls.solve_system(C,I1)\nY2 = ls.solve_system(C,I2)\nY4 = ls.solve_system(C,I4)\n\nC_inverse = np.hstack((Y1,Y2,Y3,Y4))\nprint(\"C inverse:\\n\",C_inverse,'\\n',sep='')\nprint(\"C inverse times C:\\n\",C_inverse@C,'\\n',sep='')\nprint(\"C times C inverse:\\n\",C@C_inverse,sep='')\n\nC inverse:\n[[ 0.83333333  0.5        -0.16666667 -0.5       ]\n [-2.08333333 -1.25        0.66666667  2.25      ]\n [-0.08333333 -0.25        0.16666667  0.25      ]\n [-0.33333333  0.          0.16666667  0.        ]]\n\nC inverse times C:\n[[ 1.00000000e+00  0.00000000e+00 -1.11022302e-16  1.11022302e-16]\n [ 0.00000000e+00  1.00000000e+00  0.00000000e+00  4.44089210e-16]\n [ 5.55111512e-17  0.00000000e+00  1.00000000e+00 -5.55111512e-17]\n [ 0.00000000e+00  0.00000000e+00  0.00000000e+00  1.00000000e+00]]\n\nC times C inverse:\n[[ 1.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00]\n [-1.11022302e-16  1.00000000e+00  5.55111512e-17  0.00000000e+00]\n [ 0.00000000e+00  0.00000000e+00  1.00000000e+00  0.00000000e+00]\n [-3.33066907e-16  0.00000000e+00  1.11022302e-16  1.00000000e+00]]\n\n\n반올림 오류로 인해 0이 되어야 하는 일부 항목이 정확히 0이 아닙니다.\n\nprint(np.round(C@C_inverse,8))\n\n[[ 1.  0.  0.  0.]\n [-0.  1.  0.  0.]\n [ 0.  0.  1.  0.]\n [-0.  0.  0.  1.]]\n\n\n다음으로 행렬의 역을 계산하는 파이썬 함수를 작성해 보겠습니다. 실제로 행렬의 역을 구하는 것은 선형 시스템을 푸는 매우 비효율적인 방법입니다. 행렬의 역을 구하기 위해 \\(n\\)개의 시스템을 풀어야 하므로, 제거를 통해 시스템을 풀 때보다 \\(n\\)배의 작업량이 소요되는 것으로 보입니다. 그러나 다양한 벡터 \\(B\\)에 대한 선형 시스템 \\(AX=B\\)를 풀어야 하지만 계수 행렬 \\(A\\)는 동일하다고 가정해 보겠습니다. 이 경우 \\(A^{-1}\\)를 구성하는 것이 매력적으로 보일 수 있습니다.\n계산의 효율성을 높이기 위해 행 연산의 반복을 최대한 피하고 싶습니다. \\(A^{-1}\\)를 구성하기 위해서는 \\(AX_i=Y_i\\) 시스템을 풀어야 하는데, 여기서 \\(Y_i\\)는 \\(I\\)의 \\(i\\)번째 열입니다. 이렇게 하면 \\(A^{-1}\\)의 \\(i\\)번째 열인 \\(X\\)가 생성됩니다. 증강된 각 행렬 \\([A|Y_i]\\)에서 제거를 수행하는 대신, 전체 행렬 \\(I\\)로 \\(A\\)를 증강하고 모든 \\(Y_i\\)에 필요한 연산을 동시에 수행할 수 있습니다. 예를 들어 \\(A\\)가 \\(4 \\times 4\\) 행렬인 경우 다음과 같은 증강 행렬을 갖게 됩니다.\n\\[\n\\begin{matrix}\n[A|I] = \\left[ \\begin{array}{rrrr|rrrr}\n* & * & * & * & 1 & 0 & 0 & 0 \\\\\n* & * & * & * & 0 & 1 & 0 & 0 \\\\\n* & * & * & * & 0 & 0 & 1 & 0 \\\\\n* & * & * & * & 0 & 0 & 0 & 1 \\\\\n\\end{array}\\right]\n\\end{matrix}\n\\]\n\\(A\\)가 역행렬이 가능한 경우, texttt{row_reduction} 루틴은 다음 형식의 행렬을 반환해야 합니다.\n\\[\n\\begin{matrix}\n[A|I] = \\left[ \\begin{array}{rrrr|rrrr}\n* & * & * & * & * & * & * & * \\\\\n0 & * & * & * & * & * & * & * \\\\\n0 & 0 & * & * & * & * & * & * \\\\\n0 & 0 & 0 & * & * & * & * & * \\\\\n\\end{array}\\right]\n\\end{matrix}\n\\]\n그런 다음 이 행렬의 오른쪽 절반에 있는 각 열에 대해 back_substitution 함수를 한 번씩 호출하면 됩니다.\n\nprint(ls.inverse(C))\n\n[[ 0.83333333  0.5        -0.16666667 -0.5       ]\n [-2.08333333 -1.25        0.66666667  2.25      ]\n [-0.08333333 -0.25        0.16666667  0.25      ]\n [-0.33333333  0.          0.16666667  0.        ]]\n\n\n역행렬이 불가능한 행렬이라면 위의 과정은 실패합니다. 우리는 back_substitution 루틴 내에서 위쪽 삼각형 행렬의 주 대각선을 따른 항목으로 나눈다는 것을 깨달아야 합니다. 이 항목들이 매우 중요한 피벗 위치에 있다는 것을 기억하세요. 하나 이상의 피벗 위치에 0이 있으면 원래 행렬은 반전할 수 없는 행렬입니다.\n예를 들어 inverse 루틴에서 증강 행렬 \\([A|I]\\)에 대해 row_reduction을 수행한 후 결과가 다음과 같다고 가정해 보겠습니다.\n\\[\n\\begin{equation}\n[A|I] = \\left[ \\begin{array}{rrrr|rrrr}\n* & * & * & * & * & * & * & * \\\\\n0 & 0 & * & * & * & * & * & * \\\\\n0 & 0 & * & * & * & * & * & * \\\\\n0 & 0 & 0 & * & * & * & * & * \\\\\n\\end{array}\\right]\n\\end{equation}\n\\]\n이 경우 두 번째 행의 피벗 위치에 0이 있기 때문에 back_substitution은 실패합니다. 따라서 \\(A^{-1}\\) 는 존재하지 않으며 \\(A\\)는 역행렬이 존재하지 않는다는 사실을 알게 됩니다.\n일반적으로 주어진 행렬의 역행렬이 가능한지 여부는 제거 단계를 수행하고 해당 위쪽 삼각형 행렬의 주 대각선에 있는 항목을 검사하여 결정합니다."
  },
  {
    "objectID": "04_Inverse_Matrices.html#scipy를-사용한-역행렬-계산",
    "href": "04_Inverse_Matrices.html#scipy를-사용한-역행렬-계산",
    "title": "역행렬",
    "section": "SciPy를 사용한 역행렬 계산",
    "text": "SciPy를 사용한 역행렬 계산\n\nimport scipy.linalg as sla\n\nC_inverse = sla.inv(C)\nprint(C_inverse)\n\n[[ 0.83333333  0.5        -0.16666667 -0.5       ]\n [-2.08333333 -1.25        0.66666667  2.25      ]\n [-0.08333333 -0.25        0.16666667  0.25      ]\n [-0.33333333  0.          0.16666667  0.        ]]"
  },
  {
    "objectID": "02_Gaussian_Elimination.html",
    "href": "02_Gaussian_Elimination.html",
    "title": "가우스 소거법",
    "section": "",
    "text": "연립 선형방정식을 푸는 데 도움이 되는 몇 가지 파이썬 함수를 사용하여, 가우스 소거법(Gaussian Elimination)에 대해서 알아보겠습니다. 가우스 소거법의 핵심은 해를 보존하면서 점차적으로 해에 더 쉽게 접근할 수 있도록 하는 행 연산이라는 일련의 단계를 적용하는 것 입니다. 기본 행 연산은 세 가지가 있습니다. 1. 두 방정식의 위치 교환하기(interchange) 2. 방정식에 0이 아닌 숫자를 곱하기(scaling) 3. 특정 행을 자기 자신과 다른 행의 배수 배를 합한 것으로 교체(replacement)"
  },
  {
    "objectID": "02_Gaussian_Elimination.html#예제-1-row-operations-and-elimination",
    "href": "02_Gaussian_Elimination.html#예제-1-row-operations-and-elimination",
    "title": "가우스 소거법",
    "section": "예제 1: Row operations and elimination",
    "text": "예제 1: Row operations and elimination\n\n(이건명 2020), p64.\n\n예를 들어 보겠습니다.\n\\[\n\\begin{matrix}\n2x_1 + 2x_2 + 4x_3 & = & 18 \\\\\nx_1 + 3x_2 + 2x_3 & = & 13 \\\\\n3x_1 + x_2 + 3x_3 & = & 14\n\\end{matrix}\n\\]\n첫 번째 방정식과 마지막 방정식을 바꿀 수 있습니다.\n\\[\n\\begin{matrix}\n3x_1 + x_2 + 3x_3 & = & 14 \\\\\nx_1 + 3x_2 + 2x_3 & = & 13 \\\\\n2x_1 + 2x_2 + 4x_3 & = & 18 \\\\\n\\end{matrix}\n\\]\n또는 첫 번째 방정식에 \\(5\\)를 곱할 수 있습니다.\n\\[\n\\begin{matrix}\n(2 \\times 5)x_1 + (2 \\times 5)x_2 + (4 \\times 5)x_3 & = & 18 \\\\\nx_1 + 3x_2 + 2x_3 & = & 13 \\\\\n3x_1 + x_2 + 3x_3 & = & 14\n\\end{matrix}\n\\]\n또는 첫번째 방정식에 두번째 방정식의 \\(2\\)배를 곱하고 뺄 수도 있습니다.\n\\[\n\\begin{matrix}\nx_1 - 4x_2 + x_3 & = & -8 \\\\\nx_1 + 3x_2 + 2x_3 & = & 13 \\\\\n3x_1 + x_2 + 3x_3 & = & 14\n\\end{matrix}\n\\]\n마지막 연산이 가장 중요한 이유는 방정식 중 하나에서 변수를 ’제거’할 수 있기 때문입니다. 세 번째 방정식에는 더 이상 \\(x_2\\) 항이 포함되어 있지 않다는 점에 유의하세요. 이것이 ’가우스 소거법’의 핵심입니다.\n계산을 위해 변수 이름과 “=” 기호를 생략하고 실제 숫자를 모두 배열로 정렬할 수 있습니다.\n\\[\n\\begin{matrix}\n\\left[ \\begin{array}{ccc|c} 2 & 2 & 4 & 18 \\\\ 1 & 3 & 2 & 13 \\\\ 3 & 1 & 3 & 14 \\end{array}\\right]\n\\end{matrix}\n\\]\n이제 이 값으로 NumPy 배열을 만들어 보겠습니다. 나중에 참조할 수 있도록 배열에 \\(\\texttt{A}\\)라는 이름을 지정하겠습니다.\n\nimport numpy as np\nA=np.array([[2,2,4,18],[1,3,2,13],[3,1,3,14]])\n\n기본 행 연산을 수행할 수 있는 간단한 함수를 작성하도록 하겠습니다.\n\ndef row_swap(A,k,l):\n    m = A.shape[0]\n    n = A.shape[1]\n    \n    B = np.copy(A).astype('float64')\n        \n    for j in range(n):\n        temp = B[k][j]\n        B[k][j] = B[l][j]\n        B[l][j] = temp\n        \n    return B\n\ndef row_scale(A,k,scale):\n    m = A.shape[0]\n    n = A.shape[1]\n    \n    B = np.copy(A).astype('float64')\n\n    for j in range(n):\n        B[k][j] *= scale\n        \n    return B\n\ndef row_add(A,k,l,scale):\n    m = A.shape[0]\n    n = A.shape[1]\n    \n    B = np.copy(A).astype('float64')\n        \n    for j in range(n):\n        B[l][j] += B[k][j]*scale\n        \n    return B\n\n이제 row_swap, row_scale, row_add라는 세 가지 새로운 함수가 생겼습니다. 이 함수를 사용해 어떤 결과가 나오는지 살펴봅시다.\n\nB1 = row_scale(A,0,1/2)\nB2 = row_add(A,1,0,-2)\nB3 = row_swap(A,0,2)\n\n\nprint(A,'\\n')\nprint(B1,'\\n')\nprint(B2,'\\n')\nprint(B3,'\\n')\n\n[[ 2  2  4 18]\n [ 1  3  2 13]\n [ 3  1  3 14]] \n\n[[ 1.  1.  2.  9.]\n [ 1.  3.  2. 13.]\n [ 3.  1.  3. 14.]] \n\n[[ 0. -4.  0. -8.]\n [ 1.  3.  2. 13.]\n [ 3.  1.  3. 14.]] \n\n[[ 3.  1.  3. 14.]\n [ 1.  3.  2. 13.]\n [ 2.  2.  4. 18.]] \n\n\n\n가우스 소거법의 목표는 행 연산을 수행하여 다음과 같은 구조의 행렬을 생성하는 것입니다.\n\\[\n\\begin{matrix}\n\\left[ \\begin{array}{ccc|c} 1 & * & * & * \\\\ 0 & 1 & * & * \\\\ 0 & 0 & 1 & * \\end{array}\\right]\n\\end{matrix}\n\\]\n(여기서  기호는 0 또는 1이 될 수도 있고 아닐 수도 있는 다양한 미지의 값을 나타냅니다.)*.\n행 연산을 수행하고 각 단계마다 새로운 이름을 붙인 배열로 진행 상황을 저장합니다. 예를 들어 \\(\\texttt{A1}\\), \\(\\texttt{A2}\\), \\(\\texttt{A3}\\) 등으로 이름을 지정할 수 있습니다. 이렇게 하면 진행 상황을 확인하거나 원하는 경우 돌아가서 코드를 변경할 수 있습니다.\n\nA1 = row_scale(A,0,1.0/2)\nprint(A1,'\\n')\nA2 = row_add(A1,0,1,-1)\nprint(A2,'\\n')\nA3 = row_add(A2,0,2,-3)\nprint(A3,'\\n')\nA4 = row_scale(A3,1,1.0/2)\nprint(A4,'\\n')\nA5 = row_add(A4,1,2,2)\nprint(A5,'\\n')\nA6 = row_add(A5,1,0,-1)\nprint(A6,'\\n')\nA7 = row_scale(A6,2,-(1.0/3))\nprint(A7,'\\n')\nA8 = row_add(A7,2,0,-2)\nprint(A8,'\\n')\n\n[[ 1.  1.  2.  9.]\n [ 1.  3.  2. 13.]\n [ 3.  1.  3. 14.]] \n\n[[ 1.  1.  2.  9.]\n [ 0.  2.  0.  4.]\n [ 3.  1.  3. 14.]] \n\n[[  1.   1.   2.   9.]\n [  0.   2.   0.   4.]\n [  0.  -2.  -3. -13.]] \n\n[[  1.   1.   2.   9.]\n [  0.   1.   0.   2.]\n [  0.  -2.  -3. -13.]] \n\n[[ 1.  1.  2.  9.]\n [ 0.  1.  0.  2.]\n [ 0.  0. -3. -9.]] \n\n[[ 1.  0.  2.  7.]\n [ 0.  1.  0.  2.]\n [ 0.  0. -3. -9.]] \n\n[[ 1.  0.  2.  7.]\n [ 0.  1.  0.  2.]\n [-0. -0.  1.  3.]] \n\n[[ 1.  0.  0.  1.]\n [ 0.  1.  0.  2.]\n [-0. -0.  1.  3.]] \n\n\n\n이제 행렬을 연립 선형 방정식 형태로 다시 표현하도록 하겠습니다.\n\\[\n\\begin{matrix}\nx_1 \\quad\\quad & = & 1 \\\\\n\\quad x_2 \\quad & = & 2 \\\\\n\\quad\\quad x_3 & = & 3 \\\\\n\\end{matrix}\n\\]"
  },
  {
    "objectID": "02_Gaussian_Elimination.html#예제-2-finding-pivots",
    "href": "02_Gaussian_Elimination.html#예제-2-finding-pivots",
    "title": "가우스 소거법",
    "section": "예제 2: Finding pivots",
    "text": "예제 2: Finding pivots\n마지막 예제의 코드는 배율을 계산하기 위해 나눈 배열의 항목 중 하나라도 0이 나타나면 실패합니다. 이러한 중요한 항목을 피벗이라고 하며, 행렬에서 해당 항목의 위치를 피벗 위치라고 합니다. 정의상 피벗은 0이 아니어야 합니다. 제거 단계에서 피벗 위치에 0이 발생하면 행의 순서를 바꿔서 0이 아닌 항목을 피벗 위치로 옮길 수 있습니다. 무작위 배열에서 작동하는 코드를 작성하기 전에 먼저 특정 배열에 대해 이 방법을 시도해 보겠습니다.\n\\[\n\\begin{matrix}\nx_1 - x_2 + x_3 & = & 3\\\\\n2x_1 - 2x_2 + 4x_3 & = & 8\\\\\n3x_1 \\quad\\quad -9x_3 & = & 0\n\\end{matrix}\n\\]\n\nG=np.array([[1,-1,1,3],[2,-2,4,8],[3,0,-9,0]])\nprint(G)\n\n[[ 1 -1  1  3]\n [ 2 -2  4  8]\n [ 3  0 -9  0]]\n\n\n\nG1 = row_add(G,0,1,-2)\nG2 = row_add(G1,0,2,-3)\nprint(G2)\n\n[[  1.  -1.   1.   3.]\n [  0.   0.   2.   2.]\n [  0.   3. -12.  -9.]]\n\n\n이제 중간 피벗 위치에 0이 있습니다. 제거를 계속하기 위해 중간 방정식과 마지막 방정식을 바꿀 수 있습니다.\n\nG3 = row_swap(G2,1,2)\nG4 = row_scale(G3,1,1./3)\nG5 = row_scale(G4,2,1./2)\nprint(G5)\n\n[[ 1. -1.  1.  3.]\n [ 0.  1. -4. -3.]\n [ 0.  0.  1.  1.]]\n\n\n시스템을 익숙한 방정식 집합으로 다시 작성합니다.\n\\[\n\\begin{matrix}\nx_1 - x_2 + x_3 & = & 3\\\\\nx_2 - 4x_3 & = & -3\\\\\nx_3 & = & 1\n\\end{matrix}\n\\]\n역치환을 적용하면 \\(x_2 = 1\\)과 \\(x_1=3\\)이 됩니다.\n행을 바꾸는 것은 수식을 정리하는데 사용한다는 것에 주목할 필요가 있습니다. 동치항을 제거하여 해를 깔끔하게 나타낼 수 있습니다.\n\nG3_alternative = row_scale(G2,1,1./2)\nG4_alternative = row_scale(G3_alternative,2,1./3)\nprint(G4_alternative)\n\n[[ 1. -1.  1.  3.]\n [ 0.  0.  1.  1.]\n [ 0.  1. -4. -3.]]\n\n\n생성된 배열은 방정식의 순서는 물론 다르지만 동일한 단순화된 시스템을 나타냅니다.\n\\[\n\\begin{matrix}\nx_1 - x_2 + x_3 & = & 3\\\\\nx_3 & = & 1 \\\\\nx_2 - 4x_3 & = & -3\n\\end{matrix}\n\\]"
  },
  {
    "objectID": "01_Linear_Systems.html",
    "href": "01_Linear_Systems.html",
    "title": "연립 선형 방정식과 해집합",
    "section": "",
    "text": "선형 방정식을 살펴보고 그 해를 구하는 방법 소개합니다."
  },
  {
    "objectID": "01_Linear_Systems.html#선형-연립방정식system-of-linear-equations-혹은-선형계linear-system",
    "href": "01_Linear_Systems.html#선형-연립방정식system-of-linear-equations-혹은-선형계linear-system",
    "title": "연립 선형 방정식과 해집합",
    "section": "선형 연립방정식(system of linear equations, 혹은 선형계(linear system))",
    "text": "선형 연립방정식(system of linear equations, 혹은 선형계(linear system))\n미지수 \\(x_1\\), \\(x_2\\), \\(\\cdots\\), \\(x_n\\)에 대해서 다음과 같은 1차식으로 작성된 방정식을 선형방정식(linear equation)이라고 합니다.\n\\[\n\\begin{split}\n\\begin{matrix}\na_1 x_1 + a_2 x_2 + \\cdots + a_n x_n = b\n\\end{matrix}\n\\end{split}\n\\]\n미지수 \\(x_1\\), \\(x_2\\), \\(x_3\\), … \\(x_n\\)이 있는 \\(m\\)개의 연립 선형방정식은 다음과 같은 형식 표현할 수 있습니다.\n\\[\n\\begin{split}\n\\begin{matrix}\na_{11}x_1 + a_{12}x_2 + \\hspace{0.5cm} ... \\hspace{0.5cm} + a_{1n}x_n & = & b_1 \\\\\na_{21}x_1 + a_{22}x_2 + \\hspace{0.5cm} ... \\hspace{0.5cm} + a_{2n}x_n & = & b_2 \\\\\n\\vdots \\hspace{1.2cm} \\vdots \\hspace{3cm} \\vdots \\hspace{0.5cm}  & = & \\vdots \\\\\na_{m1}x_1 + a_{m2}x_2 + \\hspace{0.5cm} ... \\hspace{0.5cm} +  a_{mn}x_n & = & b_m \\\\\n\\end{matrix}\n\\end{split}\n\\]\n연립 선형방정식의 해는 모든 방정식을 동시에 만족하는 미지수의 집합 입니다. 이런 미지수의 값 혹은 해를 모아둔 집합을 해집합이라고 합니다. 해를 갖지 않는 연립 선형방정식은 해가 없다(inconsistent)라고 하며, 적어도 하나의 해가 존재하면 모순이 없다(consistent)라고 합니다.\n두 개의 방정식과 두 개의 미지수가 있는 연립 선형방정식은 \\(x_1x_2\\) 좌표 평면에서 각 방정식을 만족하는 점의 집합을 쉽게 그래프로 그릴 수 있습니다. 연립 선형방정식의 해집합을 시각적으로 확인하기 위해서 간단한 그래프를 작성해보도록 하겠습니다."
  },
  {
    "objectID": "01_Linear_Systems.html#예제1-unique-solution",
    "href": "01_Linear_Systems.html#예제1-unique-solution",
    "title": "연립 선형 방정식과 해집합",
    "section": "예제1: unique solution",
    "text": "예제1: unique solution\n\\[\n\\begin{matrix}\nx_1 + x_2 - 2 & = & 0 \\\\\nx_1 - x_2 -1 & = & 0 \\\n\\end{matrix}\n\\]\n각 방정식의 해집합은 선으로 나타낼 수 있으며, 선형 시스템의 해집합은 두 선에 놓인 모든 점으로 나타낼 수 있습니다. 이 경우 선은 한 점에서 교차하며 두 방정식을 모두 만족하는 값은 한 쌍만 존재합니다.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n%config InlineBackend.figure_format = 'retina'\n\n\nx=np.linspace(-10,10,100)\n\n\nfig, ax = plt.subplots()\nax.plot(x,(2-x))\nax.plot(x,(1+x))\n\nax.text(1,1.6,'$x_1+x_2 -2 = 0$')\nax.text(-3,0.5,'$x_1-x_2 -1 = 0$')\n\nax.set_xlim(-4,4)\nax.set_ylim(-2,6)\nax.axvline(color='k',linewidth = 1)\nax.axhline(color='k',linewidth = 1)\n\nax.set_xticks(list(range(-4,5)))\nax.set_aspect('equal')\nax.grid(True,ls=':')"
  },
  {
    "objectID": "01_Linear_Systems.html#예제-2-no-solutions",
    "href": "01_Linear_Systems.html#예제-2-no-solutions",
    "title": "연립 선형 방정식과 해집합",
    "section": "예제 2: no solutions",
    "text": "예제 2: no solutions\n\\[\n\\begin{matrix}\nx_1 + 3x_2 & = & 5 \\\\\nx_1 + 3x_2 & = & 0 \\\\\n\\end{matrix}\n\\]\n두 방정식을 동시에 만족하는 해는 없습니다.\n\nfig, ax = plt.subplots()\nax.plot(x,(2*x-3))\nax.plot(x,(4*x-6)/2)\n\nax.text(1,1.6,'$2x_1-x_2 -3 = 0$')\nax.text(1,2.6,'$-4x_1+2x_2 +6 = 0$')\n\nax.set_xlim(-4,4)\nax.set_ylim(-4,4)\nax.axvline(color='k',linewidth = 1)\nax.axhline(color='k',linewidth = 1)\n\nax.set_xticks(list(range(-4,5)))\nax.set_aspect('equal')\nax.grid(True,ls=':')"
  },
  {
    "objectID": "01_Linear_Systems.html#예제-3-infinite-number-of-solutions",
    "href": "01_Linear_Systems.html#예제-3-infinite-number-of-solutions",
    "title": "연립 선형 방정식과 해집합",
    "section": "예제 3: infinite number of solutions",
    "text": "예제 3: infinite number of solutions\n\\[\n\\begin{matrix}\nx_1 + 3x_2 & = & 5 \\\\\n2x_1 + 6x_2 & = & 10 \\\\\n\\end{matrix}\n\\]\n마지막 예제에서 두 번째 방정식은 첫 번째 방정식의 배수입니다. 두 방정식의 해는 모두 같은 선으로 표시되므로 선의 모든 점이 선형 시스템의 해입니다.\n\nfig, ax = plt.subplots()\nax.plot(x,(1-x))\nax.plot(x,(1+x))\nax.plot(x,(-3+3*x))\n\nax.text(0,1,'$x_1+x_2 - 1 = 0$')\nax.text(-1,2,'$x_1-x_2 - 1= 0$')\nax.text(1.5,2,'$-x_1+3x_2 - 3 = 10$')\n\nax.set_xlim(-4,4)\nax.set_ylim(-2,6)\nax.axvline(color='k',linewidth = 1)\nax.axhline(color='k',linewidth = 1)\n\nax.set_xticks(list(range(-4,5)))\nax.set_aspect('equal')\nax.grid(True,ls=':')\n\n앞선 세 가지 예는 두 개의 미지수가 있는 연립 선형 방정식의 모든 유형의 해집합을 보여줍니다. 정확히 하나의 해가 있을 수도 있고, 해가 없을 수도 있으며, 해가 무한 할 수도 있습니다. 선형 시스템에 대한 기본적인 사실은 해집합이 이 세 가지 경우 중 하나라는 것입니다."
  },
  {
    "objectID": "03_Matrix_Algebra.html",
    "href": "03_Matrix_Algebra.html",
    "title": "행렬과 행렬연산",
    "section": "",
    "text": "행렬 A는 숫자의 2차원 배열입니다. NumPy를 사용하여 행렬로 계산할 때는 이전과 마찬가지로 배열을 사용하게 됩니다. 행렬의 몇 가지 모양은 아래와 같습니다.\n\\[\n\\begin{equation}\nA = \\left[ \\begin{array}{rr} 1 & 3 \\\\ 2 & 1 \\end{array}\\right] \\hspace{1cm}\nB = \\left[ \\begin{array}{rrr} 3 & 0 & 4 \\\\ -1 & -2 & 1 \\end{array}\\right] \\hspace{1cm}\nC = \\left[ \\begin{array}{rr} -2 & 1 \\\\ 4 & 1 \\end{array}\\right] \\hspace{1cm}\nD = \\left[ \\begin{array}{r} 2 \\\\ 6 \\end{array}\\right]\n\\end{equation}\n\\]\n행렬은 행과 열의 개수를 지정하여 행렬의 크기 또는 모양에 대해 이야기하는 것이 일반적입니다. 일반적으로 행의 개수가 먼저 나열됩니다. 이 예제에서 \\(A\\)와 \\(C\\)는 \\(2 \\times 2\\) 행렬이고, \\(B\\)는 \\(2 \\times 3\\) 행렬이며, \\(D\\)는 $ 2 $ 행렬입니다. \\(D\\)와 같이 열이 1개만 있는 행렬은 일반적으로 벡터라고 합니다.\n행렬의 개별 항목에 대해서도 이야기할 필요가 있습니다. 이에 대한 일반적인 표기법은 행렬에서 항목의 위치를 나타내기 위해 아래 첨자가 있는 소문자입니다. 따라서 \\(b_{12}\\)는 행렬 \\(B\\)의 첫 번째 행과 두 번째 열에 있는 0을 나타냅니다. 일반적인 위치에 대해 이야기하는 경우, \\(a_{ij}\\)와 같이 아래 첨자 안에 변수를 사용할 수 있습니다.\n\nimport numpy as np\n\nA = np.array([[1, 3],[2,1]])\nB = np.array([[3, 0, 4],[-1, -2, 1]])\nC = np.array([[-2, 1],[4, 1]])\nD = np.array([[2],[6]])\n\n행과 열의 모양과 크기에 대해서는 배열 객체의 일부로 저장되며 shape라는 메서드로 액세스할 수 있습니다. %B$가 배열인 경우, B.shape 객체는 그 자체로 두 개의 항목이 있는 배열입니다. 첫 번째 항목(인덱스 0)은 행의 개수이고 두 번째 항목(인덱스 1)은 열의 개수입니다.\n\nprint(f\"Array B has {B.shape[0]} rows.\")\nprint(f\"Array B has {B.shape[1]} columns.\")\n\nArray B has 2 rows.\nArray B has 3 columns."
  },
  {
    "objectID": "03_Matrix_Algebra.html#행렬",
    "href": "03_Matrix_Algebra.html#행렬",
    "title": "행렬과 행렬연산",
    "section": "",
    "text": "행렬 A는 숫자의 2차원 배열입니다. NumPy를 사용하여 행렬로 계산할 때는 이전과 마찬가지로 배열을 사용하게 됩니다. 행렬의 몇 가지 모양은 아래와 같습니다.\n\\[\n\\begin{equation}\nA = \\left[ \\begin{array}{rr} 1 & 3 \\\\ 2 & 1 \\end{array}\\right] \\hspace{1cm}\nB = \\left[ \\begin{array}{rrr} 3 & 0 & 4 \\\\ -1 & -2 & 1 \\end{array}\\right] \\hspace{1cm}\nC = \\left[ \\begin{array}{rr} -2 & 1 \\\\ 4 & 1 \\end{array}\\right] \\hspace{1cm}\nD = \\left[ \\begin{array}{r} 2 \\\\ 6 \\end{array}\\right]\n\\end{equation}\n\\]\n행렬은 행과 열의 개수를 지정하여 행렬의 크기 또는 모양에 대해 이야기하는 것이 일반적입니다. 일반적으로 행의 개수가 먼저 나열됩니다. 이 예제에서 \\(A\\)와 \\(C\\)는 \\(2 \\times 2\\) 행렬이고, \\(B\\)는 \\(2 \\times 3\\) 행렬이며, \\(D\\)는 $ 2 $ 행렬입니다. \\(D\\)와 같이 열이 1개만 있는 행렬은 일반적으로 벡터라고 합니다.\n행렬의 개별 항목에 대해서도 이야기할 필요가 있습니다. 이에 대한 일반적인 표기법은 행렬에서 항목의 위치를 나타내기 위해 아래 첨자가 있는 소문자입니다. 따라서 \\(b_{12}\\)는 행렬 \\(B\\)의 첫 번째 행과 두 번째 열에 있는 0을 나타냅니다. 일반적인 위치에 대해 이야기하는 경우, \\(a_{ij}\\)와 같이 아래 첨자 안에 변수를 사용할 수 있습니다.\n\nimport numpy as np\n\nA = np.array([[1, 3],[2,1]])\nB = np.array([[3, 0, 4],[-1, -2, 1]])\nC = np.array([[-2, 1],[4, 1]])\nD = np.array([[2],[6]])\n\n행과 열의 모양과 크기에 대해서는 배열 객체의 일부로 저장되며 shape라는 메서드로 액세스할 수 있습니다. %B$가 배열인 경우, B.shape 객체는 그 자체로 두 개의 항목이 있는 배열입니다. 첫 번째 항목(인덱스 0)은 행의 개수이고 두 번째 항목(인덱스 1)은 열의 개수입니다.\n\nprint(f\"Array B has {B.shape[0]} rows.\")\nprint(f\"Array B has {B.shape[1]} columns.\")\n\nArray B has 2 rows.\nArray B has 3 columns."
  },
  {
    "objectID": "03_Matrix_Algebra.html#행렬-연산",
    "href": "03_Matrix_Algebra.html#행렬-연산",
    "title": "행렬과 행렬연산",
    "section": "행렬 연산",
    "text": "행렬 연산\n행렬에 대해 수행해야 할 세 가지 대수 연산이 있습니다. 정의를 위해 \\(A\\)와 \\(C\\)가 \\(m \\times n\\) 행렬이고, \\(B\\)가 \\(n \\times k\\) 행렬이며, \\(c\\)가 숫자라고 가정해 보겠습니다. 행렬과 숫자를 포함하는 대수를 논의할 때 숫자는 일반적으로 스칼라라고 합니다.\n\n모든 형태의 행렬에 스칼라를 곱할 수 있습니다. 그 결과 모든 항목에 해당 스칼라가 곱해집니다. 아래 첨자 표기법을 사용하면 다음과 같이 작성할 수 있습니다.\n\n\\[\n(cA)_{ij} = ca_{ij}\n\\]\n\n동일한 모양을 가진 두 행렬을 추가할 수 있습니다. 그 결과 해당되는 모든 항목이 추가됩니다.\n\n\\[\n(A+C)_{ij} = a_{ij} + c_{ij}\n\\]\n\n행렬 \\(A\\)의 열 수가 행렬 \\(B\\)의 행 수와 같으면, 행렬을 \\(A\\), \\(B\\) 순서로 곱할 수 있습니다. 그 결과 행의 개수는 \\(A\\)와 같고 열의 개수는 \\(B\\)와 같은 새로운 행렬 \\(AB\\)가 생성됩니다. \\((AB)_{ij}\\) 행렬은 \\(A\\)의 행 \\(i\\)와 \\(B\\)의 열 \\(j\\)의 행렬을 다음과 같이 조합한 행렬이 됩니다.\n\n\\[\n(AB)_{ij} = \\sum_{k=1}^n a_{ik}b_{kj}\n\\]\n행렬 곱셈으로 알려진 마지막 연산은 세 가지 연산 중 가장 복잡하고 직관적이지 않습니다. 이 마지막 공식은 처음 접했을 때 다소 어렵게 느껴질 수 있습니다. 몇 가지 예를 들어 설명해 드리겠습니다.\n\n숫자와 행렬의 곱셈입니다:\n\n\\[\n\\begin{matrix}\n3A = 3\\left[ \\begin{array}{rr} 1 & 3 \\\\ 2 & 1 \\end{array}\\right]\n= \\left[ \\begin{array}{rr} 3 & 9 \\\\ 6 & 3 \\end{array}\\right]\n\\end{matrix}\n\\]\n\n모양이 같은 두 행렬의 합계입니다:\n\n\\[\n\\begin{matrix}\nA + C = \\left[ \\begin{array}{rr} 1 & 3 \\\\ 2 & 1 \\end{array}\\right] +\n\\left[ \\begin{array}{rr} -2 & 1 \\\\ 4 & 1 \\end{array}\\right]\n= \\left[ \\begin{array}{rr} -1 & 4 \\\\ 6 & 2 \\end{array}\\right]\n\\end{matrix}\n\\]\n\n두 행렬의 곱셈입니다:\n\n\\[\n\\begin{matrix}\nAB = \\left[ \\begin{array}{rr} 1 & 3 \\\\ 2 & 1 \\end{array}\\right]\n\\left[ \\begin{array}{rrr} 3 & 0 & 4 \\\\ -1 & -2 & 1 \\end{array}\\right]\n= \\left[ \\begin{array}{rrr} 0 & -6 & 7  \\\\  5 & -2 & 9  \\end{array}\\right]\n\\end{matrix}\n\\]\n행렬 곱셈에서 어떤 일이 일어나는지 명확히 하기 위해 두 개의 항목을 자세히 계산해 보겠습니다.\n\\[\n\\begin{matrix}\n(AB)_{12} & = & 1\\times 0 + 3 \\times (-2) = -6 \\\\\n(AB)_{23} & = & 2 \\times 4 + 1 \\times 1 = 9\n\\end{matrix}\n\\]\n이러한 행렬 연산은 모두 NumPy에 내장되어 있지만 행렬 곱셈의 경우 \\(\\texttt{*}\\) 대신 \\(\\texttt{@}\\) 기호를 사용해야 합니다.\n\nprint(3*A,'\\n')\nprint(A+C,'\\n')\nprint(A@B)\n\n[[3 9]\n [6 3]] \n\n[[-1  4]\n [ 6  2]] \n\n[[ 0 -6  7]\n [ 5 -2  9]]"
  },
  {
    "objectID": "03_Matrix_Algebra.html#행렬-연산의-속성",
    "href": "03_Matrix_Algebra.html#행렬-연산의-속성",
    "title": "행렬과 행렬연산",
    "section": "행렬 연산의 속성",
    "text": "행렬 연산의 속성\n행렬 곱셈에 대해 몇 가지 일반적인 대수적 성질은 아래와 같습니다. \\(A\\), \\(B\\), \\(C\\)를 행렬로, \\(k\\)를 스칼라로 가정합니다. 여기서 설명한 연관성 및 특성은 행렬 곱셈에도 적용됩니다.\n\\[\n\\begin{equation}\nk(A+B) = kA + kB\n\\end{equation}\n\\]\n\\[\n\\begin{equation}\nC(A+B) = CA + CB\n\\end{equation}\n\\]\n\\[\n\\begin{equation}\nA(BC) = (AB)C\n\\end{equation}\n\\]\n\\(A\\)와 \\(B\\)가 \\(3 \\times 3\\) 행렬인 경우에, \\(AB = BA\\)가 성립하지 않는다는 것을 주의해야 합니다.\n\nA = np.random.randint(-5,5,size=(3,3))\nB = np.random.randint(-5,5,size=(3,3))\n\nprint(A@B)\nprint('\\n')\nprint(B@A)\n\n[[-28  -3  -1]\n [ -8   1   5]\n [-25   0   5]]\n\n\n[[-14  -7  10]\n [ -3 -28  -7]\n [-18  11  20]]"
  },
  {
    "objectID": "03_Matrix_Algebra.html#행렬의-전치",
    "href": "03_Matrix_Algebra.html#행렬의-전치",
    "title": "행렬과 행렬연산",
    "section": "행렬의 전치",
    "text": "행렬의 전치\n유용하게 사용할 수 있는 또 다른 일반적인 아이디어는 행렬 전치입니다. 행렬 \\(A\\)의 전치는 열이 \\(A\\)의 행이 되도록 정의된 또 다른 행렬인 \\(A^T\\)입니다. AT\\(는 모든 항목의 행 인덱스를 열 인덱스로 간단히 바꾸면 됩니다(\\)aT_{ij} = a_{ji}$). 두 가지 예제만으로도 이 정의를 명확히 이해할 수 있습니다.\n\\[\n\\begin{equation}\nA = \\left[ \\begin{array}{rrr} 5 & 4 & 0 \\\\ 1 & 8 & 3 \\\\ 6 & 7 & 2\\end{array}\\right] \\hspace{1cm}\nA^T = \\left[ \\begin{array}{rrr} 5 & 1 & 6 \\\\ 4 & 8 & 7 \\\\ 0 & 3 & 2\\end{array}\\right] \\hspace{1cm}\n\\end{equation}\n\\]\n\\[\n\\begin{equation}\nB = \\left[ \\begin{array}{rrr} 1 & 2 & 7 & 0 \\\\ 3 & 1 & 5 & 2 \\\\ 4 & 9 & 8 & 6\\end{array}\\right] \\hspace{1cm}\nB^T = \\left[ \\begin{array}{rrr} 1 & 3 & 4 \\\\ 2 & 1 & 9 \\\\ 7 & 5 & 8 \\\\ 0 & 2 & 6\\end{array}\\right] \\hspace{1cm}\n\\end{equation}\n\\]\nNumPy 배열 객체에는 이를 위해 \\(\\texttt{transpose}\\)라는 메서드가 있습니다.\n\nA = np.array([[5, 4, 0],[1, 8, 3],[6, 7, 2]])\n\n## Note that the tranpose method must be called with (), the same as a function with no arguments.\nA_T = A.transpose()\n\nprint(A)\nprint('\\n')\nprint(A_T)\n\n[[5 4 0]\n [1 8 3]\n [6 7 2]]\n\n\n[[5 1 6]\n [4 8 7]\n [0 3 2]]\n\n\n행렬 \\(A\\)가 자신의 전치와 같을 때, 행렬은 주 대각선을 가로질러 대칭이 되는 성질을 가집니다. 이러한 이유로 행렬 \\(A\\)가 \\(A = A^T\\)이면 대칭 행렬이라고 합니다. 이와 동등하게 행렬의 모든 행렬 \\(a_{ij}\\)에 대해 \\(a_{ij} = a_{ji}\\)이면 \\(A\\)는 대칭이라고 말할 수 있습니다. 아래 행렬 \\(P\\)는 그러한 예시 중 하나입니다.\n\\[\n\\begin{equation}\nP = \\left[ \\begin{array}{rrr} 1 & 0 & 6 \\\\ 0 & 3 & 5 \\\\ 6 & 5 & -2\\end{array}\\right] \\hspace{1cm}\n\\end{equation}\n\\]"
  },
  {
    "objectID": "05_LU_Factorization.html",
    "href": "05_LU_Factorization.html",
    "title": "LU 분해",
    "section": "",
    "text": "행렬 \\(A\\)가 주어졌을 때, 다음과 같은 행렬 \\(L\\)과 \\(U\\)를 찾습니다.\n\\[\n\\begin{matrix}\nA = \\left[ \\begin{array}{cccc} * & * & * & * \\\\ * & * & * & * \\\\ * & * & * & * \\\\ * & * & * & *  \\end{array}\\right]\\hspace{1cm}\nL = \\left[ \\begin{array}{cccc} 1 & 0 & 0 & 0 \\\\ * & 1 & 0 & 0 \\\\ * & * & 1 & 0 \\\\ * & * & * & 1 \\end{array}\\right]\\hspace{1cm}\nU = \\left[ \\begin{array}{cccc} * & * & * & * \\\\ 0 & * & * & * \\\\ 0 & 0 & * & * \\\\ 0 & 0 & 0 & *  \\end{array}\\right]\\hspace{1cm}\n\\end{matrix}\n\\]\n알려진 행렬 \\(A\\)에서 \\(L\\)과 \\(U\\)를 계산하는 문제를 다루기 전에 이러한 인수분해가 왜 유용한지 알아보겠습니다. L$과 \\(U\\)를 구하여 \\(A=LU\\)가 되고, \\(AX=B\\) 시스템을 풀고 싶다고 가정해 보겠습니다. 이 문제를 쓰는 또 다른 방법은 \\(LUX=B\\)입니다. 그런 다음 \\(UX=Y\\)라고 하여 미지의 또 다른 \\(Y\\)를 정의하고, 단일 시스템 \\(AX=B\\)를 다음 두 시스템으로 교환할 수 있습니다.\n\\[\n\\begin{matrix}\nUX & = & Y\\\\\nLY & = & B\n\\end{matrix}\n\\]\n실제로 방정식의 수가 두 배로 늘어난 것은 사실이지만, 우리가 가지고 있는 두 시스템은 삼각형이며 뒤로(또는 앞으로) 치환하면 쉽게 풀 수 있습니다."
  },
  {
    "objectID": "05_LU_Factorization.html#예제-1-lu-분해를-활용",
    "href": "05_LU_Factorization.html#예제-1-lu-분해를-활용",
    "title": "LU 분해",
    "section": "예제 1: LU 분해를 활용",
    "text": "예제 1: LU 분해를 활용\n아래와 같은 방정식을 풀고자 합니다.\n\\[\n\\left[ \\begin{array}{ccc} 3 & -1 & -2 \\\\ 6 & -1 & 0  \\\\ -3 & 5 & 20  \\end{array}\\right]X =\n\\left[ \\begin{array}{c} -4 \\\\ -8 \\\\ 6  \\end{array}\\right]\\hspace{1cm}\n\\]\n여기서 \\(X\\)는 \\(3 \\times 1\\) 벡터입니다. 또한 \\(L\\)과 \\(U\\)도 계산했다고 가정합니다.\n\\[\nL = \\left[ \\begin{array}{ccc} 1 & 0 & 0 \\\\ 2 & 1 & 0  \\\\ -1 & 4 & 1  \\end{array}\\right] \\hspace{2cm}\nU = \\left[ \\begin{array}{ccc} 3 & -1 & -2 \\\\ 0 & 1 & 4  \\\\ 0 & 0 & 2  \\end{array}\\right]\n\\]\n\nimport numpy as np\nimport linear_solver as ls\nimport scipy.linalg as sla\n## Use Python to check for yourself that LU = A.\n\n이제 \\(UX=Y\\) 및 \\(LY = B\\) 시스템을 작성해 보겠습니다. 정확성을 행렬 표기법은 잠시 제쳐두고 \\(X\\)의 항목에는 \\(x_1\\), \\(x_2\\), \\(x_3\\) 변수를, \\(Y\\)의 항목에는 \\(y_1\\), \\(y_2\\), \\(y_3\\) 변수를 사용합니다.\n\\[\n\\begin{matrix}\nx_1 \\hspace{2.1cm}& = & y_1\\\\\n2x_1 + x_2 \\hspace{1.1cm}& = & y_2\\\\\n-x_1 + 4x_2 +x_3 & = & y_3 \\\\\n\\\\\n3y_1 - y_2 - 2y_3 & = & -4\\\\\ny_2 + 4y_3 & = & -8\\\\\n2y_3 & = & 6\n\\end{matrix}\n\\]\n이제 해결책은 치환의 문제입니다. 마지막 방정식은 \\(y_3\\)을 알려줍니다. 거기서부터 거꾸로 작업하여 \\(y_2\\)와 \\(y_1\\)을 찾습니다. 그런 다음 첫 번째 방정식부터 시작하여 아래로 내려가면서 비슷한 방식으로 \\(x\\) 값을 구합니다."
  },
  {
    "objectID": "05_LU_Factorization.html#기본-행렬",
    "href": "05_LU_Factorization.html#기본-행렬",
    "title": "LU 분해",
    "section": "기본 행렬",
    "text": "기본 행렬\n제거를 통해 LU 인수분해를 구성하는 방법을 이해하려면 기본 행렬이라는 특수 행렬을 곱셈하여 제거 단계를 수행할 수 있다는 것을 알면 도움이 됩니다. 기본 행렬은 호환 가능한 모양의 행렬에 row_scale 또는 row_add 연산을 적용한 결과입니다. (*행 재배열은 피벗 위치에서 0이 발생하는 경우에만 필요하다는 점을 기억하세요. 행 스왑은 곧 다루겠습니다.)\n\nI = np.eye(4)\nE = ls.row_add(I,1,2,-3)\nprint(I,'\\n')\nprint(E)\n\n[[1. 0. 0. 0.]\n [0. 1. 0. 0.]\n [0. 0. 1. 0.]\n [0. 0. 0. 1.]] \n\n[[ 1.  0.  0.  0.]\n [ 0.  1.  0.  0.]\n [ 0. -3.  1.  0.]\n [ 0.  0.  0.  1.]]\n\n\n우리가 얻는 \\(E\\)는 \\(I\\)의 세 번째 행에 \\(I\\)의 첫 번째 행의 -3배를 더한 결과입니다. 기본 행렬 \\(E\\)의 흥미로운 속성은 다른 행렬 \\(A\\)에 \\(E\\)를 곱하면 그 결과가 \\(A\\)에 동일한 행 연산을 적용하여 얻을 수 있는 행렬이 된다는 것입니다.\n\nA=np.array([[1,2,0,-1],[-1,1,-1,4],[2,13,-4,9],[-2,5,-3,13]])\nprint(A,'\\n')\nprint(E@A)\n\n[[ 1  2  0 -1]\n [-1  1 -1  4]\n [ 2 13 -4  9]\n [-2  5 -3 13]] \n\n[[ 1.  2.  0. -1.]\n [-1.  1. -1.  4.]\n [ 5. 10. -1. -3.]\n [-2.  5. -3. 13.]]"
  },
  {
    "objectID": "05_LU_Factorization.html#예제-2-finding-an-lu-factorization",
    "href": "05_LU_Factorization.html#예제-2-finding-an-lu-factorization",
    "title": "LU 분해",
    "section": "예제 2: Finding an LU factorization",
    "text": "예제 2: Finding an LU factorization\n이제 일련의 기본 행렬 \\(E_1\\), \\(E_2\\), \\(E_3\\),…을 \\(A\\)에 적용하여 제거를 수행할 수 있습니다. 위의 행렬에서 어떻게 작동하는지 살펴봅시다.\n\nA=np.array([[1,2,0,-1],[-1,1,-1,4],[2,13,-4,9],[-2,5,-3,13]])\nI = np.eye(4)\nE1 = ls.row_add(I,0,1,1)\nE2 = ls.row_add(I,0,2,-2)\nE3 = ls.row_add(I,0,3,2)\nprint(E3@E2@E1@A,'\\n')\nE4 = ls.row_add(I,1,2,-3)\nE5 = ls.row_add(I,1,3,-3)\nprint(E5@E4@E3@E2@E1@A)\n\n[[ 1.  2.  0. -1.]\n [ 0.  3. -1.  3.]\n [ 0.  9. -4. 11.]\n [ 0.  9. -3. 11.]] \n\n[[ 1.  2.  0. -1.]\n [ 0.  3. -1.  3.]\n [ 0.  0. -1.  2.]\n [ 0.  0.  0.  2.]]\n\n\nrow_add를 사용하여 적절한 공간에 \\(0\\)을 만들었으므로 이제 \\(U\\) 계수가 생겼습니다. 행렬 곱셈을 기호로 작성하면 다음과 같이 표시됩니다.\n\\[\n\\begin{matrix}\nE_5E_4E_3E_2E_1A = U\n\\end{matrix}\n\\]\n곱셈 순서는 변경할 수 없습니다. \\(E_1\\)이 가장 먼저 \\(A\\)를 곱하고, 그다음에 \\(E_2\\)를 곱하는 식으로 곱해야 합니다. 이제 역행렬의 속성에 따라 기호를 약간 조작해 보겠습니다.\n\\[\n\\begin{matrix}\nA &=& (E_5E_4E_3E_2E_1)^{-1}U  \\\\\nA &=& E_1^{-1}E_2^{-1}E_3^{-1}E_4^{-1}E_5^{-1}U  \n\\end{matrix}\n\\]\n\\(L = E_1^{-1}E_2^{-1}E_3^{-1}E_4^{-1}E_5^{-1}\\)가 되어야 합니다. 이 역행렬의 곱이 \\(L\\)이라는 정확한 형태를 갖는다는 사실은 전혀 명확하지 않습니다. 다음 두 가지를 관찰해 봅시다.\n\n역행렬의 각 행렬은 단순한 하한 삼각형 구조를 가집니다. 사실 \\(E_3^{-1}\\) 행렬도 기본 행렬입니다. \\(E_3\\)로 표현되는 행렬 연산을 취소하는 행렬이 바로 기본 행렬입니다! \\(E_3\\)를 곱하면 첫 번째 행의 2배를 마지막 행에 더하게 됩니다. \\(E_3^{-1}\\)로 곱하면 마지막 행에 첫 번째 행의 -2배를 더합니다.\n\n\nprint(E3,'\\n')\nprint(sla.inv(E3))\n\n[[1. 0. 0. 0.]\n [0. 1. 0. 0.]\n [0. 0. 1. 0.]\n [2. 0. 0. 1.]] \n\n[[ 1. -0. -0.  0.]\n [ 0.  1. -0.  0.]\n [ 0.  0.  1.  0.]\n [-2.  0.  0.  1.]]\n\n\n\n두 개의 하위 삼각형 행렬을 곱하면 하위 삼각형 행렬이 만들어집니다.\n\n\nL1 = np.array([[1,0,0,0],[-1,1,0,0],[2,3,1,0],[-2,3,0,1]])\nL2 = np.array([[1,0,0,0],[2,1,0,0],[-5,4,1,0],[4,4,1,1]])\nprint(L1,'\\n')\nprint(L2,'\\n')\nprint(L1@L2)\n\n[[ 1  0  0  0]\n [-1  1  0  0]\n [ 2  3  1  0]\n [-2  3  0  1]] \n\n[[ 1  0  0  0]\n [ 2  1  0  0]\n [-5  4  1  0]\n [ 4  4  1  1]] \n\n[[1 0 0 0]\n [1 1 0 0]\n [3 7 1 0]\n [8 7 1 1]]\n\n\n이 두 가지 사실을 종합하면 \\(E_1^{-1}E_2^{-1}E_3^{-1}E_4^{-1}E_5^{-1}\\) 행렬이 \\(L\\) 인자가 되기 위한 올바른 구조를 가지고 있음을 알 수 있습니다. 더 편리한 점은 이러한 역행렬을 함께 곱할 때 아래쪽 삼각형 부분의 0이 아닌 항목은 변하지 않는다는 것입니다.\n\nprint(sla.inv(E5),'\\n')\nprint(sla.inv(E4)@sla.inv(E5),'\\n')\nprint(sla.inv(E3)@sla.inv(E4)@sla.inv(E5))\n\n[[ 1. -0.  0.  0.]\n [ 0.  1.  0.  0.]\n [ 0. -0.  1.  0.]\n [ 0.  3.  0.  1.]] \n\n[[1. 0. 0. 0.]\n [0. 1. 0. 0.]\n [0. 3. 1. 0.]\n [0. 3. 0. 1.]] \n\n[[ 1.  0.  0.  0.]\n [ 0.  1.  0.  0.]\n [ 0.  3.  1.  0.]\n [-2.  3.  0.  1.]]\n\n\n\\(E_3^{-1}E_4^{-1}E_5^{-1}\\)의 0이 아닌 하위 삼각형 항목은 \\(E_3^{-1}\\), \\(E_4^{-1}\\) 및 \\(E_5^{-1}\\)의 해당 항목과 동일합니다. 즉, \\(L\\)의 항목은 \\(\\texttt{RowAdd}\\)의 적용에 사용된 배율에 -1을 곱한 값일 뿐입니다. 이제 이러한 기본 행렬이 어떻게 결합하여 \\(L\\)을 생성하는지 이해했으므로 실제로 행렬을 구성할 필요는 없습니다. 행 연산을 할 때 배율을 추적하여 \\(L\\)을 계산하면 됩니다.\n\nL = np.array([[1,0,0,0],[-1,1,0,0],[2,3,1,-0],[-2,3,0,1]])\nU = np.array([[1,2,0,-1],[0,3,-1,3],[0,0,-1,2],[0,0,0,2]])\nprint(\"L:\",'\\n',L,'\\n',sep='')\nprint(\"U:\",'\\n',U,'\\n',sep='')\nprint(\"LU:\",'\\n',L@U,sep='')\n\nL:\n[[ 1  0  0  0]\n [-1  1  0  0]\n [ 2  3  1  0]\n [-2  3  0  1]]\n\nU:\n[[ 1  2  0 -1]\n [ 0  3 -1  3]\n [ 0  0 -1  2]\n [ 0  0  0  2]]\n\nLU:\n[[ 1  2  0 -1]\n [-1  1 -1  4]\n [ 2 13 -4  9]\n [-2  5 -3 13]]"
  },
  {
    "objectID": "10_General_Linear_Systems.html",
    "href": "10_General_Linear_Systems.html",
    "title": "일반적인 연립선형방정식",
    "section": "",
    "text": "벡터 공간 \\(\\mathbb{R}^n\\)을 살펴보기 전에 연립선형방정식(이하 선형 시스템)의 일반적인 질문에 대한 답변을 할 준비가 되어있습니다. 모든 선형 시스템의 경우 다음 명제 중 정확히 한 가지가 참입니다:\n주어진 선형 시스템에 앞선 세 가지 명제 중 어떤 것이 참인지 확인하는 것이 핵심 사항 입니다. 이전 장에서는 고유한 해가 있는 선형 시스템에 중점을 두었습니다.\n이제 다른 가능성에 대해 자세히 살펴보겠습니다. 그리고 방정식과 미지수가 같은 선형 시스템이 아니라 \\(m\\) 개의 방정식과 \\(n\\) 개의 미지수를 가진 선형 시스템, 즉 일반적인 경우를 고려하겠습니다.\n기약 행 사다리꼴(이하, RREF)을 주로 사용 할 예정이며, RREF의 유용성에 대해서 확인할 수 있을 것으로 기대합니다."
  },
  {
    "objectID": "10_General_Linear_Systems.html#기약-행-사다리꼴",
    "href": "10_General_Linear_Systems.html#기약-행-사다리꼴",
    "title": "일반적인 연립선형방정식",
    "section": "기약 행 사다리꼴",
    "text": "기약 행 사다리꼴\n앞선 장에서 선형 시스템의 해를 구하는 방법 중 역행렬, LU 분해 등과 같은 방법을 사용해서 선형 연립방정식을 해결하였습니다. 일반적인 선형 시스템의 경우 기본 형 연산을 사용하여 RREF 형태로 만드는 것이 일반적입니다.\n\n각 행의 첫 번째 \\(0\\)이 아닌 항목은 \\(1\\)입니다. 이러한 항목을 피벗(pivots)이라고 합니다.\n각 피벗은 윗 행의 피벗 오른쪽에 위치합니다.\n각 피벗 위와 아래의 항목은 0입니다.\n모든 0인 행은 다른 행 아래에 위치합니다.\n\n다음은 RREF로 구성된 간단한 예제입니다.\n\\[\n\\begin{matrix}\n\\left[ \\begin{array}{cccc} 1 & 0 & 0 & * \\\\ 0 & 1 & 0 & * \\\\ 0 & 0 & 1 & * \\end{array}\\right]\n\\end{matrix}\n\\]\n\\[\n\\begin{matrix}\n\\left[ \\begin{array}{ccccc} 1 & 0 & * & 0 & *  \\\\ 0 & 1 & * & 0 & *\n\\\\ 0 & 0 & 0 & 1 & * \\\\ 0 & 0 & 0 & 0 & 0 \\end{array}\\right]\n\\end{matrix}\n\\]\n\\[\n\\begin{matrix}\n\\left[ \\begin{array}{cccccc} 1 & * & 0 & 0 & * & * \\\\ 0 & 0 & 1 & 0 & * & * \\\\ 0 & 0 & 0 & 1 & * & * \\end{array}\\right]\n\\end{matrix}\n\\]\n\nimport numpy as np\nimport linear_solver as ls\n\nC = np.random.randint(-2,3,size=(3,5))\nC_reduced = ls.full_row_reduction(C)\n\nprint(C)\nprint('\\n')\nprint(C_reduced)\n\n[[-1  1  1  1 -2]\n [-2  1  1 -2 -2]\n [-1  0 -1  0  2]]\n\n\n[[ 1.  0.  0.  3.  0.]\n [ 0.  1.  0.  7.  0.]\n [ 0.  0.  1. -3. -2.]]"
  },
  {
    "objectID": "10_General_Linear_Systems.html#피벗-위치-및-자유-변수",
    "href": "10_General_Linear_Systems.html#피벗-위치-및-자유-변수",
    "title": "일반적인 연립선형방정식",
    "section": "피벗 위치 및 자유 변수",
    "text": "피벗 위치 및 자유 변수\n먼저 RREF를 사용하여 자유 변수(free variables)가 있는 선형 시스템을 푸는데 어떻게 도움이 되는지 살펴봅니다. 자유 변수는 시스템에 의해 고유하게 결정되지 않는 변수를 말합니다.\n다음 연립선형방정식을 예로 들어 보겠습니다.\n\\[\n\\begin{matrix}\n-2x_1 + 2x_2 - 2x_3 + 2x_4& = & 0\\\\\nx_1 - 2x_2 -2x_3 \\hspace{1.2cm}& = & -1\\\\\nx_1 \\hspace{1.2cm} + 2x_3 -2x_4 & = & 1\n\\end{matrix}\n\\]\n\nB_augmented = np.array([[-2,2,-2,2,0],[1,-2,-2,0,-1],[1,0,2,-2,1]])\nB_augmented_reduced = ls.full_row_reduction(B_augmented)\nprint(B_augmented_reduced)\n\n[[ 1.  0.  0. -2.  1.]\n [ 0.  1.  0. -1.  1.]\n [ 0.  0.  1.  0.  0.]]\n\n\nRREF로 대표되는 연립선형방정식을 확인해보겠습니다.\n\\[\n\\begin{matrix}\nx_1 \\quad\\quad\\quad\\quad -2x_4& = & 1\\\\\nx_2 \\quad\\quad -x_4 & = & 1\\\\\nx_3 \\quad\\quad & = & 0\n\\end{matrix}\n\\]\n\\(x_3 = 0\\)이며, 다른 변수들은 앞의 두 방정식을 통해 서로 연관되어 있음을 알 수 있습니다. 즉, \\(x_3\\)의 값은 시스템에 의해 고유하게 결정되지만 다른 변수의 값은 그렇지 않다는 것을 의미합니다. 해를 완성하려면 \\(x_1\\), \\(x_2\\) 또는 \\(x_4\\) 중 하나의 값을 선택한 다음 처음 두 방정식을 사용하여 다른 두 변수의 값을 계산해야 합니다.\nRREF를 효율적으로 활용하기 위해 항상 자유 변수는 피벗이 포함되지 않은 배열의 열에 해당하는 변수로 선택합니다. 이 경우 네 번째 열에 피벗이 없으므로 \\(x_4\\)가 자유 변수가 됩니다. 이제 \\(x_4 = 2\\)를 선택하면 \\(x_1=5\\)와 \\(x_2 = 3\\)을 확인할 수 있습니다. 여기서 \\(x_4\\)는 어떤 값도 취할 수 있다는 것을 알아두는 것이 중요합니다. 그런 다음 \\(x_1\\)과 \\(x_2\\)의 값을 계산하여 시스템에 대한 해를 완성할 수 있습니다.\n여기서 잠시 멈춰서 이 시스템에 대한 가능한 모든 해을 설명하는 방법을 생각해 볼 수 있습니다. 한 가지 아이디어는 자유 변수에 매개변수(예: \\(x_4 = s\\))를 지정한 다음 다른 변수를 매개변수로 표현하는 것입니다.\n\\[\n\\begin{matrix}\nx_1 & = & 1 + 2s\\\\\nx_2  & = & 1 + s\\\\\nx_3 & = & 0 \\\\\nx_4 & = & s\n\\end{matrix}\n\\]\n중요한 점은 선형 시스템은 하나 이상의 자유 변수를 포함할 경우 해의 개수가 무한대라는 점입니다. RREF는 자유 변수가 있는지 여부를 한눈에 알 수 있기 때문에 유용합니다. 피벗이 없는 열이 있다면 시스템에 자유 변수가 있다는 뜻이며, 이는 시스템에 고유한 해가 없다는 것을 의미합니다."
  },
  {
    "objectID": "10_General_Linear_Systems.html#피벗-위치와-불능inconsistent",
    "href": "10_General_Linear_Systems.html#피벗-위치와-불능inconsistent",
    "title": "일반적인 연립선형방정식",
    "section": "피벗 위치와 불능(inconsistent)",
    "text": "피벗 위치와 불능(inconsistent)\n이제 선형 시스템에 일관성이 있는지 확인하는 문제로 관심을 돌리겠습니다. 다시 한 번 구체적인 예를 살펴보고 RREF를 활용하겠습니다.\n\\[\n\\begin{matrix}\nx_1 - 2x_2 + 2x_3 & = & 0\\\\\n2x_1 + 2x_2 + 2x_3  & = & 1\\\\\n-x_2 - x_3 & = & -2 \\\\\n-2x_1 -x_2 - x_3 & = & 0\n\\end{matrix}\n\\]\n\nD_augmented = np.array([[1,-2,2,0],[2,2,2,1],[0,-1,-1,-2],[-2,-1,-1,0]])\nD_augmented_reduced = ls.full_row_reduction(D_augmented)\nprint(D_augmented_reduced)\n\n[[1. 0. 0. 0.]\n [0. 1. 0. 0.]\n [0. 0. 1. 0.]\n [0. 0. 0. 1.]]\n\n\nRREF로 표시되는 시스템을 작성하면 이 시스템에 해가 없음을 분명히 알 수 있습니다.\n\\[\n\\begin{matrix}\nx_1 & = & 0\\\\\nx_2  & = & 0\\\\\nx_3 & = & 0 \\\\\n0 & = & 1\n\\end{matrix}\n\\]\n이 경우 RREF를 해석할 때 주의해야 합니다. 우리는 \\(x_1 = x_2 = x_3 = 0\\)을 설정하면 세 개의 방정식은 만족하지만 한 개의 방정식은 만족하지 않는다고 결론을 내리고 싶을 수 있습니다. 하지만 원래의 시스템을 되돌아보면 그렇지 않다는 것을 알 수 있습니다. \\(x_1 = x_2 = x_3 = 0\\)을 설정하면 첫 번째와 마지막 방정식만 만족합니다.\n다시 한 번 피벗 위치와 불능에 관해 결론을 연결해 보겠습니다. 특정 행의 모든 계수가 \\(0\\)이지만 오른쪽이 \\(0\\)이 아닌 경우 불일치가 발생합니다. 즉, 선형 시스템이 불능이라는 것을 의미합니다."
  },
  {
    "objectID": "10_General_Linear_Systems.html#피벗-위치와-유일-해unique-solutions",
    "href": "10_General_Linear_Systems.html#피벗-위치와-유일-해unique-solutions",
    "title": "일반적인 연립선형방정식",
    "section": "피벗 위치와 유일 해(unique solutions)",
    "text": "피벗 위치와 유일 해(unique solutions)\n마지막 예제에서는 시스템에 고유한 솔루션이 있는 일반적인 경우를 고려하고 RREF를 다시 고려합니다.\n\\[\n\\begin{matrix}\nx_1 - 2x_2 + 2x_3 & = & 0\\\\\n-x_2 - x_3 & = & -2 \\\\\n-2x_1 -x_2 - x_3 & = & 0\n\\end{matrix}\n\\]\n\nG_augmented = np.array([[1,-2,2,0],[0,-1,-1,-2],[-2,-1,-1,0]])\nG_augmented_reduced = ls.full_row_reduction(G_augmented)\nprint(G_augmented_reduced)\n\n[[ 1.    0.    0.   -1.  ]\n [ 0.    1.    0.    0.75]\n [ 0.    0.    1.    1.25]]\n\n\nRREF는 이제 고유한 솔루션을 직접 제공합니다.\n\\[\n\\begin{matrix}\nx_1 & = & -1\\\\\nx_2  & = & 0.75\\\\\nx_3 & = & 1.25\n\\end{matrix}\n\\]\n앞의 두 가지 경우가 발생하지 않을 때 정확히 고유한 해를 갖는 시스템이 있다는 것을 인식하는 것이 중요합니다. 이를 명시적으로 설명하자면, 행렬의 마지막 열을 제외한 모든 열에 피벗이 있을 때 시스템은 고유한 해를 갖게 됩니다."
  },
  {
    "objectID": "10_General_Linear_Systems.html#피벗-위치-및-선형-시스템",
    "href": "10_General_Linear_Systems.html#피벗-위치-및-선형-시스템",
    "title": "일반적인 연립선형방정식",
    "section": "피벗 위치 및 선형 시스템",
    "text": "피벗 위치 및 선형 시스템\n이제 \\(m\\times (n+1)\\) 행렬 \\([A|B]\\)의 피벗 위치에 따라 \\(AX=B\\) 시스템에 대한 해집합을 요약합니다. 이러한 피벗 위치는 RREF를 계산하면 알 수 있습니다.\n\n특정 행의 모든 계수가 \\(0\\)이지만 오른쪽이 \\(0\\)이 아닌 경우 불일치가 발생, 시스템에 해가 없습니다.\n$[A|B]의 \\(n\\) 열 중 하나라도 피벗이 없는 경우, 자유 변수가 존재하므로 시스템에 고유한 해가 없습니다.\n마지막 열을 제외한 각 열에 피벗이 있는 경우, 시스템에 고유한 해가 있습니다.\n\n이 세 문장을 통해 주어진 시스템 \\(AX=B\\)가 고유한 해를 갖는지, 무한한 수의 해를 갖는지, 아니면 해가 전혀 없는지 확인할 수 있습니다. 선형 시스템을 분류하는 이 방법은 앞으로의 논의에서 중요한 역할을 할 것입니다."
  },
  {
    "objectID": "12_Linear_Independence.html",
    "href": "12_Linear_Independence.html",
    "title": "선형 독립",
    "section": "",
    "text": "벡터집합 \\(V\\)가 \\(\\{V_1, V_2, V_3, ... V_n\\}\\) 일 때, \\(C_1 = C_2 = C_3 = .... = C_N = 0\\)으로 유일한 해를 가지면 벡터 집합 \\(V\\)는 선형독립이라고 합니다.\n\\[\n\\begin{matrix}\nc_1V_1 + c_2V_2 + c_3V_3 + .... + c_nV_n = 0\n\\end{matrix}\n\\]\n이것을 아주 간단하게 주장하자면, 선형독립은 벡터집합 \\(V\\)의 어떠한 원소도 나머지 원소들의 선형결합으로 나타낼 수 없습니다. 즉, 각각의 벡터는 서로 독립적으로 존재한다고 할 수 있습니다. 반면, 선형종속의 의미​는 벡터집합 S의 원소 중 적어도 하나는 나머지 원소들의 선형결합으로 나타낼 수 있습니다. 즉, 어떠한 특정 벡터가 나머지 벡터에 의존하여 영향을 받는다고 할 수 있습니다."
  },
  {
    "objectID": "12_Linear_Independence.html#예제-1-vectors-in-mathbbr2",
    "href": "12_Linear_Independence.html#예제-1-vectors-in-mathbbr2",
    "title": "선형 독립",
    "section": "예제 1: Vectors in \\(\\mathbb{R}^2\\)",
    "text": "예제 1: Vectors in \\(\\mathbb{R}^2\\)\n\\[\n\\begin{matrix}\nV_1 = \\left[ \\begin{array}{r} 2 \\\\ 1 \\end{array}\\right] \\hspace{1cm}\nV_2 = \\left[ \\begin{array}{r} 1 \\\\ -6  \\end{array}\\right] \\hspace{1cm}\n\\end{matrix}\n\\]\n이 벡터 집합이 선형적으로 독립적인지 확인하려면 다음 벡터 방정식을 살펴봐야 합니다.\n\\[\n\\begin{matrix}\nc_1\\left[ \\begin{array}{r} 2 \\\\ 1 \\end{array}\\right] +\nc_2\\left[ \\begin{array}{r} 1 \\\\ -6  \\end{array}\\right] =\n\\left[ \\begin{array}{r} 0 \\\\ 0 \\end{array}\\right]\n\\end{matrix}\n\\]\n\nimport numpy as np\nimport linear_solver as ls\n\nA_augmented = np.array([[2,1,0],[1,-6,0]])\nprint(ls.full_row_reduction(A_augmented))\n\n[[1. 0. 0.]\n [0. 1. 0.]]\n\n\nRREF에서 방정식의 유일한 해는 \\(c_1 = c_2 = 0\\)임을 알 수 있습니다. 집합 \\(\\{V_1, V_2\\}\\)는 선형 독립적입니다."
  },
  {
    "objectID": "12_Linear_Independence.html#예제-2-vectors-in-mathbbr3",
    "href": "12_Linear_Independence.html#예제-2-vectors-in-mathbbr3",
    "title": "선형 독립",
    "section": "예제 2: Vectors in \\(\\mathbb{R}^3\\)",
    "text": "예제 2: Vectors in \\(\\mathbb{R}^3\\)\n\\[\n\\begin{matrix}\nW_1 = \\left[ \\begin{array}{r} 2 \\\\ -1  \\\\ 1 \\end{array}\\right] \\hspace{1cm}\nW_2 = \\left[ \\begin{array}{r} 1 \\\\ -4 \\\\ 0  \\end{array}\\right] \\hspace{1cm}\nW_3 = \\left[ \\begin{array}{r} 3 \\\\ 2 \\\\ 2  \\end{array}\\right] \\hspace{1cm}\n\\end{matrix}\n\\]\n다시 한 번 벡터 방정식의 해를 살펴봐야 합니다.\n\\[\n\\begin{matrix}\nc_1\\left[ \\begin{array}{r} 2 \\\\ -1 \\\\ 1 \\end{array}\\right] +\nc_2\\left[ \\begin{array}{r} 1 \\\\ -4 \\\\ 0  \\end{array}\\right] +\nc_3\\left[ \\begin{array}{r} 3 \\\\ 2 \\\\ 2  \\end{array}\\right] =\n\\left[ \\begin{array}{r} 0 \\\\ 0 \\\\ 0\\end{array}\\right]\\end{matrix}\n\\]\n\nB_augmented = np.array([[2,1,3,0],[-1,-4,2,0],[1,0,2,0]])\nprint(ls.full_row_reduction(B_augmented))\n\n[[ 1.  0.  2.  0.]\n [ 0.  1. -1.  0.]\n [ 0.  0.  0.  0.]]\n\n\n이 경우 \\(c_3\\)이 자유 변수임을 알 수 있습니다. 만약 \\(c_3 = 1\\)로 설정하면 \\(c_2 = 1\\), \\(c_1 = -2\\)가 됩니다. \\(c_1 = c_2 = c_3 = 0\\) 이외의 해를 찾을 수 있으므로 벡터 집합 \\(\\{W_1, W_2, W_3\\}\\)은 선형 종속적입니다."
  },
  {
    "objectID": "12_Linear_Independence.html#동형-시스템",
    "href": "12_Linear_Independence.html#동형-시스템",
    "title": "선형 독립",
    "section": "동형 시스템",
    "text": "동형 시스템\n선형시스템은 행렬 방정식 \\(AX = 0\\)으로 설명할 수 있는 경우 동형 시스템이라고 합니다. 이러한 시스템의 해는 \\(AX=B\\) 시스템의 해와 연결되어 있습니다. 동형 시스템은 선형 독립성의 개념과도 관련이 있습니다. 이 모든 아이디어를 서로 연결하면 선형 독립성에 대한 정보를 바탕으로 \\(AX=B\\) 시스템의 해에 대한 정보를 얻을 수 있습니다.\n이전 예제에서는 벡터 방정식 \\(c_1V_1 + c_2V_2 + c_3V_3 + .... + c_nV_n = 0\\) 의 벡터 집합 \\(\\{V_1, V_2, V_3 .... V_n\\}\\) 벡터 집합이 선형적으로 독립적인지 확인합니다. 이 벡터 방정식은 \\(AX=0\\)로도 설명할 수 있는 동차 선형 시스템을 나타내며, 여기서 \\(V_1\\), \\(V_2\\), … \\(V_n\\)은 행렬 \\(A\\)의 열이고, \\(X\\)는 미지 계수의 벡터입니다. 벡터의 집합은 연관된 동질계가 모든 항목이 0인 벡터 이외의 해를 갖는 경우에만 선형 의존적입니다. 모든 0의 벡터를 삼차 해법이라고 합니다. 이 0 벡터는 \\(A\\)의 엔트리에 관계없이 모든 동형계 \\(AX=0\\)에 대한 해이기 때문에 사칙연산 해라고 부릅니다. 이러한 이유로 우리는 \\(AX=0\\)에 대한 비소수 해의 존재 여부에만 관심이 있습니다.\n동형 시스템 \\(AX=0\\)에 비동형 해가 있다고 가정하고, 이를 \\(X_h\\)라고 부를 수 있다고 가정해 봅시다. 또한 관련 비동차 시스템인 \\(AX=B\\)에도 어떤 특정 해가 있으며, 이를 \\(X_p\\)라고 부를 수 있다고 가정해 봅시다. 따라서 \\(AX_h = 0\\)과 \\(AX_p = B\\)가 됩니다. 이제 행렬 곱셈의 성질에 따라 \\(A(X_p + X_h) = AX_p + AX_h = B + 0\\)이므로 \\(X_p + X_h\\)도 \\(AX=B\\)의 해가 됩니다.\n다음 시스템을 예로 들어 보겠습니다.\n\\[\n\\begin{matrix}\nAX = \\left[ \\begin{array}{rrr} -3 & 2 & 1 \\\\ -2 & 1 & -1 \\\\ 4 & 3 & 3 \\end{array}\\right]\n\\left[ \\begin{array}{r} x_1 \\\\ x_2 \\\\ x_3 \\end{array}\\right]=\n\\left[ \\begin{array}{r} -6 \\\\ 1 \\\\ 13  \\end{array}\\right]= B\n\\end{matrix}\n\\]\n연관된 동질계를 살펴보고 \\(A\\)의 열이 선형적으로 독립적인지 확인할 수 있습니다.\n\\[\n\\begin{matrix}\n\\left[ \\begin{array}{rrr} -3 & 2 & 1 \\\\ -2 & 1 & -1 \\\\ 4 & 3 & 3 \\end{array}\\right]\n\\left[ \\begin{array}{r} c_1 \\\\ c_2 \\\\ c_3 \\end{array}\\right]=\n\\left[ \\begin{array}{r} 0 \\\\ 0 \\\\ 0  \\end{array}\\right]\n\\end{matrix}\n\\]\n\nA_augmented = np.array([[-3,2,1,0],[-2,1,-1,0],[4,-3,-3,0]])\nA_augmented_reduced = ls.full_row_reduction(A_augmented)\nprint(A_augmented_reduced)\n\n[[1. 0. 3. 0.]\n [0. 1. 5. 0.]\n [0. 0. 0. 0.]]\n\n\n세 번째 열에 피벗이 없다는 것은 \\(c_3\\)이 자유 변수이며, 동종 시스템에 대한 비분산 해가 존재한다는 것을 나타냅니다. 한 가지 가능성은 \\(c_1 = 3\\), \\(c_2=5\\), \\(c_3 = -1\\)입니다. 여기서 모든 항목이 0이기 때문에 증강 행렬의 마지막 열에서 행 연산을 수행할 필요가 없다는 점에 주목할 필요가 있습니다. 동종 시스템을 고려할 때는 계수 행렬의 RREF를 구하는 것으로 충분합니다.\n동차방정식이 비미분 해를 갖는다는 사실은 \\(A\\)의 열을 벡터로 생각하면 선형적으로 의존한다는 것을 의미합니다. 지금까지의 논의를 바탕으로 \\(AX=B\\) 시스템에 해가 있다면, 그 해는 고유하지 않을 것으로 예상할 수 있습니다.\n\nA_augmented = np.array([[-3,2,1,-6],[-2,1,-1,1],[4,-3,-3,13]])\nA_augmented_reduced = ls.full_row_reduction(A_augmented)\nprint(A_augmented_reduced)\n\n[[  1.   0.   3.  -8.]\n [  0.   1.   5. -15.]\n [  0.   0.   0.   0.]]\n\n\nRREF는 두 개의 방정식을 나타내며, 세 번째 변수는 자유 변수입니다.\n\\[\n\\begin{matrix}\nx_1 \\quad\\quad + 3x_3 & = & -8\\\\\nx_2 + 5x_3 & = & = -15\n\\end{matrix}\n\\]\n가능한 해를 표현하기 위해 \\(x_3 = t\\)를 설정하면 \\(x_2 = -15 -5t\\)와 \\(x_1 = -8-3t\\)가 됩니다. 이러한 구성 요소는 매개변수 \\(t\\)를 포함하는 벡터로 조립할 수 있습니다.\n\\[\n\\begin{matrix}\nX = \\left[ \\begin{array}{c} -8-3t \\\\ -15-5t  \\\\ t \\end{array}\\right]\n\\end{matrix}\n\\]\n이 벡터를 두 조각으로 나누면 이 솔루션을 동종 시스템의 솔루션과 연결하는 데 도움이 됩니다.\n\\[\n\\begin{matrix}\nX  =\n\\left[ \\begin{array}{c} -8 \\\\ -15  \\\\ 0 \\end{array}\\right] +\nt\\left[ \\begin{array}{c} -3 \\\\ -5  \\\\ 1 \\end{array}\\right] = X_p + X_h\n\\end{matrix}\n\\]\n모든 \\(t\\)에 대해 \\(AX_p= B\\), \\(AX_h= 0\\), 모든 \\(t\\)에 대해 \\(A(X_p+X_h) = B\\)라는 것을 확인할 수 있습니다.\n\nA = np.array([[-3,2,1],[-2,1,-1],[4,-3,-3]])\n\nX_p = np.array([[-8],[-15],[0]])\nX_h = np.array([[-3],[-5],[1]])\n\nt = np.random.rand()\nX = X_p + t*X_h\n\nprint(X)\nprint('\\n')\nprint(A@X_p)\nprint('\\n')\nprint(A@(t*X_h))\nprint('\\n')\nprint(A@X)\n\n[[-10.67326069]\n [-19.45543449]\n [  0.8910869 ]]\n\n\n[[-6]\n [ 1]\n [13]]\n\n\n[[ 1.11022302e-15]\n [ 6.66133815e-16]\n [-1.77635684e-15]]\n\n\n[[-6.]\n [ 1.]\n [13.]]\n\n\n동종 시스템의 증강 행렬에 대한 RREF의 처음 세 열이 \\(AX=B\\) 시스템의 RREF와 정확히 동일하다는 점에 유의해야 합니다. 물론 처음 세 열은 두 시스템에서 동일한 계수 행렬 \\(A\\)에서 나오기 때문에 그럴 수밖에 없습니다. 여기서 중요한 점은 \\(AX=B\\) 시스템은 \\(A\\)의 열이 선형적으로 독립적인 경우에만 고유한 해를 가질 수 있다는 것입니다."
  },
  {
    "objectID": "12_Linear_Independence.html#null-space",
    "href": "12_Linear_Independence.html#null-space",
    "title": "선형 독립",
    "section": "Null space",
    "text": "Null space\n동종 시스템의 개념이 정립되었으므로 이제 두 번째 기본 부분 공간을 정의할 준비가 되었습니다. A$가 \\(m\\times n\\) 행렬인 경우, \\(A\\)의 널 공간은 \\(AX=0\\)이 되는 벡터 \\(X\\)의 집합입니다. 다시 말해, \\(A\\)의 널 공간은 동종 시스템 \\(AX=0\\)에 대한 모든 해의 집합입니다. \\(A\\)의 널 공간은 \\(\\mathbb{R}^n\\)의 부분공간이며, \\(\\mathcal{N}(A)\\)라는 표기법으로 쓰입니다. 이제 앞서 설명한 내용을 널 공간의 관점에서 재구성할 수 있습니다.\n\n행렬 \\(A\\)의 열은 \\(\\mathcal{N}(A)\\)가 0 벡터만 포함하는 경우에만 선형적으로 독립적입니다.\n\\(AX=B\\) 시스템은 \\(\\mathcal{N}(A)\\) 가 0 벡터만 포함하는 경우에만 최대 하나의 해를 갖습니다.\n\n\\(A\\)의 기본 부분공간과 \\(AX=B\\) 시스템의 해집합을 연결하면 선형 시스템에 대한 이해와 이를 풀 수 있는 방법을 더욱 강화하는 일반적인 결론을 내릴 수 있습니다."
  },
  {
    "objectID": "14_Vector_Space_Examples.html",
    "href": "14_Vector_Space_Examples.html",
    "title": "벡터 공간의 예",
    "section": "",
    "text": "벡터 공간에 대한 기본 개념이 정리되었으므로 이제 벡터 공간을 특정 속성을 만족하는 객체와 대수 연산의 집합으로 이해하는 추상화로 돌아가 보겠습니다."
  },
  {
    "objectID": "14_Vector_Space_Examples.html#예제-1-polynomials",
    "href": "14_Vector_Space_Examples.html#예제-1-polynomials",
    "title": "벡터 공간의 예",
    "section": "예제 1: Polynomials",
    "text": "예제 1: Polynomials\n차수가 3 이하인 모든 다항식의 집합은 일반적인 대수 연산과 함께 벡터 공간을 구성합니다. 이 벡터 공간은 일반적으로 \\(\\mathbb{P}_3\\)라는 기호로 표기합니다. 예를 들어 \\(\\mathbb{P}_3\\)에서 두 원소, \\(p = 2x^3 - x^2 + 6x -8\\)과 \\(q = x^3 - 3x^2 -4x -3\\)을 취하면 선형 조합 \\(p+2q = 4x^3 - 7x^2 -2x -14\\)가 잘 정의되어 있으며 \\(\\mathbb{P}_3\\)의 또 다른 원소입니다. 실제로 \\(\\mathbb{P}_3\\)의 다항식의 선형 조합은 대수의 일반적인 규칙에 따라 \\(\\mathbb{P}_3\\)의 다른 다항식이 될 것입니다.\n\\[\n\\begin{matrix}\ns(a_3x^3 + a_2x^2 + a_1 + a_0) + t(b_3x^3 + b_2x^2 + b_1x + b_0) = (sa_3+tb_3)x^3 + (sa_2+tb_2)x^2 + (sa_1+tb_1)x\n+ (sa_0 + ta_0)\n\\end{matrix}\n\\]\n대수 연산에 필요한 속성은 모두 충족되지만 여기서는 확인하지 않습니다.\n\\(mathbb{P}_3\\)에서 다항식을 지정하려면 4개의 계수가 필요하므로 \\(\\mathbb{P}_3\\)의 차원이 4라는 것을 이해하는 것은 어느 정도 자연스러운 일입니다. 이러한 \\(\\mathbb{P}_3\\)의 기저 중 하나는 집합 \\(\\{x^3, x^2, x, 1\\}\\)입니다. 이 기저에 대한 모든 다항식의 좌표는 \\(x^3\\), \\(x^2\\), \\(x\\) 항과 상수 항의 계수일 뿐입니다. 이 표준 기저를 사용하면 스팬과 선형 독립성에 대한 개념을 논의할 수 있습니다.\n다음 다항식(벡터) 컬렉션은 \\(\\mathbb{P}_3\\)에서 선형 종속적입니다.\n\\[\n\\begin{matrix}\np_1 & = & 3x^3 + 2x^2 + x  - 1 \\\\\np_2 & = & x^2 - 5x + 4 \\\\\np_3 & = & 6x^3 + 3x^2 + 7x + -6 \\\\\np_4 & = & -2x^3 + 2x^2 + 8x\n\\end{matrix}\n\\]\n집합이 선형 의존적이라는 것을 보여주기 위해서는 \\(c_1p_1 + c_2p_2 + c_3p_3 + c_4p_4 = 0\\) 방정식에 대한 부등식을 찾아야 합니다. 왼쪽의 다항식은 모든 항의 계수가 0과 같을 때만 0이 될 수 있습니다. 대수적 연산을 진행하면, 네 항 각각에 대해 하나의 방정식을 얻을 수 있습니다.\n\\[\n\\begin{matrix}\n3c_1 \\quad\\quad + 6c_3 -2c_4 & = & 0 \\\\\n2c_1 +c_2 + 3c_3 + 2c_4 & = & 0 \\\\\nc_1 -5c_2 + 7c_3 + 8c_4 & = & 0 \\\\\n-c_1 +4c_2 - 6c_3 \\quad\\quad & = & 0 \\\\\n\\end{matrix}\n\\]\n이 시스템의 계수 행렬의 RREF를 살펴보면 4개의 열 각각에 피벗이 없다는 것을 알 수 있는데, 이는 시스템이 비차분 해를 가지고 있으며 다항식 집합이 선형적으로 독립적이지 않다는 것을 의미합니다.\n\nimport numpy as np\nimport linear_solver as ls\n\nA = np.array([[3,0,6,-2],[2,1,3,2],[1,-5,7,8],[-1,4,-6,0]])\nprint(ls.full_row_reduction(A))\n\n[[ 1.  0.  2.  0.]\n [ 0.  1. -1.  0.]\n [ 0.  0.  0.  1.]\n [ 0.  0.  0.  0.]]\n\n\n다항식을 구성하는 다항식에는 특별한 것이 없습니다. 일반적으로 차수 \\(n\\) 이하의 다항식의 집합을 \\(\\mathbb{P}_n\\)이라고 하며, \\(n\\)의 임의의 선택에 대한 벡터 공간이기도 합니다.\n\nExample 2: Matrices\n행렬 대수에서는 열이 하나뿐인 행렬을 일반적으로 벡터라고 하며, 열이 하나인 행렬을 계산하기 위해 행렬의 대수를 특별히 정의할 필요가 없다는 점을 소개하였습니다. 일반적으로 행렬의 선형 조합을 계산하는 데 필요한 대수적 방법은 열이 하나인 행렬의 선형 조합을 계산하는 데 필요한 대수적 방법은 다르지 않습니다. 그렇다면 여러 열을 가진 행렬도 단일 열을 가진 행렬과 마찬가지로 벡터라고 생각하는 것이 자연스럽습니다. 어떤 의미에서 우리가 벡터라고 부르는 단일 열 행렬은 특수한 유형의 행렬일 뿐입니다. 그러나 벡터 공간의 공식적인 정의에 따르면, 행렬 덧셈과 스칼라 곱셈 연산이 모든 대수적 요구 사항을 충족하기 때문에 주어진 모양의 모든 행렬의 집합이 벡터 공간을 구성합니다. 이러한 의미에서 행렬은 벡터 공간을 구성하는 객체이므로 벡터입니다. 이 용어가 혼란스러운 것은 당연합니다.\n구체적인 예로, \\(\\mathbb{M}_{2 \\times 3}\\) 기호를 할당하는 모든 \\(2 \\times 3\\) 행렬을 고려해 보겠습니다. 두 개의 행렬을 선택하고 임의의 선형 조합을 형성하면 또 다른 \\(2 \\times 3\\) 행렬을 얻을 수 있습니다.\n\\[\n\\begin{matrix}\nc_1A + c_2B =\nc_1\\left[ \\begin{array}{ccc} a_{11} & a_{12} & a_{13} \\\\ a_{21} & a_{22} & a_{23}  \\end{array}\\right] +\nc_2\\left[ \\begin{array}{ccc} b_{11} & b_{12} & b_{13} \\\\ b_{21} & b_{22} & b_{23}  \\end{array}\\right] =\n\\left[ \\begin{array}{ccc} c_1a_{11}+c_2b_{11} & c_1a_{12}+c_2b_{12} & c_1a_{13}+c_2b_{13} \\\\\nc_1a_{21}+c_2b_{21} & c_1a_{22}+c_2b_{22} & c_1a_{23}+c_2b_{23}  \\end{array}\\right]\n\\end{matrix}\n\\]\n이러한 대수 연산은 유효한 벡터 공간에 필요한 모든 요건을 충족하므로 검증에 대한 자세한 설명은 생략하겠습니다.\n표준 기준 역할을 하는 다음과 같은 행렬 모음을 작성할 수 있으며, 이를 \\(\\alpha\\)라고 부릅니다.\n\\[\n\\begin{matrix}\nE_1 = \\left[ \\begin{array}{ccc} 1 & 0 & 0 \\\\ 0 & 0 & 0  \\end{array}\\right] \\hspace{1cm}\nE_3 = \\left[ \\begin{array}{ccc} 0 & 1 & 0 \\\\ 0 & 0 & 0  \\end{array}\\right] \\hspace{1cm}\nE_5 = \\left[ \\begin{array}{ccc} 0 & 0 & 1 \\\\ 0 & 0 & 0  \\end{array}\\right] \\hspace{1cm}\n\\end{matrix}\n\\]\n\\[\n\\begin{matrix}\nE_2 = \\left[ \\begin{array}{ccc} 0 & 0 & 0 \\\\ 1 & 0 & 0  \\end{array}\\right] \\hspace{1cm}\nE_4 = \\left[ \\begin{array}{ccc} 0 & 0 & 0 \\\\ 0 & 1 & 0  \\end{array}\\right] \\hspace{1cm}\nE_6 = \\left[ \\begin{array}{ccc} 0 & 0 & 0 \\\\ 0 & 0 & 1  \\end{array}\\right] \\hspace{1cm}\n\\end{matrix}\n\\]\n이제 행렬 \\(B\\)와 기저 \\(\\alpha\\)에 대한 \\(B\\)의 좌표 벡터를 구분해 보겠습니다.\n\\[\n\\begin{matrix}\nB = \\left[ \\begin{array}{ccc} 2 & 0 & 5 \\\\ 1 & -1 & 2  \\end{array}\\right] \\hspace{1cm}\n\\left [B\\right]_{\\alpha} = \\left[ \\begin{array}{r} 2\\\\1\\\\0\\\\-1\\\\5\\\\2  \\end{array}\\right] \\hspace{1cm}\n\\end{matrix}\n\\]\n좌표 벡터 \\(\\left[B\\right]_{\\alpha}\\) 는 \\(\\mathbb{R}^6\\) 의 벡터로, 행렬 \\(B\\) 를 기저 \\(\\alpha\\) 의 원소들의 선형 조합으로 조립하는 방법에 대한 설명을 제공합니다."
  },
  {
    "objectID": "14_Vector_Space_Examples.html#예제-3-functions",
    "href": "14_Vector_Space_Examples.html#예제-3-functions",
    "title": "벡터 공간의 예",
    "section": "예제 3: Functions",
    "text": "예제 3: Functions\n세 번째 예로, \\(C\\left[0,1\\right]\\) 기호로 주어지는 \\([0,1]\\) 간격의 모든 연속 함수의 집합을 살펴봅니다. \\(f\\)와 \\(g\\)가 이러한 두 함수이고 \\(c\\)가 스칼라라면, 함수 대수를 사용하여 \\(cf\\)와 \\(f+g\\)를 정의할 수 있습니다.\n\\[\n\\begin{matrix}\n(cf)(x) & = & c(f(x)) \\\\\n(f + g)(x) & = & f(x) + g(x)\n\\end{matrix}\n\\]\n이러한 함수들의 대수적 조합은 \\(C\\left[0,1\\right]\\)를 벡터 공간으로 만들기 위한 모든 요건을 충족합니다. 이 공간은 유한 차원을 갖지 않는다는 점에서 다른 예와 상당히 다릅니다. \\(C\\left[0,1\\right]\\)의 모든 기저에는 무한한 수의 함수가 포함되어야 합니다. 이러한 이유로 함수 집합이 선형적으로 독립적인지 확인하기 위해 이전 예제에서와 같은 계산을 쉽게 수행할 수 없습니다. 하지만 이 예제는 나중에 응용 프로그램에서 사용할 것입니다."
  },
  {
    "objectID": "20_Matrix_Representations.html",
    "href": "20_Matrix_Representations.html",
    "title": "행렬의 표현",
    "section": "",
    "text": "선형 변환과 행렬 대수 사이의 핵심적인 연결 고리는 모든 선형 변환이 행렬 곱셈으로 수행될 수 있다는 사실입니다. 따라서 어떤 식으로든 행렬을 선형 변환과 연관시키는 것은 당연한 일입니다. 반대로 행렬 곱셈을 수행할 때 행렬이 나타내는 관련 선형 변환을 고려하는 것은 매우 자연스러운 일입니다. 이런 식으로 행렬 곱셈은 한 공간의 벡터를 다른 공간의 벡터에 매핑하는 수단으로 볼 수 있습니다.\n행렬 표현을 구하는 가장 일반적인 경우를 다루는 대신 \\(\\mathbb{R}^n\\)에서 \\(\\mathbb{R}^m\\)로의 선형 변환을 고려해 보겠습니다. 선형 변환의 정의 속성은 \\(\\mathbb{R}^n\\)의 기저에 있는 각 요소의 이미지(출력)를 지정하는 것으로 설명할 수 있음을 의미합니다. \\(T\\)가 우리의 변환이고, \\(\\beta = \\{V_1, V_2,..., V_n\\}\\)가 \\(\\mathbb{R}^n\\)의 기저이며, 이미지 \\(T(V_1)\\), \\(T(V_2)\\), …, \\(T(V_n)\\)를 알고 있다고 가정해 봅시다. 이것은 \\(\\mathbb{R}^n\\)에서 임의의 \\(X\\)에 대한 \\(T(X)\\)를 계산하는 데 필요한 유일한 정보입니다. 먼저 \\(X\\)를 기저의 관점에서 \\(X = c_1V_1 + c_2V_2 + ... c_nV_n\\)로 표현한 다음 변환의 선형성을 사용합니다.\n\\[\n\\begin{matrix}\nT(X) = T(c_1V_1 + c_2V_2 + ... c_nV_n) = c_1T(V_1) + c_2T(V_2) + ... c_nT(V_n)\n\\end{matrix}\n\\]\n행렬과 연결하기 위해서는 이 방정식의 오른쪽이 행렬-벡터 곱셈으로 표현될 수 있다는 것을 인식해야 합니다. 행렬의 열은 기저 벡터의 이미지이고, 벡터는 기저 \\(\\beta\\)에 대한 \\(X\\)의 좌표 벡터입니다.\n\\[\n\\begin{matrix}\nT(X) =  c_1T(V_1) + c_2T(V_2) + ... c_nT(V_n) = \\left[ \\begin{array}{c|c|c|c} & & & \\\\\nT(V_1) & T(V_2) & ... & T(V_n) \\\\ & & & \\end{array} \\right]\n\\left[ \\begin{array}{c} c_1 \\\\ c_2 \\\\ \\vdots \\\\ c_n \\end{array} \\right]\n\\end{matrix}\n\\]\n따라서 선형 변환을 나타내는 행렬은 \\(\\mathbb{R}^n\\)을 설명하기 위해 선택한 기저에 따라 달라지며, 이는 기저를 선택할 때마다 다른 행렬을 제공한다는 것을 의미합니다. 이 섹션에서는 표준 기저와 관련된 행렬 표현으로 주의를 제한하겠습니다."
  },
  {
    "objectID": "20_Matrix_Representations.html#표준-행렬-표현",
    "href": "20_Matrix_Representations.html#표준-행렬-표현",
    "title": "행렬의 표현",
    "section": "표준 행렬 표현",
    "text": "표준 행렬 표현\n선형 변환의 표준 기저 \\(\\alpha = \\{E_1, E_2, ..., E_n\\}\\)을 선택하면, 선형 변환의 행렬 표현을 표준 행렬 표현이라고 부릅니다. 이 행렬은 이전 장에서 사용한 다른 모든 행렬과 마찬가지로 일반 행렬이지만 약간 다른 표기법을 도입합니다. 변환의 레이블로 \\(T\\)를 사용하는 경우, \\(T\\)의 표준 행렬 표현을 나타내기 위해 \\(\\left[T\\right]\\)라는 표기법을 사용할 것입니다.\n\n예제 1: Transformation from \\(\\mathbb{R}^2\\) to \\(\\mathbb{R}^4\\)\n다음 이미지가 정의된 \\(T:\\mathbb{R}^2 \\to \\mathbb{R}^4\\) 로의 변환을 생각해 보겠습니다.\n\\[\n\\begin{matrix}\nT\\left(\\left[\\begin{array}{r} 1\\\\0 \\end{array}\\right]\\right)= \\left[\\begin{array}{r} 2\\\\0\\\\1\\\\1 \\end{array}\\right] \\hspace{1cm}  \nT\\left(\\left[\\begin{array}{r} 0\\\\1 \\end{array}\\right]\\right)= \\left[\\begin{array}{r} 0\\\\1\\\\-1\\\\4 \\end{array}\\right]\n\\end{matrix}\n\\]\n표준 행렬 표현은 이러한 이미지를 열로 사용하여 구축됩니다.\n\\[\n\\begin{matrix}\n\\left[T\\right] =\\left[\\begin{array}{rr} 2 & 0 \\\\ 0 & 1 \\\\ 1 & -1 \\\\ 1 & 4 \\end{array}\\right]  \n\\end{matrix}\n\\]\n이제 \\(X\\)가 \\(\\mathbb{R}^2\\)의 다른 벡터라면, \\(T(X)\\)를 행렬-벡터 곱 \\(\\left[T\\right]X\\)로 계산할 수 있습니다.\n\\[\n\\begin{matrix}\nX = \\left[\\begin{array}{r} 5 \\\\ -2 \\end{array}\\right] \\hspace{1cm} \\to \\hspace{1cm}\nT(X) = \\left[T\\right]X =\\left[\\begin{array}{rr} 2 & 0 \\\\ 0 & 1 \\\\ 1 & -1 \\\\ 1 & 4 \\end{array}\\right] \\left[\\begin{array}{r} 5 \\\\ -2 \\end{array}\\right] =\n5\\left[\\begin{array}{r} 2\\\\0\\\\1\\\\1 \\end{array}\\right] -\n2\\left[\\begin{array}{r} 0\\\\1\\\\-1\\\\4 \\end{array}\\right] =\n\\left[\\begin{array}{r} 10\\\\2\\\\3\\\\-3 \\end{array}\\right]\n\\end{matrix}\n\\]\n\n\n예제 2: Transformation from \\(\\mathbb{R}^3\\) to \\(\\mathbb{R}^3\\)\n선형 변환 \\(L:\\mathbb{R}^3 \\to \\mathbb{R}^3\\)은 다음과 같은 공식으로 정의할 수 있습니다.\n\\[\n\\begin{matrix}\nL \\left(\\left[\\begin{array}{r} x_1 \\\\ x_2 \\\\ x_3 \\end{array} \\right]\\right) =\n\\left[\\begin{array}{c} x_1 - x_3 \\\\ 3x_1 -x_2 + 2x_3  \\\\ 2x_1 + 8x_2 \\end{array} \\right]\n\\end{matrix}\n\\]\n\\(L\\)의 표준 행렬 표현을 구하기 위해 먼저 공식을 적용하여 표준 기저의 이미지를 생성한 다음, 이를 조합하여 \\(\\left[L\\right]\\)를 형성합니다.\n\\[\n\\begin{matrix}\nL\\left(\\left[\\begin{array}{r} 1\\\\0\\\\0 \\end{array}\\right]\\right)= \\left[\\begin{array}{r} 1\\\\3\\\\2 \\end{array}\\right] \\hspace{1cm}  \nL\\left(\\left[\\begin{array}{r} 0\\\\1\\\\0 \\end{array}\\right]\\right)= \\left[\\begin{array}{r} 0\\\\-1\\\\8 \\end{array}\\right] \\hspace{1cm}  \nL\\left(\\left[\\begin{array}{r} 0\\\\0\\\\1 \\end{array}\\right]\\right)= \\left[\\begin{array}{r} -1\\\\2\\\\0 \\end{array}\\right]\n\\end{matrix}\n\\]\n\\[\n\\begin{matrix}\n\\left[L\\right] = \\left[\\begin{array}{rrr} 1 & 0 & -1 \\\\ 3 & -1 & 2 \\\\ 2 & 8 & 0 \\end{array}\\right]\n\\end{matrix}\n\\]"
  },
  {
    "objectID": "20_Matrix_Representations.html#rref를-사용한-분석",
    "href": "20_Matrix_Representations.html#rref를-사용한-분석",
    "title": "행렬의 표현",
    "section": "RREF를 사용한 분석",
    "text": "RREF를 사용한 분석\n이제 선형 변환을 행렬-벡터 곱셈으로 표현할 수 있게 되었으므로 이전 장에서 배운 내용을 사용하여 선형 변환이 반전 가능한지 확인할 수 있습니다. 변환 \\(T:\\mathbb{R}^n \\to \\mathbb{R}^m\\)이 표준 행렬 표현 \\([T]\\)를 가지며, 역변환 \\(T^{-1}:\\mathbb{R}^m \\to \\mathbb{R}^n\\)이 존재하는지 알고 싶다고 가정해 봅시다. 선형 방정식 \\([T]X = B\\)가 \\(\\mathbb{R}^m\\)의 모든 \\(B\\)에 대해 고유한 해를 갖는지 알아야 합니다.\n일반 선형 시스템의 논의를 되돌아보면, 이 시스템과 관련된 RREF 마지막 열에 피벗이 있는 경우 \\([T]X = B\\) 시스템이 일관성이 없음을 알 수 있습니다. 이것이 가능한 유일한 방법은 행렬 \\([T]\\)에 피벗이 없는 행이 있는 경우인데, 행당 피벗이 하나 이상 있을 수 없기 때문입니다. 또한 \\([T]\\)의 각 열에 피벗이 있을 때 \\([T]X=B\\)는 고유한 해를 갖는다는 것을 발견했습니다. 따라서 \\([T]X=B\\)는 행렬 \\([T]\\)의 각 행과 각 열에 피벗이 있을 때 정확히 \\(\\mathbb{R}^m\\)의 모든 \\(B\\)에 대해 고유한 해를 갖습니다. 이 경우 선형 변환 \\(T\\)는 반전이 가능하며 행렬 \\([T]\\)는 역을 갖습니다.\n선형 변환에는 이와 매우 밀접한 관련이 있는 두 가지 다른 속성이 있습니다.\n\n선형 시스템 \\([T]X=B\\)가 \\(\\mathbb{R}^m\\)의 모든 \\(B\\)에 대해 적어도 하나의 해를 갖는 경우, 변환은 또는 \\(\\mathbb{R}^m\\)이라고 합니다. 이 경우, \\(\\mathbb{R}^m\\)의 모든 벡터 \\(B\\)에 대해 \\(\\mathbb{R}^n\\)에는 적어도 하나의 벡터 \\(X\\)가 존재하므로 \\(T(X)=B\\)가 됩니다. 행렬 \\([T]\\)가 모든 행에 피벗을 가질 때마다 변환 \\(T\\)가 켜집니다.\n선형 시스템 \\([T]X=B\\)가 \\(\\mathbb{R}^m\\)의 모든 \\(B\\)에 대해 *최대 하나의 해를 갖는 경우, 선형 변환은 일대일이라고 합니다. 이 경우, \\(\\mathbb{R}^n\\)의 두 벡터는 \\(\\mathbb{R}^m\\)의 동일한 벡터로 전송되지 않습니다. 행렬 \\([T]\\)가 모든 열에 피벗을 가질 때마다 변환 \\(T\\)는 일대일입니다.\n\n변환은 일대일 변환인 경우에만 반전이 가능합니다.\n각 열의 최대 하나의 피벗과 행당 하나의 피벗이 있을 수 있다는 점을 염두에 둔다면, \\(m\\)과 \\(n\\)의 상대적인 크기에 따라 이러한 속성에 대한 추가 진술을 할 수 있습니다. \\(T:\\mathbb{R}^n \\to \\mathbb{R}^m\\)일 경우, \\(m&gt;n\\)인 경우 \\(T\\)는 \\(\\mathbb{R}^m\\) 위에 있을 수 없고, \\(m&lt;n\\)인 경우 일대일일 수 없습니다. \\(m=n\\)일 때만 \\(T\\)가 반전될 수 있습니다.\n예제를 살펴보겠습니다. 예제 1에서 행렬 \\([T]\\)는 \\(4 \\times 2\\)입니다. 행렬은 최대 두 개의 피벗(열당 최대 하나)을 가질 수 있으므로 각 행에 피벗을 가질 수 없다는 것을 알고 있습니다. 각 열에 피벗이 있는지 확인하기 위해 RREF를 계산할 수 있습니다.\n\nimport numpy as np\nimport linear_solver as ls\n\nT = np.array([[2, 0],[0,1],[1, -1],[1,4]])\nprint(ls.full_row_reduction(T))\n\n[[1. 0.]\n [0. 1.]\n [0. 0.]\n [0. 0.]]\n\n\n이 경우 변환 \\(T\\)는 일대일(one-to-one)이지만 전사(onto)는 아닙니다.\n예제 2에서 행렬 \\([L]\\)은 \\(3 \\times 3\\)이며, 피벗 위치를 결정하기 위해 RREF를 계산해야 합니다.\n\nL=np.array([[1,0,-1],[3,-1,2],[2,8,0]])\nprint(ls.full_row_reduction(L))\n\n[[1. 0. 0.]\n [0. 1. 0.]\n [0. 0. 1.]]\n\n\n행렬 표현은 각 행과 열에 피벗이 있으므로 변환 \\(L\\)은 반전 가능합니다."
  },
  {
    "objectID": "22_Applications_LT.html",
    "href": "22_Applications_LT.html",
    "title": "선형 변환의 응용",
    "section": "",
    "text": "컴퓨터 그래픽은 기본적으로 꼭짓점(모서리)으로 정의되는 삼각형이나 사각형과 같은 수많은 기본 기하학적 도형으로 구성됩니다. 이러한 도형을 효율적으로 조작하는 능력은 컴퓨터 그래픽 분야에서 기본적으로 필요한 능력입니다. 선형 변환은 전단 및 반사와 같은 효과를 통해 기본 도형에서 복잡한 도형을 생성하는 데 사용할 수 있으며, 애니메이션 장면에 필요한 이미지 시퀀스를 생성하기 위해 도형을 회전 및 변환하는 데에도 사용할 수 있습니다.\n최신 비디오 게임에서 3차원 장면을 렌더링하는 소프트웨어는 애니메이션의 각 프레임에서 수백만 개의 정점 좌표를 처리해야 합니다. 소프트웨어를 실행하는 데 사용되는 일반적인 하드웨어는 초당 약 60프레임을 생성할 수 있습니다. 장면에 정점을 배치하는 것 외에도 색상과 음영을 제공하고 3차원 장면을 2차원 화면에 투사하는 등의 다른 계산이 필요합니다. 이러한 맥락에서 알고리즘, 소프트웨어, 하드웨어의 효율성은 모두 최종 결과물의 품질에 중요한 역할을 합니다.\n컴퓨터 그래픽의 좌표를 조작하기 위해 행렬 곱셈을 사용하면 두 가지 주요 이점이 있습니다. 행렬 표현은 여러 변환을 단일 변환으로 병합하는 데 사용할 수 있습니다. 예를 들어, 회전과 배율 변환을 적용하는 대신 앞서 한 것처럼 관련 행렬을 곱하면 두 연산을 단일 연산으로 쉽게 병합할 수 있습니다. 행렬 곱셈으로 연산을 구성할 때의 또 다른 장점은 전용 하드웨어(그래픽 처리 장치)가 이러한 연산을 대량으로 처리하도록 특별히 설계되었다는 점입니다.\n회전, 반사, 전단을 수행하기 위한 행렬의 구성은 이미 평면 변환에서 설명한 바 있습니다. 여기서는 선형 변환이 아닌 변환을 수행하기 위해 행렬 곱셈을 사용하는 방법을 보여드리겠습니다."
  },
  {
    "objectID": "22_Applications_LT.html#computer-graphics",
    "href": "22_Applications_LT.html#computer-graphics",
    "title": "선형 변환의 응용",
    "section": "",
    "text": "컴퓨터 그래픽은 기본적으로 꼭짓점(모서리)으로 정의되는 삼각형이나 사각형과 같은 수많은 기본 기하학적 도형으로 구성됩니다. 이러한 도형을 효율적으로 조작하는 능력은 컴퓨터 그래픽 분야에서 기본적으로 필요한 능력입니다. 선형 변환은 전단 및 반사와 같은 효과를 통해 기본 도형에서 복잡한 도형을 생성하는 데 사용할 수 있으며, 애니메이션 장면에 필요한 이미지 시퀀스를 생성하기 위해 도형을 회전 및 변환하는 데에도 사용할 수 있습니다.\n최신 비디오 게임에서 3차원 장면을 렌더링하는 소프트웨어는 애니메이션의 각 프레임에서 수백만 개의 정점 좌표를 처리해야 합니다. 소프트웨어를 실행하는 데 사용되는 일반적인 하드웨어는 초당 약 60프레임을 생성할 수 있습니다. 장면에 정점을 배치하는 것 외에도 색상과 음영을 제공하고 3차원 장면을 2차원 화면에 투사하는 등의 다른 계산이 필요합니다. 이러한 맥락에서 알고리즘, 소프트웨어, 하드웨어의 효율성은 모두 최종 결과물의 품질에 중요한 역할을 합니다.\n컴퓨터 그래픽의 좌표를 조작하기 위해 행렬 곱셈을 사용하면 두 가지 주요 이점이 있습니다. 행렬 표현은 여러 변환을 단일 변환으로 병합하는 데 사용할 수 있습니다. 예를 들어, 회전과 배율 변환을 적용하는 대신 앞서 한 것처럼 관련 행렬을 곱하면 두 연산을 단일 연산으로 쉽게 병합할 수 있습니다. 행렬 곱셈으로 연산을 구성할 때의 또 다른 장점은 전용 하드웨어(그래픽 처리 장치)가 이러한 연산을 대량으로 처리하도록 특별히 설계되었다는 점입니다.\n회전, 반사, 전단을 수행하기 위한 행렬의 구성은 이미 평면 변환에서 설명한 바 있습니다. 여기서는 선형 변환이 아닌 변환을 수행하기 위해 행렬 곱셈을 사용하는 방법을 보여드리겠습니다."
  },
  {
    "objectID": "22_Applications_LT.html#translation",
    "href": "22_Applications_LT.html#translation",
    "title": "선형 변환의 응용",
    "section": "Translation",
    "text": "Translation\n변환은 모든 점을 같은 방향으로 같은 양만큼 이동시키는 변환입니다. 아래는 모든 점이 \\(T:\\mathbb{R}^2 \\to \\mathbb{R}^2\\) 변환에 의해 오른쪽으로 3단위 이동(변환)하고 1단위 위로 이동하는 예입니다. 그림에서는 도형을 정의하는 여러 점과 변환 아래 해당 이미지를 표시합니다.\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ncoords = np.array([[0,0],[0,3],[1,3],[1,1],[2,1],[2,0],[0,0]])\ncoords = coords.transpose()\n\nx = coords[0,:]\ny = coords[1,:]\n\n## Compute translation by adding 3 to x coordinates and 1 to y coordinates\nx_translated = np.copy(x)\ny_translated = np.copy(y)\n\nfor i in range(x.shape[0]):\n x_translated[i] += 3\n y_translated[i] += 1\n\n\n# Create the figure and axes objects\nfig, ax = plt.subplots()\n\n# Plot the points.\nax.plot(x,y,'ro')\nax.plot(x_translated,y_translated,'bo')\n\n# Connect the points by lines\nax.plot(x,y,'r',ls=\"--\")\nax.plot(x_translated,y_translated,'b')\n\n# Edit some settings \nax.axvline(x=0,color=\"k\",ls=\":\")\nax.axhline(y=0,color=\"k\",ls=\":\")\nax.grid(True)\nax.axis([-1,6,-1,6])\nax.set_aspect('equal')\nax.set_title(\"Translation\");\n\n\n\n\n좌표 변환은 컴퓨터 그래픽에서 유용하지만 선형 변환은 아닙니다. 그 이유를 알아보기 위해 벡터 \\(X\\)의 이미지에 대한 공식을 작성한 다음 임의의 벡터 \\(X\\)와 \\(Y\\)에 대해 \\(T(X+Y)가 \\neq T(X)+T(Y)\\)임을 확인합니다.\n\\[\n\\begin{matrix}\nT(X) = X + \\left[ \\begin{array}{r} 3 \\\\ 1 \\end{array} \\right]\n\\end{matrix}\n\\]\n\\[\n\\begin{matrix}\nT(X+Y) = (X + Y) + \\left[ \\begin{array}{r} 3 \\\\ 1 \\end{array} \\right]\n\\end{matrix}\n\\]\n\\[\n\\begin{matrix}\nT(X) + T(Y) = X + \\left[ \\begin{array}{r} 3 \\\\ 1 \\end{array} \\right] + Y + \\left[ \\begin{array}{r} 3 \\\\ 1 \\end{array} \\right]\n= (X + Y) + \\left[ \\begin{array}{r} 6 \\\\ 2 \\end{array} \\right]\n\\end{matrix}\n\\]\n\\(T\\)가 선형이 아니라는 사실은 이 변환이 현재 상태에서는 행렬 곱셈으로 표현될 수 없음을 의미합니다.\n변환을 사용해야 하기 때문에 행렬 곱셈과 관련 이점을 통합하기 위한 표준 방법이 개발되었습니다. 이 방법을 사용하려면 \\(\\mathbb{R}^2\\)를 \\(\\mathbb{R}^3\\) 내의 평면으로 간주해야 합니다. 그런 다음 해당 평면 내에서 변환의 효과를 갖는 선형 변환 \\(L:\\mathbb{R}^3 \\to \\mathbb{R}^3\\)로 구성할 수 있습니다. 위에서 정의한 변환에 대한 세부 사항을 보여드리겠습니다.\n먼저, \\(\\mathbb{R}^2\\)에 있는 한 점의 좌표 \\((x_1,x_2)\\)를 \\(x_3=1\\) 평면에서 \\(\\mathbb{R}^3\\)에 있는 한 점의 좌표 \\((x_1,x_2,1)\\)와 연관시킵니다. 이러한 새로운 좌표를 동질 좌표라고 합니다. 그런 다음 \\(x_1x_2\\) 평면에 평행하고 원하는 변환 방향으로 전단을 나타내는 선형 변환 \\(L:\\mathbb{R}^3 \\to \\mathbb{R}^3\\)을 생성할 수 있습니다. L$이 \\(x_3=1\\) 평면의 점에 미치는 영향은 \\(x_3=1\\) 평면 내에서의 이동입니다. 여기서 \\(A\\)는 다음과 같은 행렬로 \\(L(X)=AX\\)를 정의합니다.\n\\[\n\\begin{matrix}\nA = \\left[ \\begin{array}{rrr} 1 & 0 & 3 \\\\ 0 & 1 & 1 \\\\ 0 & 0 & 1 \\end{array} \\right]\n\\end{matrix}\n\\]\n\\(A\\)의 열은 표준 기저 벡터 \\(\\{E_1, E_2, E_3\\}\\)의 이미지라는 것을 기억합니다. 이 경우 \\(E_1\\)과 \\(E_2\\)는 변하지 않고, \\(E_3\\)은 원하는 방향으로 전단됩니다. 우리는 \\(L\\)이 의도한 효과를 낸다는 것을 관찰합니다.\n\\[\n\\begin{matrix}\nL(X) = AX = \\left[ \\begin{array}{rrr} 1 & 0 & 3 \\\\ 0 & 1 & 1 \\\\ 0 & 0 & 1 \\end{array} \\right]\n\\left[ \\begin{array}{r} x_1 \\\\ x_2 \\\\ 1 \\end{array} \\right] =\n\\left[ \\begin{array}{c} x_1+3 \\\\ x_2+1 \\\\ 1 \\end{array} \\right]\n\\end{matrix}\n\\]\n마지막으로, 좌표 \\((x_1+3, x_2+1)\\)를 갖는 \\(\\mathbb{R}^2\\)의 점을 \\(L(X)\\)와 연결합니다. 이제 행렬 곱셈을 사용하는 NumPy로 수정된 계산을 살펴보겠습니다.\n\n# Form a matrix of coordinates with rows x, y, 1\nOnes = np.ones((1,7))\ncoords = np.vstack((x,y,Ones))\n\n# Define the matrix for the transfomation L\nA = np.array([[1,0,3],[0,1,1],[0,0,1]])\n\n## Compute translation by matrix multiplication\ncoords_translated = A@coords\n\n## Slice off the first and second rows. These are the coords of the translated points\nx_translated = coords_translated[0,:]\ny_translated = coords_translated[1,:]\n\n# Create the figure and axes objects\nfig, ax = plt.subplots()\n\n# Plot the points.\nax.plot(x,y,'ro')\nax.plot(x_translated,y_translated,'bo')\n\n# Connect the points by lines\nax.plot(x,y,'r',ls=\"--\")\nax.plot(x_translated,y_translated,'b')\n\n# Edit some settings \nax.axvline(x=0,color=\"k\",ls=\":\")\nax.axhline(y=0,color=\"k\",ls=\":\")\nax.grid(True)\nax.axis([-1,6,-1,6])\nax.set_aspect('equal')\nax.set_title(\"Translation\");\n\n\n\n\n계산을 자세히 살펴보면, 변환된 도형의 좌표를 계산하는 이 방법은 배열을 통해 직접 좌표를 조작했던 첫 번째 시도보다 실제로 더 많은 연산이 필요하다는 것을 알 수 있습니다. 그러나 기억해야 할 중요한 점은 변환을 행렬 곱셈으로 표현할 수 있다는 것은 회전과 같은 다른 연산과 병합하여 단일 행렬을 곱하여 두 연산을 모두 수행할 수 있다는 것을 의미합니다.\n3차원에서 도형의 이동도 비슷한 방식으로 \\(\\mathbb{R}^3\\)의 각 좌표 집합 \\((x_1, x_2, x_3)\\)을 \\(\\mathbb{R}^4\\)의 점 \\((x_1, x_2, x_3, 1)\\)과 연관시켜서 수행할 수 있습니다."
  },
  {
    "objectID": "22_Applications_LT.html#이산-동적-시스템",
    "href": "22_Applications_LT.html#이산-동적-시스템",
    "title": "선형 변환의 응용",
    "section": "이산 동적 시스템",
    "text": "이산 동적 시스템\n이전 장에서 살펴본 것처럼, 여러 구성 요소가 있는 구조를 하나의 벡터로 설명하는 것이 유용할 때가 많습니다. 어떤 프로세스로 인해 구조가 시간에 따라 변화하는 경우, 특정 시점의 구조의 상태를 설명하기 때문에 이 벡터를 상태 벡터라고 부르는 것이 일반적입니다. 이러한 동적 프로세스를 불연속적인 시간에 모델링하고 선형 변환을 사용하여 한 시간에서 다음 시간으로의 상태 벡터의 진화를 모델링하는 것은 매우 일반적입니다.\n\\(t=0, 1, 2, 3,...\\) 시점의 상태 벡터 \\(X_0\\), \\(X_1\\), \\(X_2\\), \\(X_3\\)…. 을 사용하여 일련의 벡터를 설명하고자 한다고 가정해 보겠습니다. 우리는 이전 상태 벡터 \\(X_{t-1}\\)만을 기반으로 상태 벡터 \\(X_t\\)를 계산할 것을 제안합니다. 선형 변환을 통해 \\(X_{t-1}\\)에서 \\(X_t\\)로의 전환을 모델링하면 \\(X_t = AX_{t-1}\\)가 되는 행렬이 존재합니다. 이러한 종류의 모델을 이산 동역학 시스템이라고 하며, 경제학에서 생물학에 이르기까지 다양한 분야에서 사용됩니다.\n\\[\n\\begin{matrix}\ns_t & = & 0.95s_{t-1} \\hspace{2cm} + 0.15r_{t-1} \\\\\ni_t & = & 0.05s_{t-1} + 0.80i_{t-1} \\\\\nr_t & = & \\hspace{2cm} 0.20i_{t-1} + 0.85r_{t-1}\n\\end{matrix}\n\\]\n이제 \\(X_t\\)를 구성 요소 \\(s_t\\), \\(i_t\\), \\(r_t\\)가 있는 벡터로 정의할 수 있으므로 행렬 곱셈을 사용하여 방정식을 작성할 수 있습니다.\n\\[\n\\begin{matrix}\nX_t = \\left[ \\begin{array}{r} s_t \\\\ i_t \\\\ r_t \\end{array}\\right] =\n\\left[ \\begin{array}{rrr} 0.95 & 0 & 0.15 \\\\ 0.05 & 0.80 & 0 \\\\ 0 & 0.20 & 0.85 \\end{array}\\right]\n\\left[ \\begin{array}{r} s_{t-1} \\\\ i_{t-1} \\\\ r_{t-1} \\end{array}\\right]=\nAX_{t-1}\n\\end{matrix}\n\\]\n이 행렬 곱셈에 의해 정의된 선형 변환 \\(L:\\mathbb{R}^3 \\to \\mathbb{R}^3\\)은 시간 \\(t-1\\)의 인구 상태를 시간 \\(t\\)의 인구 상태로 매핑합니다. 예를 들어 초기 상태 벡터 \\(X_0\\)에 레이블을 붙이고, 처음에 인구의 5%가 감염되고 나머지 95%가 감수성이 있는 경우 어떤 일이 발생하는지 생각해 보겠습니다.\n\\[\n\\begin{matrix}\nX_0 = \\left[ \\begin{array}{r} 0.95 \\\\ 0.05 \\\\ 0 \\end{array}\\right]\n\\end{matrix}\n\\]\n\\(X_1 = AX_0\\)을 계산합니다.\n\nimport numpy as np\nA = np.array([[0.95, 0, 0.15],[0.05,0.8,0],[0,0.2,0.85]])\n\n## X at time 0\nX_0 = np.array([[0.95],[0.05],[0]])\n\n## Compute X at the next time\nX_1 = A@X_0\n\nprint(X_1)\n\n[[0.9025]\n [0.0875]\n [0.01  ]]\n\n\n변환을 다시 적용하면 \\(X_2 = AX_1 = A^2X_0\\), 즉 \\(t=2\\) 시점의 인구 상태가 됩니다. 일반적으로 변환을 \\(n\\) 번 반복 적용하면 \\(X_n = A^nX_0\\), 즉 미래 $n주 후 인구의 상태가 됩니다. 예를 들어 \\(X_{50}\\)를 계산해 보겠습니다.\n\n## X at time 0\nX = np.array([[0.95],[0.05],[0]])\n\nfor t in range(50):\n    X = A@X\n    \nprint(X)\n\n[[0.63157999]\n [0.15789071]\n [0.2105293 ]]\n\n\n이러한 모델에서는 일반적으로 상태 벡터의 궁극적인 동작에 관심이 집중됩니다. 우리는 인구의 구성이 균형에 도달하는지, 아니면 계속 변화하는지 알고 싶어합니다. 만약 균형에 도달하면 행렬 곱셈을 여러 번 적용하지 않고 직접 계산할 수 있을까요?"
  },
  {
    "objectID": "22_Applications_LT.html#navigating-webpages",
    "href": "22_Applications_LT.html#navigating-webpages",
    "title": "선형 변환의 응용",
    "section": "Navigating webpages",
    "text": "Navigating webpages\n웹 페이지 탐색은 이산 동적 시스템을 사용하여 모델링할 수도 있습니다. 이 모델에서 상태 벡터 \\(X_t\\)의 항목은 브라우저가 시간 \\(t\\)에 특정 페이지에 있을 확률을 나타냅니다. 시간 진행은 브라우저가 한 페이지에서 다른 페이지로 이동하는 것을 나타냅니다. 많은 페이지에는 다른 페이지로 연결되는 링크가 포함되어 있습니다. 이 모델은 브라우저가 링크되지 않은 새 페이지로 이동하는 것보다 새 페이지로 연결되는 링크를 따라갈 가능성이 더 높다고 가정합니다. 목표는 행렬 곱셈으로 정의되는 선형 변환 \\(L\\)을 구축하여 페이지의 링크 구조에 따라 \\(t-1\\) 시점의 확률 벡터를 \\(t\\) 시점의 확률 벡터에 매핑하는 것입니다. 이러한 모델은 Google의 매우 성공적인 검색 엔진의 기반이 된 PageRank 알고리즘의 기초가 되었습니다.\n필요한 행렬 \\(A\\)를 구축하기 위해, \\(a_{ij}\\) 항목은 브라우저가 페이지 \\(j\\)에서 페이지 \\(i\\)로 이동할 확률로 설정됩니다. 고정 열 \\(j\\)의 경우, 항목은 다음 단계에서 브라우저의 위치를 설명하는 확률 분포를 나타냅니다. 따라서 각 열의 항목은 하나에 더해져야 합니다. 모델을 완성하기 위해 몇 가지 추가 가정을 해 보겠습니다.\n\n브라우저는 0.8의 확률로 링크를 따라갑니다.\n페이지의 모든 링크를 따라갈 확률은 동일합니다.\n링크를 따라가지 않는 브라우저는 다음 단계에서 새 페이지에 도달할 확률도 동일합니다.\n브라우저는 각 단계에서 항상 페이지를 변경합니다.\n\n이러한 가정은 행렬을 완전히 정의합니다. 모델에 있는 웹페이지의 수를 \\(n\\)이라고 하면, \\(A\\)는 마지막 가정으로 인해 주 대각선에 0이 있는 \\(n\\ times n\\) 행렬이 됩니다. 특정 페이지 \\(j\\)에 초점을 맞추면 \\(a_{jj} = 0\\)이므로 총 \\(n-1\\) 개의 0이 아닌 항목이 있습니다. 페이지 \\(j\\)가 다른 페이지 \\(k\\)에 대한 링크를 가지고 있다면, \\(i\\)가 링크된 페이지 중 하나의 인덱스인 경우 \\(a_{ij} = 0.8/k + 0.2/(n-1)\\), \\(i\\)가 링크되지 않은 페이지 중 하나의 인덱스인 경우 \\(a_{ij} = 0.2/(n-1)\\)가 됩니다.\n다음은 \\(n=5\\), 1페이지가 2페이지와 5페이지에 링크되고, 2페이지가 5페이지에 링크되고, 3페이지가 2페이지에 링크되고, 4페이지가 1페이지와 2페이지에 링크되고, 5페이지가 다른 모든 페이지에 링크되는 행렬의 예입니다.\n\\[\n\\begin{matrix}\n\\left[ \\begin{array}{ccccc}\n0 & 0.05 & 0.05 & 0.45 & 0.25 \\\\\n0.45 & 0 & 0.85 & 0.45 & 0.25  \\\\\n0.05 & 0.05 & 0 & 0.05 & 0.25  \\\\\n0.05 & 0.05 & 0.05 & 0 & 0.25  \\\\\n0.45 & 0.85 & 0.05 & 0.05 & 0  \\\\\n\\end{array}\\right]\n\\end{matrix}\n\\]\n모델 예시를 완성하기 위해 \\(X_0\\)을 지정합니다. 이 경우 \\(X_0\\)을 하나의 엔트리가 1이고 다른 모든 엔트리가 0인 벡터로 간주하면 가장 쉽게 해석할 수 있습니다. 예를 들어, 다음과 같이 \\(X_0\\)을 선택하면 브라우저가 4페이지에서 탐색을 시작한다는 의미입니다.\n\\[\n\\begin{matrix}\nX_0 = \\left[ \\begin{array}{ccccc} 0 \\\\ 0 \\\\ 0 \\\\ 1 \\\\ 0\n\\end{array}\\right]\n\\end{matrix}\n\\]\n변환을 한 번 적용하면 \\(X_1 = AX_0\\)이 되며, 이는 브라우저가 각 페이지에 있을 확률을 포함하는 벡터를 제공합니다.\n\nA = np.array([[0,0.05,0.05,0.45,0.25],\n              [0.45,0,0.85,0.45,0.25],\n              [0.05,0.05,0,0.05,0.25],\n              [0.05,0.05,0.05,0,0.25],\n              [0.45,0.85,0.05,0.05,0]])\nX_0 = np.array([[0],[0],[0],[1],[0]])\nX_1 = A@X_0\nprint(X_1)\n\n[[0.45]\n [0.45]\n [0.05]\n [0.  ]\n [0.05]]\n\n\n변환을 \\(n\\) 번 적용하면 브라우저가 \\(n\\) 단계의 탐색 후 각 페이지에 도달할 확률을 포함하는 벡터인 \\(X_n\\)이 나옵니다.\n\nX = np.array([[0],[0],[0],[1],[0]])\n\nfor t in range(20):\n    X = A@X\n    \nprint(X)\n\n[[0.15277035]\n [0.29525499]\n [0.11062482]\n [0.11062482]\n [0.33072501]]\n\n\n모집단 모델과 마찬가지로, \\(n\\)이 클 때 \\(X_n\\)의 확률을 예측하여 브라우저가 이러한 종류의 무작위 탐색 후에 어떤 페이지를 방문할 가능성이 높은지를 결정하는 데 관심이 있습니다.\n\nReferences\n\nAllen, Linda J.S. Some Discrete SI, SIR, and SIS epidemic models., Mathematical Biosciences, Vol 124, No. 1, Nov. 1994, pp. 83-105.\nKwak, Jin Ho and Sungpyo Hong. Linear Algebra. 2nd ed., Birkhauser., 2004.\nLay, David, et al. Linear Algebra and its Applications. 5th ed., Pearson., 2016\nLeon, Steven J. Linear Algebra with Applications. 9th ed., Pearson., 2015\nJohn Vince. Mathematics for Computer Graphics. 3rd ed., Springer., 2010"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Index",
    "section": "",
    "text": "2023년 겨울 계절학기에 진행된 “공학선형대수학 (CB3500573-059)”에 사용된 Python 코드 및 간단한 예제등을 모아둔 곳 입니다. 선형대수학 공부에 도움이 되시길 바라니다. 교재는 “응용이 보이는 선형대수학 : 파이썬과 함께하는 선형대수학 이론과 응용”(이건명 2020) 입니다.\n문서 버전 : 0.01 - 초안 작성 중"
  },
  {
    "objectID": "index.html#ref.",
    "href": "index.html#ref.",
    "title": "Index",
    "section": "Ref.",
    "text": "Ref.\n\n\n이건명. 2020. 응용이 보이는 선형대수학 : 파이썬과 함께하는 선형대수학 이론과 응용. 한빛미디어."
  }
]